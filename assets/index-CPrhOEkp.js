function vR(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();var pI=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function q2(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function ZM(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var tw={exports:{}},Bp={};var fI;function JM(){if(fI)return Bp;fI=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,r,i){var a=null;if(i!==void 0&&(a=""+i),r.key!==void 0&&(a=""+r.key),"key"in r){i={};for(var o in r)o!=="key"&&(i[o]=r[o])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:a,ref:r!==void 0?r:null,props:i}}return Bp.Fragment=e,Bp.jsx=t,Bp.jsxs=t,Bp}var mI;function eP(){return mI||(mI=1,tw.exports=JM()),tw.exports}var q=eP(),nw={exports:{}},yt={};var gI;function tP(){if(gI)return yt;gI=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function g(G){return G===null||typeof G!="object"?null:(G=m&&G[m]||G["@@iterator"],typeof G=="function"?G:null)}var x={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},b=Object.assign,v={};function w(G,re,pe){this.props=G,this.context=re,this.refs=v,this.updater=pe||x}w.prototype.isReactComponent={},w.prototype.setState=function(G,re){if(typeof G!="object"&&typeof G!="function"&&G!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,G,re,"setState")},w.prototype.forceUpdate=function(G){this.updater.enqueueForceUpdate(this,G,"forceUpdate")};function N(){}N.prototype=w.prototype;function I(G,re,pe){this.props=G,this.context=re,this.refs=v,this.updater=pe||x}var $=I.prototype=new N;$.constructor=I,b($,w.prototype),$.isPureReactComponent=!0;var E=Array.isArray;function D(){}var F={H:null,A:null,T:null,S:null},L=Object.prototype.hasOwnProperty;function z(G,re,pe){var ve=pe.ref;return{$$typeof:n,type:G,key:re,ref:ve!==void 0?ve:null,props:pe}}function M(G,re){return z(G.type,re,G.props)}function O(G){return typeof G=="object"&&G!==null&&G.$$typeof===n}function H(G){var re={"=":"=0",":":"=2"};return"$"+G.replace(/[=:]/g,function(pe){return re[pe]})}var X=/\/+/g;function te(G,re){return typeof G=="object"&&G!==null&&G.key!=null?H(""+G.key):re.toString(36)}function Z(G){switch(G.status){case"fulfilled":return G.value;case"rejected":throw G.reason;default:switch(typeof G.status=="string"?G.then(D,D):(G.status="pending",G.then(function(re){G.status==="pending"&&(G.status="fulfilled",G.value=re)},function(re){G.status==="pending"&&(G.status="rejected",G.reason=re)})),G.status){case"fulfilled":return G.value;case"rejected":throw G.reason}}throw G}function W(G,re,pe,ve,Ne){var Ee=typeof G;(Ee==="undefined"||Ee==="boolean")&&(G=null);var _e=!1;if(G===null)_e=!0;else switch(Ee){case"bigint":case"string":case"number":_e=!0;break;case"object":switch(G.$$typeof){case n:case e:_e=!0;break;case d:return _e=G._init,W(_e(G._payload),re,pe,ve,Ne)}}if(_e)return Ne=Ne(G),_e=ve===""?"."+te(G,0):ve,E(Ne)?(pe="",_e!=null&&(pe=_e.replace(X,"$&/")+"/"),W(Ne,re,pe,"",function(at){return at})):Ne!=null&&(O(Ne)&&(Ne=M(Ne,pe+(Ne.key==null||G&&G.key===Ne.key?"":(""+Ne.key).replace(X,"$&/")+"/")+_e)),re.push(Ne)),1;_e=0;var je=ve===""?".":ve+":";if(E(G))for(var Be=0;Be<G.length;Be++)ve=G[Be],Ee=je+te(ve,Be),_e+=W(ve,re,pe,Ee,Ne);else if(Be=g(G),typeof Be=="function")for(G=Be.call(G),Be=0;!(ve=G.next()).done;)ve=ve.value,Ee=je+te(ve,Be++),_e+=W(ve,re,pe,Ee,Ne);else if(Ee==="object"){if(typeof G.then=="function")return W(Z(G),re,pe,ve,Ne);throw re=String(G),Error("Objects are not valid as a React child (found: "+(re==="[object Object]"?"object with keys {"+Object.keys(G).join(", ")+"}":re)+"). If you meant to render a collection of children, use an array instead.")}return _e}function ee(G,re,pe){if(G==null)return G;var ve=[],Ne=0;return W(G,ve,"","",function(Ee){return re.call(pe,Ee,Ne++)}),ve}function ie(G){if(G._status===-1){var re=G._result;re=re(),re.then(function(pe){(G._status===0||G._status===-1)&&(G._status=1,G._result=pe)},function(pe){(G._status===0||G._status===-1)&&(G._status=2,G._result=pe)}),G._status===-1&&(G._status=0,G._result=re)}if(G._status===1)return G._result.default;throw G._result}var de=typeof reportError=="function"?reportError:function(G){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var re=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof G=="object"&&G!==null&&typeof G.message=="string"?String(G.message):String(G),error:G});if(!window.dispatchEvent(re))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",G);return}console.error(G)},ge={map:ee,forEach:function(G,re,pe){ee(G,function(){re.apply(this,arguments)},pe)},count:function(G){var re=0;return ee(G,function(){re++}),re},toArray:function(G){return ee(G,function(re){return re})||[]},only:function(G){if(!O(G))throw Error("React.Children.only expected to receive a single React element child.");return G}};return yt.Activity=p,yt.Children=ge,yt.Component=w,yt.Fragment=t,yt.Profiler=r,yt.PureComponent=I,yt.StrictMode=s,yt.Suspense=u,yt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=F,yt.__COMPILER_RUNTIME={__proto__:null,c:function(G){return F.H.useMemoCache(G)}},yt.cache=function(G){return function(){return G.apply(null,arguments)}},yt.cacheSignal=function(){return null},yt.cloneElement=function(G,re,pe){if(G==null)throw Error("The argument must be a React element, but you passed "+G+".");var ve=b({},G.props),Ne=G.key;if(re!=null)for(Ee in re.key!==void 0&&(Ne=""+re.key),re)!L.call(re,Ee)||Ee==="key"||Ee==="__self"||Ee==="__source"||Ee==="ref"&&re.ref===void 0||(ve[Ee]=re[Ee]);var Ee=arguments.length-2;if(Ee===1)ve.children=pe;else if(1<Ee){for(var _e=Array(Ee),je=0;je<Ee;je++)_e[je]=arguments[je+2];ve.children=_e}return z(G.type,Ne,ve)},yt.createContext=function(G){return G={$$typeof:a,_currentValue:G,_currentValue2:G,_threadCount:0,Provider:null,Consumer:null},G.Provider=G,G.Consumer={$$typeof:i,_context:G},G},yt.createElement=function(G,re,pe){var ve,Ne={},Ee=null;if(re!=null)for(ve in re.key!==void 0&&(Ee=""+re.key),re)L.call(re,ve)&&ve!=="key"&&ve!=="__self"&&ve!=="__source"&&(Ne[ve]=re[ve]);var _e=arguments.length-2;if(_e===1)Ne.children=pe;else if(1<_e){for(var je=Array(_e),Be=0;Be<_e;Be++)je[Be]=arguments[Be+2];Ne.children=je}if(G&&G.defaultProps)for(ve in _e=G.defaultProps,_e)Ne[ve]===void 0&&(Ne[ve]=_e[ve]);return z(G,Ee,Ne)},yt.createRef=function(){return{current:null}},yt.forwardRef=function(G){return{$$typeof:o,render:G}},yt.isValidElement=O,yt.lazy=function(G){return{$$typeof:d,_payload:{_status:-1,_result:G},_init:ie}},yt.memo=function(G,re){return{$$typeof:c,type:G,compare:re===void 0?null:re}},yt.startTransition=function(G){var re=F.T,pe={};F.T=pe;try{var ve=G(),Ne=F.S;Ne!==null&&Ne(pe,ve),typeof ve=="object"&&ve!==null&&typeof ve.then=="function"&&ve.then(D,de)}catch(Ee){de(Ee)}finally{re!==null&&pe.types!==null&&(re.types=pe.types),F.T=re}},yt.unstable_useCacheRefresh=function(){return F.H.useCacheRefresh()},yt.use=function(G){return F.H.use(G)},yt.useActionState=function(G,re,pe){return F.H.useActionState(G,re,pe)},yt.useCallback=function(G,re){return F.H.useCallback(G,re)},yt.useContext=function(G){return F.H.useContext(G)},yt.useDebugValue=function(){},yt.useDeferredValue=function(G,re){return F.H.useDeferredValue(G,re)},yt.useEffect=function(G,re){return F.H.useEffect(G,re)},yt.useEffectEvent=function(G){return F.H.useEffectEvent(G)},yt.useId=function(){return F.H.useId()},yt.useImperativeHandle=function(G,re,pe){return F.H.useImperativeHandle(G,re,pe)},yt.useInsertionEffect=function(G,re){return F.H.useInsertionEffect(G,re)},yt.useLayoutEffect=function(G,re){return F.H.useLayoutEffect(G,re)},yt.useMemo=function(G,re){return F.H.useMemo(G,re)},yt.useOptimistic=function(G,re){return F.H.useOptimistic(G,re)},yt.useReducer=function(G,re,pe){return F.H.useReducer(G,re,pe)},yt.useRef=function(G){return F.H.useRef(G)},yt.useState=function(G){return F.H.useState(G)},yt.useSyncExternalStore=function(G,re,pe){return F.H.useSyncExternalStore(G,re,pe)},yt.useTransition=function(){return F.H.useTransition()},yt.version="19.2.1",yt}var yI;function Ax(){return yI||(yI=1,nw.exports=tP()),nw.exports}var Re=Ax();const nP=q2(Re),sP=vR({__proto__:null,default:nP},[Re]);var sw={exports:{}},Vp={},rw={exports:{}},iw={};var xI;function rP(){return xI||(xI=1,(function(n){function e(W,ee){var ie=W.length;W.push(ee);e:for(;0<ie;){var de=ie-1>>>1,ge=W[de];if(0<r(ge,ee))W[de]=ee,W[ie]=ge,ie=de;else break e}}function t(W){return W.length===0?null:W[0]}function s(W){if(W.length===0)return null;var ee=W[0],ie=W.pop();if(ie!==ee){W[0]=ie;e:for(var de=0,ge=W.length,G=ge>>>1;de<G;){var re=2*(de+1)-1,pe=W[re],ve=re+1,Ne=W[ve];if(0>r(pe,ie))ve<ge&&0>r(Ne,pe)?(W[de]=Ne,W[ve]=ie,de=ve):(W[de]=pe,W[re]=ie,de=re);else if(ve<ge&&0>r(Ne,ie))W[de]=Ne,W[ve]=ie,de=ve;else break e}}return ee}function r(W,ee){var ie=W.sortIndex-ee.sortIndex;return ie!==0?ie:W.id-ee.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var u=[],c=[],d=1,p=null,m=3,g=!1,x=!1,b=!1,v=!1,w=typeof setTimeout=="function"?setTimeout:null,N=typeof clearTimeout=="function"?clearTimeout:null,I=typeof setImmediate<"u"?setImmediate:null;function $(W){for(var ee=t(c);ee!==null;){if(ee.callback===null)s(c);else if(ee.startTime<=W)s(c),ee.sortIndex=ee.expirationTime,e(u,ee);else break;ee=t(c)}}function E(W){if(b=!1,$(W),!x)if(t(u)!==null)x=!0,D||(D=!0,H());else{var ee=t(c);ee!==null&&Z(E,ee.startTime-W)}}var D=!1,F=-1,L=5,z=-1;function M(){return v?!0:!(n.unstable_now()-z<L)}function O(){if(v=!1,D){var W=n.unstable_now();z=W;var ee=!0;try{e:{x=!1,b&&(b=!1,N(F),F=-1),g=!0;var ie=m;try{t:{for($(W),p=t(u);p!==null&&!(p.expirationTime>W&&M());){var de=p.callback;if(typeof de=="function"){p.callback=null,m=p.priorityLevel;var ge=de(p.expirationTime<=W);if(W=n.unstable_now(),typeof ge=="function"){p.callback=ge,$(W),ee=!0;break t}p===t(u)&&s(u),$(W)}else s(u);p=t(u)}if(p!==null)ee=!0;else{var G=t(c);G!==null&&Z(E,G.startTime-W),ee=!1}}break e}finally{p=null,m=ie,g=!1}ee=void 0}}finally{ee?H():D=!1}}}var H;if(typeof I=="function")H=function(){I(O)};else if(typeof MessageChannel<"u"){var X=new MessageChannel,te=X.port2;X.port1.onmessage=O,H=function(){te.postMessage(null)}}else H=function(){w(O,0)};function Z(W,ee){F=w(function(){W(n.unstable_now())},ee)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(W){W.callback=null},n.unstable_forceFrameRate=function(W){0>W||125<W?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):L=0<W?Math.floor(1e3/W):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(W){switch(m){case 1:case 2:case 3:var ee=3;break;default:ee=m}var ie=m;m=ee;try{return W()}finally{m=ie}},n.unstable_requestPaint=function(){v=!0},n.unstable_runWithPriority=function(W,ee){switch(W){case 1:case 2:case 3:case 4:case 5:break;default:W=3}var ie=m;m=W;try{return ee()}finally{m=ie}},n.unstable_scheduleCallback=function(W,ee,ie){var de=n.unstable_now();switch(typeof ie=="object"&&ie!==null?(ie=ie.delay,ie=typeof ie=="number"&&0<ie?de+ie:de):ie=de,W){case 1:var ge=-1;break;case 2:ge=250;break;case 5:ge=1073741823;break;case 4:ge=1e4;break;default:ge=5e3}return ge=ie+ge,W={id:d++,callback:ee,priorityLevel:W,startTime:ie,expirationTime:ge,sortIndex:-1},ie>de?(W.sortIndex=ie,e(c,W),t(u)===null&&W===t(c)&&(b?(N(F),F=-1):b=!0,Z(E,ie-de))):(W.sortIndex=ge,e(u,W),x||g||(x=!0,D||(D=!0,H()))),W},n.unstable_shouldYield=M,n.unstable_wrapCallback=function(W){var ee=m;return function(){var ie=m;m=ee;try{return W.apply(this,arguments)}finally{m=ie}}}})(iw)),iw}var bI;function iP(){return bI||(bI=1,rw.exports=rP()),rw.exports}var aw={exports:{}},Us={};var vI;function aP(){if(vI)return Us;vI=1;var n=Ax();function e(u){var c="https://react.dev/errors/"+u;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)c+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+u+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(u,c,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:u,containerInfo:c,implementation:d}}var a=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(u,c){if(u==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return Us.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Us.createPortal=function(u,c){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(e(299));return i(u,c,null,d)},Us.flushSync=function(u){var c=a.T,d=s.p;try{if(a.T=null,s.p=2,u)return u()}finally{a.T=c,s.p=d,s.d.f()}},Us.preconnect=function(u,c){typeof u=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,s.d.C(u,c))},Us.prefetchDNS=function(u){typeof u=="string"&&s.d.D(u)},Us.preinit=function(u,c){if(typeof u=="string"&&c&&typeof c.as=="string"){var d=c.as,p=o(d,c.crossOrigin),m=typeof c.integrity=="string"?c.integrity:void 0,g=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;d==="style"?s.d.S(u,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:g}):d==="script"&&s.d.X(u,{crossOrigin:p,integrity:m,fetchPriority:g,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},Us.preinitModule=function(u,c){if(typeof u=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var d=o(c.as,c.crossOrigin);s.d.M(u,{crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&s.d.M(u)},Us.preload=function(u,c){if(typeof u=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var d=c.as,p=o(d,c.crossOrigin);s.d.L(u,d,{crossOrigin:p,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},Us.preloadModule=function(u,c){if(typeof u=="string")if(c){var d=o(c.as,c.crossOrigin);s.d.m(u,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else s.d.m(u)},Us.requestFormReset=function(u){s.d.r(u)},Us.unstable_batchedUpdates=function(u,c){return u(c)},Us.useFormState=function(u,c,d){return a.H.useFormState(u,c,d)},Us.useFormStatus=function(){return a.H.useHostTransitionStatus()},Us.version="19.2.1",Us}var wI;function wR(){if(wI)return aw.exports;wI=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),aw.exports=aP(),aw.exports}var SI;function oP(){if(SI)return Vp;SI=1;var n=iP(),e=Ax(),t=wR();function s(l){var h="https://react.dev/errors/"+l;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)h+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+l+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function i(l){var h=l,f=l;if(l.alternate)for(;h.return;)h=h.return;else{l=h;do h=l,(h.flags&4098)!==0&&(f=h.return),l=h.return;while(l)}return h.tag===3?f:null}function a(l){if(l.tag===13){var h=l.memoizedState;if(h===null&&(l=l.alternate,l!==null&&(h=l.memoizedState)),h!==null)return h.dehydrated}return null}function o(l){if(l.tag===31){var h=l.memoizedState;if(h===null&&(l=l.alternate,l!==null&&(h=l.memoizedState)),h!==null)return h.dehydrated}return null}function u(l){if(i(l)!==l)throw Error(s(188))}function c(l){var h=l.alternate;if(!h){if(h=i(l),h===null)throw Error(s(188));return h!==l?null:l}for(var f=l,y=h;;){var S=f.return;if(S===null)break;var k=S.alternate;if(k===null){if(y=S.return,y!==null){f=y;continue}break}if(S.child===k.child){for(k=S.child;k;){if(k===f)return u(S),l;if(k===y)return u(S),h;k=k.sibling}throw Error(s(188))}if(f.return!==y.return)f=S,y=k;else{for(var _=!1,V=S.child;V;){if(V===f){_=!0,f=S,y=k;break}if(V===y){_=!0,y=S,f=k;break}V=V.sibling}if(!_){for(V=k.child;V;){if(V===f){_=!0,f=k,y=S;break}if(V===y){_=!0,y=k,f=S;break}V=V.sibling}if(!_)throw Error(s(189))}}if(f.alternate!==y)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?l:h}function d(l){var h=l.tag;if(h===5||h===26||h===27||h===6)return l;for(l=l.child;l!==null;){if(h=d(l),h!==null)return h;l=l.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),g=Symbol.for("react.transitional.element"),x=Symbol.for("react.portal"),b=Symbol.for("react.fragment"),v=Symbol.for("react.strict_mode"),w=Symbol.for("react.profiler"),N=Symbol.for("react.consumer"),I=Symbol.for("react.context"),$=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),D=Symbol.for("react.suspense_list"),F=Symbol.for("react.memo"),L=Symbol.for("react.lazy"),z=Symbol.for("react.activity"),M=Symbol.for("react.memo_cache_sentinel"),O=Symbol.iterator;function H(l){return l===null||typeof l!="object"?null:(l=O&&l[O]||l["@@iterator"],typeof l=="function"?l:null)}var X=Symbol.for("react.client.reference");function te(l){if(l==null)return null;if(typeof l=="function")return l.$$typeof===X?null:l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case b:return"Fragment";case w:return"Profiler";case v:return"StrictMode";case E:return"Suspense";case D:return"SuspenseList";case z:return"Activity"}if(typeof l=="object")switch(l.$$typeof){case x:return"Portal";case I:return l.displayName||"Context";case N:return(l._context.displayName||"Context")+".Consumer";case $:var h=l.render;return l=l.displayName,l||(l=h.displayName||h.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case F:return h=l.displayName||null,h!==null?h:te(l.type)||"Memo";case L:h=l._payload,l=l._init;try{return te(l(h))}catch{}}return null}var Z=Array.isArray,W=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ee=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ie={pending:!1,data:null,method:null,action:null},de=[],ge=-1;function G(l){return{current:l}}function re(l){0>ge||(l.current=de[ge],de[ge]=null,ge--)}function pe(l,h){ge++,de[ge]=l.current,l.current=h}var ve=G(null),Ne=G(null),Ee=G(null),_e=G(null);function je(l,h){switch(pe(Ee,h),pe(Ne,l),pe(ve,null),h.nodeType){case 9:case 11:l=(l=h.documentElement)&&(l=l.namespaceURI)?z$(l):0;break;default:if(l=h.tagName,h=h.namespaceURI)h=z$(h),l=L$(h,l);else switch(l){case"svg":l=1;break;case"math":l=2;break;default:l=0}}re(ve),pe(ve,l)}function Be(){re(ve),re(Ne),re(Ee)}function at(l){l.memoizedState!==null&&pe(_e,l);var h=ve.current,f=L$(h,l.type);h!==f&&(pe(Ne,l),pe(ve,f))}function ot(l){Ne.current===l&&(re(ve),re(Ne)),_e.current===l&&(re(_e),zp._currentValue=ie)}var Tt,ut;function mt(l){if(Tt===void 0)try{throw Error()}catch(f){var h=f.stack.trim().match(/\n( *(at )?)/);Tt=h&&h[1]||"",ut=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Tt+l+ut}var Bt=!1;function Ft(l,h){if(!l||Bt)return"";Bt=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var y={DetermineComponentFrameRoot:function(){try{if(h){var Te=function(){throw Error()};if(Object.defineProperty(Te.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Te,[])}catch(Se){var be=Se}Reflect.construct(l,[],Te)}else{try{Te.call()}catch(Se){be=Se}l.call(Te.prototype)}}else{try{throw Error()}catch(Se){be=Se}(Te=l())&&typeof Te.catch=="function"&&Te.catch(function(){})}}catch(Se){if(Se&&be&&typeof Se.stack=="string")return[Se.stack,be.stack]}return[null,null]}};y.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var S=Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot,"name");S&&S.configurable&&Object.defineProperty(y.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var k=y.DetermineComponentFrameRoot(),_=k[0],V=k[1];if(_&&V){var ne=_.split(`
`),xe=V.split(`
`);for(S=y=0;y<ne.length&&!ne[y].includes("DetermineComponentFrameRoot");)y++;for(;S<xe.length&&!xe[S].includes("DetermineComponentFrameRoot");)S++;if(y===ne.length||S===xe.length)for(y=ne.length-1,S=xe.length-1;1<=y&&0<=S&&ne[y]!==xe[S];)S--;for(;1<=y&&0<=S;y--,S--)if(ne[y]!==xe[S]){if(y!==1||S!==1)do if(y--,S--,0>S||ne[y]!==xe[S]){var ke=`
`+ne[y].replace(" at new "," at ");return l.displayName&&ke.includes("<anonymous>")&&(ke=ke.replace("<anonymous>",l.displayName)),ke}while(1<=y&&0<=S);break}}}finally{Bt=!1,Error.prepareStackTrace=f}return(f=l?l.displayName||l.name:"")?mt(f):""}function Zt(l,h){switch(l.tag){case 26:case 27:case 5:return mt(l.type);case 16:return mt("Lazy");case 13:return l.child!==h&&h!==null?mt("Suspense Fallback"):mt("Suspense");case 19:return mt("SuspenseList");case 0:case 15:return Ft(l.type,!1);case 11:return Ft(l.type.render,!1);case 1:return Ft(l.type,!0);case 31:return mt("Activity");default:return""}}function qt(l){try{var h="",f=null;do h+=Zt(l,f),f=l,l=l.return;while(l);return h}catch(y){return`
Error generating stack: `+y.message+`
`+y.stack}}var Ps=Object.prototype.hasOwnProperty,yn=n.unstable_scheduleCallback,Js=n.unstable_cancelCallback,os=n.unstable_shouldYield,ei=n.unstable_requestPaint,Ut=n.unstable_now,fr=n.unstable_getCurrentPriorityLevel,Bs=n.unstable_ImmediatePriority,er=n.unstable_UserBlockingPriority,tr=n.unstable_NormalPriority,na=n.unstable_LowPriority,yo=n.unstable_IdlePriority,xo=n.log,tc=n.unstable_setDisableYieldValue,Vs=null,ls=null;function Or(l){if(typeof xo=="function"&&tc(l),ls&&typeof ls.setStrictMode=="function")try{ls.setStrictMode(Vs,l)}catch{}}var nr=Math.clz32?Math.clz32:Ra,Jm=Math.log,Vd=Math.LN2;function Ra(l){return l>>>=0,l===0?32:31-(Jm(l)/Vd|0)|0}var sa=256,Al=262144,Dl=4194304;function Ri(l){var h=l&42;if(h!==0)return h;switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return l&261888;case 262144:case 524288:case 1048576:case 2097152:return l&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return l&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return l}}function _l(l,h,f){var y=l.pendingLanes;if(y===0)return 0;var S=0,k=l.suspendedLanes,_=l.pingedLanes;l=l.warmLanes;var V=y&134217727;return V!==0?(y=V&~k,y!==0?S=Ri(y):(_&=V,_!==0?S=Ri(_):f||(f=V&~l,f!==0&&(S=Ri(f))))):(V=y&~k,V!==0?S=Ri(V):_!==0?S=Ri(_):f||(f=y&~l,f!==0&&(S=Ri(f)))),S===0?0:h!==0&&h!==S&&(h&k)===0&&(k=S&-S,f=h&-h,k>=f||k===32&&(f&4194048)!==0)?h:S}function Fr(l,h){return(l.pendingLanes&~(l.suspendedLanes&~l.pingedLanes)&h)===0}function Ud(l,h){switch(l){case 1:case 2:case 4:case 8:case 64:return h+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Wd(){var l=Dl;return Dl<<=1,(Dl&62914560)===0&&(Dl=4194304),l}function bo(l){for(var h=[],f=0;31>f;f++)h.push(l);return h}function ra(l,h){l.pendingLanes|=h,h!==268435456&&(l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0)}function Xb(l,h,f,y,S,k){var _=l.pendingLanes;l.pendingLanes=f,l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0,l.expiredLanes&=f,l.entangledLanes&=f,l.errorRecoveryDisabledLanes&=f,l.shellSuspendCounter=0;var V=l.entanglements,ne=l.expirationTimes,xe=l.hiddenUpdates;for(f=_&~f;0<f;){var ke=31-nr(f),Te=1<<ke;V[ke]=0,ne[ke]=-1;var be=xe[ke];if(be!==null)for(xe[ke]=null,ke=0;ke<be.length;ke++){var Se=be[ke];Se!==null&&(Se.lane&=-536870913)}f&=~Te}y!==0&&Aa(l,y,0),k!==0&&S===0&&l.tag!==0&&(l.suspendedLanes|=k&~(_&~h))}function Aa(l,h,f){l.pendingLanes|=h,l.suspendedLanes&=~h;var y=31-nr(h);l.entangledLanes|=h,l.entanglements[y]=l.entanglements[y]|1073741824|f&261930}function eg(l,h){var f=l.entangledLanes|=h;for(l=l.entanglements;f;){var y=31-nr(f),S=1<<y;S&h|l[y]&h&&(l[y]|=h),f&=~S}}function ti(l,h){var f=h&-h;return f=(f&42)!==0?1:Ai(f),(f&(l.suspendedLanes|h))!==0?0:f}function Ai(l){switch(l){case 2:l=1;break;case 8:l=4;break;case 32:l=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:l=128;break;case 268435456:l=134217728;break;default:l=0}return l}function nc(l){return l&=-l,2<l?8<l?(l&134217727)!==0?32:268435456:8:2}function Sn(){var l=ee.p;return l!==0?l:(l=window.event,l===void 0?32:aI(l.type))}function zr(l,h){var f=ee.p;try{return ee.p=l,h()}finally{ee.p=f}}var ni=Math.random().toString(36).slice(2),us="__reactFiber$"+ni,cs="__reactProps$"+ni,ia="__reactContainer$"+ni,vo="__reactEvents$"+ni,Ol="__reactListeners$"+ni,tg="__reactHandles$"+ni,sc="__reactResources$"+ni,Da="__reactMarker$"+ni;function rc(l){delete l[us],delete l[cs],delete l[vo],delete l[Ol],delete l[tg]}function bs(l){var h=l[us];if(h)return h;for(var f=l.parentNode;f;){if(h=f[ia]||f[us]){if(f=h.alternate,h.child!==null||f!==null&&f.child!==null)for(l=G$(l);l!==null;){if(f=l[us])return f;l=G$(l)}return h}l=f,f=l.parentNode}return null}function Ts(l){if(l=l[us]||l[ia]){var h=l.tag;if(h===5||h===6||h===13||h===31||h===26||h===27||h===3)return l}return null}function Di(l){var h=l.tag;if(h===5||h===26||h===27||h===6)return l.stateNode;throw Error(s(33))}function aa(l){var h=l[sc];return h||(h=l[sc]={hoistableStyles:new Map,hoistableScripts:new Map}),h}function _n(l){l[Da]=!0}var Gd=new Set,ic={};function vs(l,h){_a(l,h),_a(l+"Capture",h)}function _a(l,h){for(ic[l]=h,l=0;l<h.length;l++)Gd.add(h[l])}var ac=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Lr={},Fl={};function Kb(l){return Ps.call(Fl,l)?!0:Ps.call(Lr,l)?!1:ac.test(l)?Fl[l]=!0:(Lr[l]=!0,!1)}function zl(l,h,f){if(Kb(h))if(f===null)l.removeAttribute(h);else{switch(typeof f){case"undefined":case"function":case"symbol":l.removeAttribute(h);return;case"boolean":var y=h.toLowerCase().slice(0,5);if(y!=="data-"&&y!=="aria-"){l.removeAttribute(h);return}}l.setAttribute(h,""+f)}}function wo(l,h,f){if(f===null)l.removeAttribute(h);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(h);return}l.setAttribute(h,""+f)}}function _i(l,h,f,y){if(y===null)l.removeAttribute(f);else{switch(typeof y){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(f);return}l.setAttributeNS(h,f,""+y)}}function mr(l){switch(typeof l){case"bigint":case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function Hd(l){var h=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function ng(l,h,f){var y=Object.getOwnPropertyDescriptor(l.constructor.prototype,h);if(!l.hasOwnProperty(h)&&typeof y<"u"&&typeof y.get=="function"&&typeof y.set=="function"){var S=y.get,k=y.set;return Object.defineProperty(l,h,{configurable:!0,get:function(){return S.call(this)},set:function(_){f=""+_,k.call(this,_)}}),Object.defineProperty(l,h,{enumerable:y.enumerable}),{getValue:function(){return f},setValue:function(_){f=""+_},stopTracking:function(){l._valueTracker=null,delete l[h]}}}}function oc(l){if(!l._valueTracker){var h=Hd(l)?"checked":"value";l._valueTracker=ng(l,h,""+l[h])}}function jd(l){if(!l)return!1;var h=l._valueTracker;if(!h)return!0;var f=h.getValue(),y="";return l&&(y=Hd(l)?l.checked?"true":"false":l.value),l=y,l!==f?(h.setValue(l),!0):!1}function hs(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}var sg=/[\n"\\]/g;function sr(l){return l.replace(sg,function(h){return"\\"+h.charCodeAt(0).toString(16)+" "})}function So(l,h,f,y,S,k,_,V){l.name="",_!=null&&typeof _!="function"&&typeof _!="symbol"&&typeof _!="boolean"?l.type=_:l.removeAttribute("type"),h!=null?_==="number"?(h===0&&l.value===""||l.value!=h)&&(l.value=""+mr(h)):l.value!==""+mr(h)&&(l.value=""+mr(h)):_!=="submit"&&_!=="reset"||l.removeAttribute("value"),h!=null?lc(l,_,mr(h)):f!=null?lc(l,_,mr(f)):y!=null&&l.removeAttribute("value"),S==null&&k!=null&&(l.defaultChecked=!!k),S!=null&&(l.checked=S&&typeof S!="function"&&typeof S!="symbol"),V!=null&&typeof V!="function"&&typeof V!="symbol"&&typeof V!="boolean"?l.name=""+mr(V):l.removeAttribute("name")}function qd(l,h,f,y,S,k,_,V){if(k!=null&&typeof k!="function"&&typeof k!="symbol"&&typeof k!="boolean"&&(l.type=k),h!=null||f!=null){if(!(k!=="submit"&&k!=="reset"||h!=null)){oc(l);return}f=f!=null?""+mr(f):"",h=h!=null?""+mr(h):f,V||h===l.value||(l.value=h),l.defaultValue=h}y=y??S,y=typeof y!="function"&&typeof y!="symbol"&&!!y,l.checked=V?l.checked:!!y,l.defaultChecked=!!y,_!=null&&typeof _!="function"&&typeof _!="symbol"&&typeof _!="boolean"&&(l.name=_),oc(l)}function lc(l,h,f){h==="number"&&hs(l.ownerDocument)===l||l.defaultValue===""+f||(l.defaultValue=""+f)}function Co(l,h,f,y){if(l=l.options,h){h={};for(var S=0;S<f.length;S++)h["$"+f[S]]=!0;for(f=0;f<l.length;f++)S=h.hasOwnProperty("$"+l[f].value),l[f].selected!==S&&(l[f].selected=S),S&&y&&(l[f].defaultSelected=!0)}else{for(f=""+mr(f),h=null,S=0;S<l.length;S++){if(l[S].value===f){l[S].selected=!0,y&&(l[S].defaultSelected=!0);return}h!==null||l[S].disabled||(h=l[S])}h!==null&&(h.selected=!0)}}function rg(l,h,f){if(h!=null&&(h=""+mr(h),h!==l.value&&(l.value=h),f==null)){l.defaultValue!==h&&(l.defaultValue=h);return}l.defaultValue=f!=null?""+mr(f):""}function Xd(l,h,f,y){if(h==null){if(y!=null){if(f!=null)throw Error(s(92));if(Z(y)){if(1<y.length)throw Error(s(93));y=y[0]}f=y}f==null&&(f=""),h=f}f=mr(h),l.defaultValue=f,y=l.textContent,y===f&&y!==""&&y!==null&&(l.value=y),oc(l)}function Oa(l,h){if(h){var f=l.firstChild;if(f&&f===l.lastChild&&f.nodeType===3){f.nodeValue=h;return}}l.textContent=h}var uc=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Kd(l,h,f){var y=h.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?y?l.setProperty(h,""):h==="float"?l.cssFloat="":l[h]="":y?l.setProperty(h,f):typeof f!="number"||f===0||uc.has(h)?h==="float"?l.cssFloat=f:l[h]=(""+f).trim():l[h]=f+"px"}function Yd(l,h,f){if(h!=null&&typeof h!="object")throw Error(s(62));if(l=l.style,f!=null){for(var y in f)!f.hasOwnProperty(y)||h!=null&&h.hasOwnProperty(y)||(y.indexOf("--")===0?l.setProperty(y,""):y==="float"?l.cssFloat="":l[y]="");for(var S in h)y=h[S],h.hasOwnProperty(S)&&f[S]!==y&&Kd(l,S,y)}else for(var k in h)h.hasOwnProperty(k)&&Kd(l,k,h[k])}function Fa(l){if(l.indexOf("-")===-1)return!1;switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Yb=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Qb=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function cc(l){return Qb.test(""+l)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":l}function Oi(){}var Ll=null;function za(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var No=null,ko=null;function ig(l){var h=Ts(l);if(h&&(l=h.stateNode)){var f=l[cs]||null;e:switch(l=h.stateNode,h.type){case"input":if(So(l,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),h=f.name,f.type==="radio"&&h!=null){for(f=l;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+sr(""+h)+'"][type="radio"]'),h=0;h<f.length;h++){var y=f[h];if(y!==l&&y.form===l.form){var S=y[cs]||null;if(!S)throw Error(s(90));So(y,S.value,S.defaultValue,S.defaultValue,S.checked,S.defaultChecked,S.type,S.name)}}for(h=0;h<f.length;h++)y=f[h],y.form===l.form&&jd(y)}break e;case"textarea":rg(l,f.value,f.defaultValue);break e;case"select":h=f.value,h!=null&&Co(l,!!f.multiple,h,!1)}}}var Qd=!1;function hc(l,h,f){if(Qd)return l(h,f);Qd=!0;try{var y=l(h);return y}finally{if(Qd=!1,(No!==null||ko!==null)&&(Qg(),No&&(h=No,l=ko,ko=No=null,ig(h),l)))for(h=0;h<l.length;h++)ig(l[h])}}function $o(l,h){var f=l.stateNode;if(f===null)return null;var y=f[cs]||null;if(y===null)return null;f=y[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(y=!y.disabled)||(l=l.type,y=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!y;break e;default:l=!1}if(l)return null;if(f&&typeof f!="function")throw Error(s(231,h,typeof f));return f}var si=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),La=!1;if(si)try{var Es={};Object.defineProperty(Es,"passive",{get:function(){La=!0}}),window.addEventListener("test",Es,Es),window.removeEventListener("test",Es,Es)}catch{La=!1}var oa=null,Zd=null,Ml=null;function Jd(){if(Ml)return Ml;var l,h=Zd,f=h.length,y,S="value"in oa?oa.value:oa.textContent,k=S.length;for(l=0;l<f&&h[l]===S[l];l++);var _=f-l;for(y=1;y<=_&&h[f-y]===S[k-y];y++);return Ml=S.slice(l,1<y?1-y:void 0)}function Io(l){var h=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&h===13&&(l=13)):l=h,l===10&&(l=13),32<=l||l===13?l:0}function To(){return!0}function Ma(){return!1}function Rs(l){function h(f,y,S,k,_){this._reactName=f,this._targetInst=S,this.type=y,this.nativeEvent=k,this.target=_,this.currentTarget=null;for(var V in l)l.hasOwnProperty(V)&&(f=l[V],this[V]=f?f(k):k[V]);return this.isDefaultPrevented=(k.defaultPrevented!=null?k.defaultPrevented:k.returnValue===!1)?To:Ma,this.isPropagationStopped=Ma,this}return p(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=To)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=To)},persist:function(){},isPersistent:To}),h}var Fi={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dc=Rs(Fi),Pl=p({},Fi,{view:0,detail:0}),Bl=Rs(Pl),pc,fc,Vl,mc=p({},Pl,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:sp,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==Vl&&(Vl&&l.type==="mousemove"?(pc=l.screenX-Vl.screenX,fc=l.screenY-Vl.screenY):fc=pc=0,Vl=l),pc)},movementY:function(l){return"movementY"in l?l.movementY:fc}}),Ul=Rs(mc),ag=p({},mc,{dataTransfer:0}),Zb=Rs(ag),og=p({},Pl,{relatedTarget:0}),ep=Rs(og),Jb=p({},Fi,{animationName:0,elapsedTime:0,pseudoElement:0}),tp=Rs(Jb),np=p({},Fi,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),lg=Rs(np),e1=p({},Fi,{data:0}),ug=Rs(e1),t1={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},n1={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},cg={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function s1(l){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(l):(l=cg[l])?!!h[l]:!1}function sp(){return s1}var rp=p({},Pl,{key:function(l){if(l.key){var h=t1[l.key]||l.key;if(h!=="Unidentified")return h}return l.type==="keypress"?(l=Io(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?n1[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:sp,charCode:function(l){return l.type==="keypress"?Io(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?Io(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),r1=Rs(rp),i1=p({},mc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),hg=Rs(i1),gc=p({},Pl,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:sp}),a1=Rs(gc),o1=p({},Fi,{propertyName:0,elapsedTime:0,pseudoElement:0}),l1=Rs(o1),dg=p({},mc,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),pg=Rs(dg),C=p({},Fi,{newState:0,oldState:0}),T=Rs(C),A=[9,13,27,32],P=si&&"CompositionEvent"in window,j=null;si&&"documentMode"in document&&(j=document.documentMode);var Y=si&&"TextEvent"in window&&!j,K=si&&(!P||j&&8<j&&11>=j),ue=" ",we=!1;function De(l,h){switch(l){case"keyup":return A.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Me(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var nt=!1;function tt(l,h){switch(l){case"compositionend":return Me(h);case"keypress":return h.which!==32?null:(we=!0,ue);case"textInput":return l=h.data,l===ue&&we?null:l;default:return null}}function Ge(l,h){if(nt)return l==="compositionend"||!P&&De(l,h)?(l=Jd(),Ml=Zd=oa=null,nt=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return K&&h.locale!=="ko"?null:h.data;default:return null}}var ct={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function bt(l){var h=l&&l.nodeName&&l.nodeName.toLowerCase();return h==="input"?!!ct[l.type]:h==="textarea"}function rn(l,h,f,y){No?ko?ko.push(y):ko=[y]:No=y,h=ry(h,"onChange"),0<h.length&&(f=new dc("onChange","change",null,f,y),l.push({event:f,listeners:h}))}var Gt=null,In=null;function gr(l){R$(l,0)}function ds(l){var h=Di(l);if(jd(h))return l}function zt(l,h){if(l==="change")return h}var jn=!1;if(si){var ri;if(si){var ip="oninput"in document;if(!ip){var fg=document.createElement("div");fg.setAttribute("oninput","return;"),ip=typeof fg.oninput=="function"}ri=ip}else ri=!1;jn=ri&&(!document.documentMode||9<document.documentMode)}function mg(){Gt&&(Gt.detachEvent("onpropertychange",gg),In=Gt=null)}function gg(l){if(l.propertyName==="value"&&ds(In)){var h=[];rn(h,In,l,za(l)),hc(gr,h)}}function u1(l,h,f){l==="focusin"?(mg(),Gt=h,In=f,Gt.attachEvent("onpropertychange",gg)):l==="focusout"&&mg()}function yc(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return ds(In)}function TL(l,h){if(l==="click")return ds(h)}function EL(l,h){if(l==="input"||l==="change")return ds(h)}function RL(l,h){return l===h&&(l!==0||1/l===1/h)||l!==l&&h!==h}var Mr=typeof Object.is=="function"?Object.is:RL;function ap(l,h){if(Mr(l,h))return!0;if(typeof l!="object"||l===null||typeof h!="object"||h===null)return!1;var f=Object.keys(l),y=Object.keys(h);if(f.length!==y.length)return!1;for(y=0;y<f.length;y++){var S=f[y];if(!Ps.call(h,S)||!Mr(l[S],h[S]))return!1}return!0}function eN(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function tN(l,h){var f=eN(l);l=0;for(var y;f;){if(f.nodeType===3){if(y=l+f.textContent.length,l<=h&&y>=h)return{node:f,offset:h-l};l=y}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=eN(f)}}function nN(l,h){return l&&h?l===h?!0:l&&l.nodeType===3?!1:h&&h.nodeType===3?nN(l,h.parentNode):"contains"in l?l.contains(h):l.compareDocumentPosition?!!(l.compareDocumentPosition(h)&16):!1:!1}function sN(l){l=l!=null&&l.ownerDocument!=null&&l.ownerDocument.defaultView!=null?l.ownerDocument.defaultView:window;for(var h=hs(l.document);h instanceof l.HTMLIFrameElement;){try{var f=typeof h.contentWindow.location.href=="string"}catch{f=!1}if(f)l=h.contentWindow;else break;h=hs(l.document)}return h}function c1(l){var h=l&&l.nodeName&&l.nodeName.toLowerCase();return h&&(h==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||h==="textarea"||l.contentEditable==="true")}var AL=si&&"documentMode"in document&&11>=document.documentMode,xc=null,h1=null,op=null,d1=!1;function rN(l,h,f){var y=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;d1||xc==null||xc!==hs(y)||(y=xc,"selectionStart"in y&&c1(y)?y={start:y.selectionStart,end:y.selectionEnd}:(y=(y.ownerDocument&&y.ownerDocument.defaultView||window).getSelection(),y={anchorNode:y.anchorNode,anchorOffset:y.anchorOffset,focusNode:y.focusNode,focusOffset:y.focusOffset}),op&&ap(op,y)||(op=y,y=ry(h1,"onSelect"),0<y.length&&(h=new dc("onSelect","select",null,h,f),l.push({event:h,listeners:y}),h.target=xc)))}function Wl(l,h){var f={};return f[l.toLowerCase()]=h.toLowerCase(),f["Webkit"+l]="webkit"+h,f["Moz"+l]="moz"+h,f}var bc={animationend:Wl("Animation","AnimationEnd"),animationiteration:Wl("Animation","AnimationIteration"),animationstart:Wl("Animation","AnimationStart"),transitionrun:Wl("Transition","TransitionRun"),transitionstart:Wl("Transition","TransitionStart"),transitioncancel:Wl("Transition","TransitionCancel"),transitionend:Wl("Transition","TransitionEnd")},p1={},iN={};si&&(iN=document.createElement("div").style,"AnimationEvent"in window||(delete bc.animationend.animation,delete bc.animationiteration.animation,delete bc.animationstart.animation),"TransitionEvent"in window||delete bc.transitionend.transition);function Gl(l){if(p1[l])return p1[l];if(!bc[l])return l;var h=bc[l],f;for(f in h)if(h.hasOwnProperty(f)&&f in iN)return p1[l]=h[f];return l}var aN=Gl("animationend"),oN=Gl("animationiteration"),lN=Gl("animationstart"),DL=Gl("transitionrun"),_L=Gl("transitionstart"),OL=Gl("transitioncancel"),uN=Gl("transitionend"),cN=new Map,f1="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");f1.push("scrollEnd");function zi(l,h){cN.set(l,h),vs(h,[l])}var yg=typeof reportError=="function"?reportError:function(l){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var h=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof l=="object"&&l!==null&&typeof l.message=="string"?String(l.message):String(l),error:l});if(!window.dispatchEvent(h))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",l);return}console.error(l)},ii=[],vc=0,m1=0;function xg(){for(var l=vc,h=m1=vc=0;h<l;){var f=ii[h];ii[h++]=null;var y=ii[h];ii[h++]=null;var S=ii[h];ii[h++]=null;var k=ii[h];if(ii[h++]=null,y!==null&&S!==null){var _=y.pending;_===null?S.next=S:(S.next=_.next,_.next=S),y.pending=S}k!==0&&hN(f,S,k)}}function bg(l,h,f,y){ii[vc++]=l,ii[vc++]=h,ii[vc++]=f,ii[vc++]=y,m1|=y,l.lanes|=y,l=l.alternate,l!==null&&(l.lanes|=y)}function g1(l,h,f,y){return bg(l,h,f,y),vg(l)}function Hl(l,h){return bg(l,null,null,h),vg(l)}function hN(l,h,f){l.lanes|=f;var y=l.alternate;y!==null&&(y.lanes|=f);for(var S=!1,k=l.return;k!==null;)k.childLanes|=f,y=k.alternate,y!==null&&(y.childLanes|=f),k.tag===22&&(l=k.stateNode,l===null||l._visibility&1||(S=!0)),l=k,k=k.return;return l.tag===3?(k=l.stateNode,S&&h!==null&&(S=31-nr(f),l=k.hiddenUpdates,y=l[S],y===null?l[S]=[h]:y.push(h),h.lane=f|536870912),k):null}function vg(l){if(50<Ep)throw Ep=0,kv=null,Error(s(185));for(var h=l.return;h!==null;)l=h,h=l.return;return l.tag===3?l.stateNode:null}var wc={};function FL(l,h,f,y){this.tag=l,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=y,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Pr(l,h,f,y){return new FL(l,h,f,y)}function y1(l){return l=l.prototype,!(!l||!l.isReactComponent)}function Pa(l,h){var f=l.alternate;return f===null?(f=Pr(l.tag,h,l.key,l.mode),f.elementType=l.elementType,f.type=l.type,f.stateNode=l.stateNode,f.alternate=l,l.alternate=f):(f.pendingProps=h,f.type=l.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=l.flags&65011712,f.childLanes=l.childLanes,f.lanes=l.lanes,f.child=l.child,f.memoizedProps=l.memoizedProps,f.memoizedState=l.memoizedState,f.updateQueue=l.updateQueue,h=l.dependencies,f.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},f.sibling=l.sibling,f.index=l.index,f.ref=l.ref,f.refCleanup=l.refCleanup,f}function dN(l,h){l.flags&=65011714;var f=l.alternate;return f===null?(l.childLanes=0,l.lanes=h,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=f.childLanes,l.lanes=f.lanes,l.child=f.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=f.memoizedProps,l.memoizedState=f.memoizedState,l.updateQueue=f.updateQueue,l.type=f.type,h=f.dependencies,l.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),l}function wg(l,h,f,y,S,k){var _=0;if(y=l,typeof l=="function")y1(l)&&(_=1);else if(typeof l=="string")_=BM(l,f,ve.current)?26:l==="html"||l==="head"||l==="body"?27:5;else e:switch(l){case z:return l=Pr(31,f,h,S),l.elementType=z,l.lanes=k,l;case b:return jl(f.children,S,k,h);case v:_=8,S|=24;break;case w:return l=Pr(12,f,h,S|2),l.elementType=w,l.lanes=k,l;case E:return l=Pr(13,f,h,S),l.elementType=E,l.lanes=k,l;case D:return l=Pr(19,f,h,S),l.elementType=D,l.lanes=k,l;default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case I:_=10;break e;case N:_=9;break e;case $:_=11;break e;case F:_=14;break e;case L:_=16,y=null;break e}_=29,f=Error(s(130,l===null?"null":typeof l,"")),y=null}return h=Pr(_,f,h,S),h.elementType=l,h.type=y,h.lanes=k,h}function jl(l,h,f,y){return l=Pr(7,l,y,h),l.lanes=f,l}function x1(l,h,f){return l=Pr(6,l,null,h),l.lanes=f,l}function pN(l){var h=Pr(18,null,null,0);return h.stateNode=l,h}function b1(l,h,f){return h=Pr(4,l.children!==null?l.children:[],l.key,h),h.lanes=f,h.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},h}var fN=new WeakMap;function ai(l,h){if(typeof l=="object"&&l!==null){var f=fN.get(l);return f!==void 0?f:(h={value:l,source:h,stack:qt(h)},fN.set(l,h),h)}return{value:l,source:h,stack:qt(h)}}var Sc=[],Cc=0,Sg=null,lp=0,oi=[],li=0,Eo=null,la=1,ua="";function Ba(l,h){Sc[Cc++]=lp,Sc[Cc++]=Sg,Sg=l,lp=h}function mN(l,h,f){oi[li++]=la,oi[li++]=ua,oi[li++]=Eo,Eo=l;var y=la;l=ua;var S=32-nr(y)-1;y&=~(1<<S),f+=1;var k=32-nr(h)+S;if(30<k){var _=S-S%5;k=(y&(1<<_)-1).toString(32),y>>=_,S-=_,la=1<<32-nr(h)+S|f<<S|y,ua=k+l}else la=1<<k|f<<S|y,ua=l}function v1(l){l.return!==null&&(Ba(l,1),mN(l,1,0))}function w1(l){for(;l===Sg;)Sg=Sc[--Cc],Sc[Cc]=null,lp=Sc[--Cc],Sc[Cc]=null;for(;l===Eo;)Eo=oi[--li],oi[li]=null,ua=oi[--li],oi[li]=null,la=oi[--li],oi[li]=null}function gN(l,h){oi[li++]=la,oi[li++]=ua,oi[li++]=Eo,la=h.id,ua=h.overflow,Eo=l}var As=null,xn=null,Lt=!1,Ro=null,ui=!1,S1=Error(s(519));function Ao(l){var h=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw up(ai(h,l)),S1}function yN(l){var h=l.stateNode,f=l.type,y=l.memoizedProps;switch(h[us]=l,h[cs]=y,f){case"dialog":It("cancel",h),It("close",h);break;case"iframe":case"object":case"embed":It("load",h);break;case"video":case"audio":for(f=0;f<Ap.length;f++)It(Ap[f],h);break;case"source":It("error",h);break;case"img":case"image":case"link":It("error",h),It("load",h);break;case"details":It("toggle",h);break;case"input":It("invalid",h),qd(h,y.value,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name,!0);break;case"select":It("invalid",h);break;case"textarea":It("invalid",h),Xd(h,y.value,y.defaultValue,y.children)}f=y.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||h.textContent===""+f||y.suppressHydrationWarning===!0||O$(h.textContent,f)?(y.popover!=null&&(It("beforetoggle",h),It("toggle",h)),y.onScroll!=null&&It("scroll",h),y.onScrollEnd!=null&&It("scrollend",h),y.onClick!=null&&(h.onclick=Oi),h=!0):h=!1,h||Ao(l,!0)}function xN(l){for(As=l.return;As;)switch(As.tag){case 5:case 31:case 13:ui=!1;return;case 27:case 3:ui=!0;return;default:As=As.return}}function Nc(l){if(l!==As)return!1;if(!Lt)return xN(l),Lt=!0,!1;var h=l.tag,f;if((f=h!==3&&h!==27)&&((f=h===5)&&(f=l.type,f=!(f!=="form"&&f!=="button")||Bv(l.type,l.memoizedProps)),f=!f),f&&xn&&Ao(l),xN(l),h===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(317));xn=W$(l)}else if(h===31){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(317));xn=W$(l)}else h===27?(h=xn,Ho(l.type)?(l=Hv,Hv=null,xn=l):xn=h):xn=As?hi(l.stateNode.nextSibling):null;return!0}function ql(){xn=As=null,Lt=!1}function C1(){var l=Ro;return l!==null&&(vr===null?vr=l:vr.push.apply(vr,l),Ro=null),l}function up(l){Ro===null?Ro=[l]:Ro.push(l)}var N1=G(null),Xl=null,Va=null;function Do(l,h,f){pe(N1,h._currentValue),h._currentValue=f}function Ua(l){l._currentValue=N1.current,re(N1)}function k1(l,h,f){for(;l!==null;){var y=l.alternate;if((l.childLanes&h)!==h?(l.childLanes|=h,y!==null&&(y.childLanes|=h)):y!==null&&(y.childLanes&h)!==h&&(y.childLanes|=h),l===f)break;l=l.return}}function $1(l,h,f,y){var S=l.child;for(S!==null&&(S.return=l);S!==null;){var k=S.dependencies;if(k!==null){var _=S.child;k=k.firstContext;e:for(;k!==null;){var V=k;k=S;for(var ne=0;ne<h.length;ne++)if(V.context===h[ne]){k.lanes|=f,V=k.alternate,V!==null&&(V.lanes|=f),k1(k.return,f,l),y||(_=null);break e}k=V.next}}else if(S.tag===18){if(_=S.return,_===null)throw Error(s(341));_.lanes|=f,k=_.alternate,k!==null&&(k.lanes|=f),k1(_,f,l),_=null}else _=S.child;if(_!==null)_.return=S;else for(_=S;_!==null;){if(_===l){_=null;break}if(S=_.sibling,S!==null){S.return=_.return,_=S;break}_=_.return}S=_}}function kc(l,h,f,y){l=null;for(var S=h,k=!1;S!==null;){if(!k){if((S.flags&524288)!==0)k=!0;else if((S.flags&262144)!==0)break}if(S.tag===10){var _=S.alternate;if(_===null)throw Error(s(387));if(_=_.memoizedProps,_!==null){var V=S.type;Mr(S.pendingProps.value,_.value)||(l!==null?l.push(V):l=[V])}}else if(S===_e.current){if(_=S.alternate,_===null)throw Error(s(387));_.memoizedState.memoizedState!==S.memoizedState.memoizedState&&(l!==null?l.push(zp):l=[zp])}S=S.return}l!==null&&$1(h,l,f,y),h.flags|=262144}function Cg(l){for(l=l.firstContext;l!==null;){if(!Mr(l.context._currentValue,l.memoizedValue))return!0;l=l.next}return!1}function Kl(l){Xl=l,Va=null,l=l.dependencies,l!==null&&(l.firstContext=null)}function Ds(l){return bN(Xl,l)}function Ng(l,h){return Xl===null&&Kl(l),bN(l,h)}function bN(l,h){var f=h._currentValue;if(h={context:h,memoizedValue:f,next:null},Va===null){if(l===null)throw Error(s(308));Va=h,l.dependencies={lanes:0,firstContext:h},l.flags|=524288}else Va=Va.next=h;return f}var zL=typeof AbortController<"u"?AbortController:function(){var l=[],h=this.signal={aborted:!1,addEventListener:function(f,y){l.push(y)}};this.abort=function(){h.aborted=!0,l.forEach(function(f){return f()})}},LL=n.unstable_scheduleCallback,ML=n.unstable_NormalPriority,qn={$$typeof:I,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function I1(){return{controller:new zL,data:new Map,refCount:0}}function cp(l){l.refCount--,l.refCount===0&&LL(ML,function(){l.controller.abort()})}var hp=null,T1=0,$c=0,Ic=null;function PL(l,h){if(hp===null){var f=hp=[];T1=0,$c=Av(),Ic={status:"pending",value:void 0,then:function(y){f.push(y)}}}return T1++,h.then(vN,vN),h}function vN(){if(--T1===0&&hp!==null){Ic!==null&&(Ic.status="fulfilled");var l=hp;hp=null,$c=0,Ic=null;for(var h=0;h<l.length;h++)(0,l[h])()}}function BL(l,h){var f=[],y={status:"pending",value:null,reason:null,then:function(S){f.push(S)}};return l.then(function(){y.status="fulfilled",y.value=h;for(var S=0;S<f.length;S++)(0,f[S])(h)},function(S){for(y.status="rejected",y.reason=S,S=0;S<f.length;S++)(0,f[S])(void 0)}),y}var wN=W.S;W.S=function(l,h){r$=Ut(),typeof h=="object"&&h!==null&&typeof h.then=="function"&&PL(l,h),wN!==null&&wN(l,h)};var Yl=G(null);function E1(){var l=Yl.current;return l!==null?l:hn.pooledCache}function kg(l,h){h===null?pe(Yl,Yl.current):pe(Yl,h.pool)}function SN(){var l=E1();return l===null?null:{parent:qn._currentValue,pool:l}}var Tc=Error(s(460)),R1=Error(s(474)),$g=Error(s(542)),Ig={then:function(){}};function CN(l){return l=l.status,l==="fulfilled"||l==="rejected"}function NN(l,h,f){switch(f=l[f],f===void 0?l.push(h):f!==h&&(h.then(Oi,Oi),h=f),h.status){case"fulfilled":return h.value;case"rejected":throw l=h.reason,$N(l),l;default:if(typeof h.status=="string")h.then(Oi,Oi);else{if(l=hn,l!==null&&100<l.shellSuspendCounter)throw Error(s(482));l=h,l.status="pending",l.then(function(y){if(h.status==="pending"){var S=h;S.status="fulfilled",S.value=y}},function(y){if(h.status==="pending"){var S=h;S.status="rejected",S.reason=y}})}switch(h.status){case"fulfilled":return h.value;case"rejected":throw l=h.reason,$N(l),l}throw Zl=h,Tc}}function Ql(l){try{var h=l._init;return h(l._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(Zl=f,Tc):f}}var Zl=null;function kN(){if(Zl===null)throw Error(s(459));var l=Zl;return Zl=null,l}function $N(l){if(l===Tc||l===$g)throw Error(s(483))}var Ec=null,dp=0;function Tg(l){var h=dp;return dp+=1,Ec===null&&(Ec=[]),NN(Ec,l,h)}function pp(l,h){h=h.props.ref,l.ref=h!==void 0?h:null}function Eg(l,h){throw h.$$typeof===m?Error(s(525)):(l=Object.prototype.toString.call(h),Error(s(31,l==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":l)))}function IN(l){function h(me,le){if(l){var ye=me.deletions;ye===null?(me.deletions=[le],me.flags|=16):ye.push(le)}}function f(me,le){if(!l)return null;for(;le!==null;)h(me,le),le=le.sibling;return null}function y(me){for(var le=new Map;me!==null;)me.key!==null?le.set(me.key,me):le.set(me.index,me),me=me.sibling;return le}function S(me,le){return me=Pa(me,le),me.index=0,me.sibling=null,me}function k(me,le,ye){return me.index=ye,l?(ye=me.alternate,ye!==null?(ye=ye.index,ye<le?(me.flags|=67108866,le):ye):(me.flags|=67108866,le)):(me.flags|=1048576,le)}function _(me){return l&&me.alternate===null&&(me.flags|=67108866),me}function V(me,le,ye,Ie){return le===null||le.tag!==6?(le=x1(ye,me.mode,Ie),le.return=me,le):(le=S(le,ye),le.return=me,le)}function ne(me,le,ye,Ie){var st=ye.type;return st===b?ke(me,le,ye.props.children,Ie,ye.key):le!==null&&(le.elementType===st||typeof st=="object"&&st!==null&&st.$$typeof===L&&Ql(st)===le.type)?(le=S(le,ye.props),pp(le,ye),le.return=me,le):(le=wg(ye.type,ye.key,ye.props,null,me.mode,Ie),pp(le,ye),le.return=me,le)}function xe(me,le,ye,Ie){return le===null||le.tag!==4||le.stateNode.containerInfo!==ye.containerInfo||le.stateNode.implementation!==ye.implementation?(le=b1(ye,me.mode,Ie),le.return=me,le):(le=S(le,ye.children||[]),le.return=me,le)}function ke(me,le,ye,Ie,st){return le===null||le.tag!==7?(le=jl(ye,me.mode,Ie,st),le.return=me,le):(le=S(le,ye),le.return=me,le)}function Te(me,le,ye){if(typeof le=="string"&&le!==""||typeof le=="number"||typeof le=="bigint")return le=x1(""+le,me.mode,ye),le.return=me,le;if(typeof le=="object"&&le!==null){switch(le.$$typeof){case g:return ye=wg(le.type,le.key,le.props,null,me.mode,ye),pp(ye,le),ye.return=me,ye;case x:return le=b1(le,me.mode,ye),le.return=me,le;case L:return le=Ql(le),Te(me,le,ye)}if(Z(le)||H(le))return le=jl(le,me.mode,ye,null),le.return=me,le;if(typeof le.then=="function")return Te(me,Tg(le),ye);if(le.$$typeof===I)return Te(me,Ng(me,le),ye);Eg(me,le)}return null}function be(me,le,ye,Ie){var st=le!==null?le.key:null;if(typeof ye=="string"&&ye!==""||typeof ye=="number"||typeof ye=="bigint")return st!==null?null:V(me,le,""+ye,Ie);if(typeof ye=="object"&&ye!==null){switch(ye.$$typeof){case g:return ye.key===st?ne(me,le,ye,Ie):null;case x:return ye.key===st?xe(me,le,ye,Ie):null;case L:return ye=Ql(ye),be(me,le,ye,Ie)}if(Z(ye)||H(ye))return st!==null?null:ke(me,le,ye,Ie,null);if(typeof ye.then=="function")return be(me,le,Tg(ye),Ie);if(ye.$$typeof===I)return be(me,le,Ng(me,ye),Ie);Eg(me,ye)}return null}function Se(me,le,ye,Ie,st){if(typeof Ie=="string"&&Ie!==""||typeof Ie=="number"||typeof Ie=="bigint")return me=me.get(ye)||null,V(le,me,""+Ie,st);if(typeof Ie=="object"&&Ie!==null){switch(Ie.$$typeof){case g:return me=me.get(Ie.key===null?ye:Ie.key)||null,ne(le,me,Ie,st);case x:return me=me.get(Ie.key===null?ye:Ie.key)||null,xe(le,me,Ie,st);case L:return Ie=Ql(Ie),Se(me,le,ye,Ie,st)}if(Z(Ie)||H(Ie))return me=me.get(ye)||null,ke(le,me,Ie,st,null);if(typeof Ie.then=="function")return Se(me,le,ye,Tg(Ie),st);if(Ie.$$typeof===I)return Se(me,le,ye,Ng(le,Ie),st);Eg(le,Ie)}return null}function qe(me,le,ye,Ie){for(var st=null,Ht=null,et=le,Ct=le=0,Rt=null;et!==null&&Ct<ye.length;Ct++){et.index>Ct?(Rt=et,et=null):Rt=et.sibling;var jt=be(me,et,ye[Ct],Ie);if(jt===null){et===null&&(et=Rt);break}l&&et&&jt.alternate===null&&h(me,et),le=k(jt,le,Ct),Ht===null?st=jt:Ht.sibling=jt,Ht=jt,et=Rt}if(Ct===ye.length)return f(me,et),Lt&&Ba(me,Ct),st;if(et===null){for(;Ct<ye.length;Ct++)et=Te(me,ye[Ct],Ie),et!==null&&(le=k(et,le,Ct),Ht===null?st=et:Ht.sibling=et,Ht=et);return Lt&&Ba(me,Ct),st}for(et=y(et);Ct<ye.length;Ct++)Rt=Se(et,me,Ct,ye[Ct],Ie),Rt!==null&&(l&&Rt.alternate!==null&&et.delete(Rt.key===null?Ct:Rt.key),le=k(Rt,le,Ct),Ht===null?st=Rt:Ht.sibling=Rt,Ht=Rt);return l&&et.forEach(function(Yo){return h(me,Yo)}),Lt&&Ba(me,Ct),st}function lt(me,le,ye,Ie){if(ye==null)throw Error(s(151));for(var st=null,Ht=null,et=le,Ct=le=0,Rt=null,jt=ye.next();et!==null&&!jt.done;Ct++,jt=ye.next()){et.index>Ct?(Rt=et,et=null):Rt=et.sibling;var Yo=be(me,et,jt.value,Ie);if(Yo===null){et===null&&(et=Rt);break}l&&et&&Yo.alternate===null&&h(me,et),le=k(Yo,le,Ct),Ht===null?st=Yo:Ht.sibling=Yo,Ht=Yo,et=Rt}if(jt.done)return f(me,et),Lt&&Ba(me,Ct),st;if(et===null){for(;!jt.done;Ct++,jt=ye.next())jt=Te(me,jt.value,Ie),jt!==null&&(le=k(jt,le,Ct),Ht===null?st=jt:Ht.sibling=jt,Ht=jt);return Lt&&Ba(me,Ct),st}for(et=y(et);!jt.done;Ct++,jt=ye.next())jt=Se(et,me,Ct,jt.value,Ie),jt!==null&&(l&&jt.alternate!==null&&et.delete(jt.key===null?Ct:jt.key),le=k(jt,le,Ct),Ht===null?st=jt:Ht.sibling=jt,Ht=jt);return l&&et.forEach(function(QM){return h(me,QM)}),Lt&&Ba(me,Ct),st}function ln(me,le,ye,Ie){if(typeof ye=="object"&&ye!==null&&ye.type===b&&ye.key===null&&(ye=ye.props.children),typeof ye=="object"&&ye!==null){switch(ye.$$typeof){case g:e:{for(var st=ye.key;le!==null;){if(le.key===st){if(st=ye.type,st===b){if(le.tag===7){f(me,le.sibling),Ie=S(le,ye.props.children),Ie.return=me,me=Ie;break e}}else if(le.elementType===st||typeof st=="object"&&st!==null&&st.$$typeof===L&&Ql(st)===le.type){f(me,le.sibling),Ie=S(le,ye.props),pp(Ie,ye),Ie.return=me,me=Ie;break e}f(me,le);break}else h(me,le);le=le.sibling}ye.type===b?(Ie=jl(ye.props.children,me.mode,Ie,ye.key),Ie.return=me,me=Ie):(Ie=wg(ye.type,ye.key,ye.props,null,me.mode,Ie),pp(Ie,ye),Ie.return=me,me=Ie)}return _(me);case x:e:{for(st=ye.key;le!==null;){if(le.key===st)if(le.tag===4&&le.stateNode.containerInfo===ye.containerInfo&&le.stateNode.implementation===ye.implementation){f(me,le.sibling),Ie=S(le,ye.children||[]),Ie.return=me,me=Ie;break e}else{f(me,le);break}else h(me,le);le=le.sibling}Ie=b1(ye,me.mode,Ie),Ie.return=me,me=Ie}return _(me);case L:return ye=Ql(ye),ln(me,le,ye,Ie)}if(Z(ye))return qe(me,le,ye,Ie);if(H(ye)){if(st=H(ye),typeof st!="function")throw Error(s(150));return ye=st.call(ye),lt(me,le,ye,Ie)}if(typeof ye.then=="function")return ln(me,le,Tg(ye),Ie);if(ye.$$typeof===I)return ln(me,le,Ng(me,ye),Ie);Eg(me,ye)}return typeof ye=="string"&&ye!==""||typeof ye=="number"||typeof ye=="bigint"?(ye=""+ye,le!==null&&le.tag===6?(f(me,le.sibling),Ie=S(le,ye),Ie.return=me,me=Ie):(f(me,le),Ie=x1(ye,me.mode,Ie),Ie.return=me,me=Ie),_(me)):f(me,le)}return function(me,le,ye,Ie){try{dp=0;var st=ln(me,le,ye,Ie);return Ec=null,st}catch(et){if(et===Tc||et===$g)throw et;var Ht=Pr(29,et,null,me.mode);return Ht.lanes=Ie,Ht.return=me,Ht}finally{}}}var Jl=IN(!0),TN=IN(!1),_o=!1;function A1(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function D1(l,h){l=l.updateQueue,h.updateQueue===l&&(h.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,callbacks:null})}function Oo(l){return{lane:l,tag:0,payload:null,callback:null,next:null}}function Fo(l,h,f){var y=l.updateQueue;if(y===null)return null;if(y=y.shared,(Xt&2)!==0){var S=y.pending;return S===null?h.next=h:(h.next=S.next,S.next=h),y.pending=h,h=vg(l),hN(l,null,f),h}return bg(l,y,h,f),vg(l)}function fp(l,h,f){if(h=h.updateQueue,h!==null&&(h=h.shared,(f&4194048)!==0)){var y=h.lanes;y&=l.pendingLanes,f|=y,h.lanes=f,eg(l,f)}}function _1(l,h){var f=l.updateQueue,y=l.alternate;if(y!==null&&(y=y.updateQueue,f===y)){var S=null,k=null;if(f=f.firstBaseUpdate,f!==null){do{var _={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};k===null?S=k=_:k=k.next=_,f=f.next}while(f!==null);k===null?S=k=h:k=k.next=h}else S=k=h;f={baseState:y.baseState,firstBaseUpdate:S,lastBaseUpdate:k,shared:y.shared,callbacks:y.callbacks},l.updateQueue=f;return}l=f.lastBaseUpdate,l===null?f.firstBaseUpdate=h:l.next=h,f.lastBaseUpdate=h}var O1=!1;function mp(){if(O1){var l=Ic;if(l!==null)throw l}}function gp(l,h,f,y){O1=!1;var S=l.updateQueue;_o=!1;var k=S.firstBaseUpdate,_=S.lastBaseUpdate,V=S.shared.pending;if(V!==null){S.shared.pending=null;var ne=V,xe=ne.next;ne.next=null,_===null?k=xe:_.next=xe,_=ne;var ke=l.alternate;ke!==null&&(ke=ke.updateQueue,V=ke.lastBaseUpdate,V!==_&&(V===null?ke.firstBaseUpdate=xe:V.next=xe,ke.lastBaseUpdate=ne))}if(k!==null){var Te=S.baseState;_=0,ke=xe=ne=null,V=k;do{var be=V.lane&-536870913,Se=be!==V.lane;if(Se?(Et&be)===be:(y&be)===be){be!==0&&be===$c&&(O1=!0),ke!==null&&(ke=ke.next={lane:0,tag:V.tag,payload:V.payload,callback:null,next:null});e:{var qe=l,lt=V;be=h;var ln=f;switch(lt.tag){case 1:if(qe=lt.payload,typeof qe=="function"){Te=qe.call(ln,Te,be);break e}Te=qe;break e;case 3:qe.flags=qe.flags&-65537|128;case 0:if(qe=lt.payload,be=typeof qe=="function"?qe.call(ln,Te,be):qe,be==null)break e;Te=p({},Te,be);break e;case 2:_o=!0}}be=V.callback,be!==null&&(l.flags|=64,Se&&(l.flags|=8192),Se=S.callbacks,Se===null?S.callbacks=[be]:Se.push(be))}else Se={lane:be,tag:V.tag,payload:V.payload,callback:V.callback,next:null},ke===null?(xe=ke=Se,ne=Te):ke=ke.next=Se,_|=be;if(V=V.next,V===null){if(V=S.shared.pending,V===null)break;Se=V,V=Se.next,Se.next=null,S.lastBaseUpdate=Se,S.shared.pending=null}}while(!0);ke===null&&(ne=Te),S.baseState=ne,S.firstBaseUpdate=xe,S.lastBaseUpdate=ke,k===null&&(S.shared.lanes=0),Bo|=_,l.lanes=_,l.memoizedState=Te}}function EN(l,h){if(typeof l!="function")throw Error(s(191,l));l.call(h)}function RN(l,h){var f=l.callbacks;if(f!==null)for(l.callbacks=null,l=0;l<f.length;l++)EN(f[l],h)}var Rc=G(null),Rg=G(0);function AN(l,h){l=Qa,pe(Rg,l),pe(Rc,h),Qa=l|h.baseLanes}function F1(){pe(Rg,Qa),pe(Rc,Rc.current)}function z1(){Qa=Rg.current,re(Rc),re(Rg)}var Br=G(null),ci=null;function zo(l){var h=l.alternate;pe(Vn,Vn.current&1),pe(Br,l),ci===null&&(h===null||Rc.current!==null||h.memoizedState!==null)&&(ci=l)}function L1(l){pe(Vn,Vn.current),pe(Br,l),ci===null&&(ci=l)}function DN(l){l.tag===22?(pe(Vn,Vn.current),pe(Br,l),ci===null&&(ci=l)):Lo()}function Lo(){pe(Vn,Vn.current),pe(Br,Br.current)}function Vr(l){re(Br),ci===l&&(ci=null),re(Vn)}var Vn=G(0);function Ag(l){for(var h=l;h!==null;){if(h.tag===13){var f=h.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||Wv(f)||Gv(f)))return h}else if(h.tag===19&&(h.memoizedProps.revealOrder==="forwards"||h.memoizedProps.revealOrder==="backwards"||h.memoizedProps.revealOrder==="unstable_legacy-backwards"||h.memoizedProps.revealOrder==="together")){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===l)break;for(;h.sibling===null;){if(h.return===null||h.return===l)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}var Wa=0,vt=null,an=null,Xn=null,Dg=!1,Ac=!1,eu=!1,_g=0,yp=0,Dc=null,VL=0;function On(){throw Error(s(321))}function M1(l,h){if(h===null)return!1;for(var f=0;f<h.length&&f<l.length;f++)if(!Mr(l[f],h[f]))return!1;return!0}function P1(l,h,f,y,S,k){return Wa=k,vt=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,W.H=l===null||l.memoizedState===null?mk:ev,eu=!1,k=f(y,S),eu=!1,Ac&&(k=ON(h,f,y,S)),_N(l),k}function _N(l){W.H=vp;var h=an!==null&&an.next!==null;if(Wa=0,Xn=an=vt=null,Dg=!1,yp=0,Dc=null,h)throw Error(s(300));l===null||Kn||(l=l.dependencies,l!==null&&Cg(l)&&(Kn=!0))}function ON(l,h,f,y){vt=l;var S=0;do{if(Ac&&(Dc=null),yp=0,Ac=!1,25<=S)throw Error(s(301));if(S+=1,Xn=an=null,l.updateQueue!=null){var k=l.updateQueue;k.lastEffect=null,k.events=null,k.stores=null,k.memoCache!=null&&(k.memoCache.index=0)}W.H=gk,k=h(f,y)}while(Ac);return k}function UL(){var l=W.H,h=l.useState()[0];return h=typeof h.then=="function"?xp(h):h,l=l.useState()[0],(an!==null?an.memoizedState:null)!==l&&(vt.flags|=1024),h}function B1(){var l=_g!==0;return _g=0,l}function V1(l,h,f){h.updateQueue=l.updateQueue,h.flags&=-2053,l.lanes&=~f}function U1(l){if(Dg){for(l=l.memoizedState;l!==null;){var h=l.queue;h!==null&&(h.pending=null),l=l.next}Dg=!1}Wa=0,Xn=an=vt=null,Ac=!1,yp=_g=0,Dc=null}function rr(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Xn===null?vt.memoizedState=Xn=l:Xn=Xn.next=l,Xn}function Un(){if(an===null){var l=vt.alternate;l=l!==null?l.memoizedState:null}else l=an.next;var h=Xn===null?vt.memoizedState:Xn.next;if(h!==null)Xn=h,an=l;else{if(l===null)throw vt.alternate===null?Error(s(467)):Error(s(310));an=l,l={memoizedState:an.memoizedState,baseState:an.baseState,baseQueue:an.baseQueue,queue:an.queue,next:null},Xn===null?vt.memoizedState=Xn=l:Xn=Xn.next=l}return Xn}function Og(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function xp(l){var h=yp;return yp+=1,Dc===null&&(Dc=[]),l=NN(Dc,l,h),h=vt,(Xn===null?h.memoizedState:Xn.next)===null&&(h=h.alternate,W.H=h===null||h.memoizedState===null?mk:ev),l}function Fg(l){if(l!==null&&typeof l=="object"){if(typeof l.then=="function")return xp(l);if(l.$$typeof===I)return Ds(l)}throw Error(s(438,String(l)))}function W1(l){var h=null,f=vt.updateQueue;if(f!==null&&(h=f.memoCache),h==null){var y=vt.alternate;y!==null&&(y=y.updateQueue,y!==null&&(y=y.memoCache,y!=null&&(h={data:y.data.map(function(S){return S.slice()}),index:0})))}if(h==null&&(h={data:[],index:0}),f===null&&(f=Og(),vt.updateQueue=f),f.memoCache=h,f=h.data[h.index],f===void 0)for(f=h.data[h.index]=Array(l),y=0;y<l;y++)f[y]=M;return h.index++,f}function Ga(l,h){return typeof h=="function"?h(l):h}function zg(l){var h=Un();return G1(h,an,l)}function G1(l,h,f){var y=l.queue;if(y===null)throw Error(s(311));y.lastRenderedReducer=f;var S=l.baseQueue,k=y.pending;if(k!==null){if(S!==null){var _=S.next;S.next=k.next,k.next=_}h.baseQueue=S=k,y.pending=null}if(k=l.baseState,S===null)l.memoizedState=k;else{h=S.next;var V=_=null,ne=null,xe=h,ke=!1;do{var Te=xe.lane&-536870913;if(Te!==xe.lane?(Et&Te)===Te:(Wa&Te)===Te){var be=xe.revertLane;if(be===0)ne!==null&&(ne=ne.next={lane:0,revertLane:0,gesture:null,action:xe.action,hasEagerState:xe.hasEagerState,eagerState:xe.eagerState,next:null}),Te===$c&&(ke=!0);else if((Wa&be)===be){xe=xe.next,be===$c&&(ke=!0);continue}else Te={lane:0,revertLane:xe.revertLane,gesture:null,action:xe.action,hasEagerState:xe.hasEagerState,eagerState:xe.eagerState,next:null},ne===null?(V=ne=Te,_=k):ne=ne.next=Te,vt.lanes|=be,Bo|=be;Te=xe.action,eu&&f(k,Te),k=xe.hasEagerState?xe.eagerState:f(k,Te)}else be={lane:Te,revertLane:xe.revertLane,gesture:xe.gesture,action:xe.action,hasEagerState:xe.hasEagerState,eagerState:xe.eagerState,next:null},ne===null?(V=ne=be,_=k):ne=ne.next=be,vt.lanes|=Te,Bo|=Te;xe=xe.next}while(xe!==null&&xe!==h);if(ne===null?_=k:ne.next=V,!Mr(k,l.memoizedState)&&(Kn=!0,ke&&(f=Ic,f!==null)))throw f;l.memoizedState=k,l.baseState=_,l.baseQueue=ne,y.lastRenderedState=k}return S===null&&(y.lanes=0),[l.memoizedState,y.dispatch]}function H1(l){var h=Un(),f=h.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=l;var y=f.dispatch,S=f.pending,k=h.memoizedState;if(S!==null){f.pending=null;var _=S=S.next;do k=l(k,_.action),_=_.next;while(_!==S);Mr(k,h.memoizedState)||(Kn=!0),h.memoizedState=k,h.baseQueue===null&&(h.baseState=k),f.lastRenderedState=k}return[k,y]}function FN(l,h,f){var y=vt,S=Un(),k=Lt;if(k){if(f===void 0)throw Error(s(407));f=f()}else f=h();var _=!Mr((an||S).memoizedState,f);if(_&&(S.memoizedState=f,Kn=!0),S=S.queue,X1(MN.bind(null,y,S,l),[l]),S.getSnapshot!==h||_||Xn!==null&&Xn.memoizedState.tag&1){if(y.flags|=2048,_c(9,{destroy:void 0},LN.bind(null,y,S,f,h),null),hn===null)throw Error(s(349));k||(Wa&127)!==0||zN(y,h,f)}return f}function zN(l,h,f){l.flags|=16384,l={getSnapshot:h,value:f},h=vt.updateQueue,h===null?(h=Og(),vt.updateQueue=h,h.stores=[l]):(f=h.stores,f===null?h.stores=[l]:f.push(l))}function LN(l,h,f,y){h.value=f,h.getSnapshot=y,PN(h)&&BN(l)}function MN(l,h,f){return f(function(){PN(h)&&BN(l)})}function PN(l){var h=l.getSnapshot;l=l.value;try{var f=h();return!Mr(l,f)}catch{return!0}}function BN(l){var h=Hl(l,2);h!==null&&wr(h,l,2)}function j1(l){var h=rr();if(typeof l=="function"){var f=l;if(l=f(),eu){Or(!0);try{f()}finally{Or(!1)}}}return h.memoizedState=h.baseState=l,h.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ga,lastRenderedState:l},h}function VN(l,h,f,y){return l.baseState=f,G1(l,an,typeof y=="function"?y:Ga)}function WL(l,h,f,y,S){if(Pg(l))throw Error(s(485));if(l=h.action,l!==null){var k={payload:S,action:l,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(_){k.listeners.push(_)}};W.T!==null?f(!0):k.isTransition=!1,y(k),f=h.pending,f===null?(k.next=h.pending=k,UN(h,k)):(k.next=f.next,h.pending=f.next=k)}}function UN(l,h){var f=h.action,y=h.payload,S=l.state;if(h.isTransition){var k=W.T,_={};W.T=_;try{var V=f(S,y),ne=W.S;ne!==null&&ne(_,V),WN(l,h,V)}catch(xe){q1(l,h,xe)}finally{k!==null&&_.types!==null&&(k.types=_.types),W.T=k}}else try{k=f(S,y),WN(l,h,k)}catch(xe){q1(l,h,xe)}}function WN(l,h,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(y){GN(l,h,y)},function(y){return q1(l,h,y)}):GN(l,h,f)}function GN(l,h,f){h.status="fulfilled",h.value=f,HN(h),l.state=f,h=l.pending,h!==null&&(f=h.next,f===h?l.pending=null:(f=f.next,h.next=f,UN(l,f)))}function q1(l,h,f){var y=l.pending;if(l.pending=null,y!==null){y=y.next;do h.status="rejected",h.reason=f,HN(h),h=h.next;while(h!==y)}l.action=null}function HN(l){l=l.listeners;for(var h=0;h<l.length;h++)(0,l[h])()}function jN(l,h){return h}function qN(l,h){if(Lt){var f=hn.formState;if(f!==null){e:{var y=vt;if(Lt){if(xn){t:{for(var S=xn,k=ui;S.nodeType!==8;){if(!k){S=null;break t}if(S=hi(S.nextSibling),S===null){S=null;break t}}k=S.data,S=k==="F!"||k==="F"?S:null}if(S){xn=hi(S.nextSibling),y=S.data==="F!";break e}}Ao(y)}y=!1}y&&(h=f[0])}}return f=rr(),f.memoizedState=f.baseState=h,y={pending:null,lanes:0,dispatch:null,lastRenderedReducer:jN,lastRenderedState:h},f.queue=y,f=dk.bind(null,vt,y),y.dispatch=f,y=j1(!1),k=J1.bind(null,vt,!1,y.queue),y=rr(),S={state:h,dispatch:null,action:l,pending:null},y.queue=S,f=WL.bind(null,vt,S,k,f),S.dispatch=f,y.memoizedState=l,[h,f,!1]}function XN(l){var h=Un();return KN(h,an,l)}function KN(l,h,f){if(h=G1(l,h,jN)[0],l=zg(Ga)[0],typeof h=="object"&&h!==null&&typeof h.then=="function")try{var y=xp(h)}catch(_){throw _===Tc?$g:_}else y=h;h=Un();var S=h.queue,k=S.dispatch;return f!==h.memoizedState&&(vt.flags|=2048,_c(9,{destroy:void 0},GL.bind(null,S,f),null)),[y,k,l]}function GL(l,h){l.action=h}function YN(l){var h=Un(),f=an;if(f!==null)return KN(h,f,l);Un(),h=h.memoizedState,f=Un();var y=f.queue.dispatch;return f.memoizedState=l,[h,y,!1]}function _c(l,h,f,y){return l={tag:l,create:f,deps:y,inst:h,next:null},h=vt.updateQueue,h===null&&(h=Og(),vt.updateQueue=h),f=h.lastEffect,f===null?h.lastEffect=l.next=l:(y=f.next,f.next=l,l.next=y,h.lastEffect=l),l}function QN(){return Un().memoizedState}function Lg(l,h,f,y){var S=rr();vt.flags|=l,S.memoizedState=_c(1|h,{destroy:void 0},f,y===void 0?null:y)}function Mg(l,h,f,y){var S=Un();y=y===void 0?null:y;var k=S.memoizedState.inst;an!==null&&y!==null&&M1(y,an.memoizedState.deps)?S.memoizedState=_c(h,k,f,y):(vt.flags|=l,S.memoizedState=_c(1|h,k,f,y))}function ZN(l,h){Lg(8390656,8,l,h)}function X1(l,h){Mg(2048,8,l,h)}function HL(l){vt.flags|=4;var h=vt.updateQueue;if(h===null)h=Og(),vt.updateQueue=h,h.events=[l];else{var f=h.events;f===null?h.events=[l]:f.push(l)}}function JN(l){var h=Un().memoizedState;return HL({ref:h,nextImpl:l}),function(){if((Xt&2)!==0)throw Error(s(440));return h.impl.apply(void 0,arguments)}}function ek(l,h){return Mg(4,2,l,h)}function tk(l,h){return Mg(4,4,l,h)}function nk(l,h){if(typeof h=="function"){l=l();var f=h(l);return function(){typeof f=="function"?f():h(null)}}if(h!=null)return l=l(),h.current=l,function(){h.current=null}}function sk(l,h,f){f=f!=null?f.concat([l]):null,Mg(4,4,nk.bind(null,h,l),f)}function K1(){}function rk(l,h){var f=Un();h=h===void 0?null:h;var y=f.memoizedState;return h!==null&&M1(h,y[1])?y[0]:(f.memoizedState=[l,h],l)}function ik(l,h){var f=Un();h=h===void 0?null:h;var y=f.memoizedState;if(h!==null&&M1(h,y[1]))return y[0];if(y=l(),eu){Or(!0);try{l()}finally{Or(!1)}}return f.memoizedState=[y,h],y}function Y1(l,h,f){return f===void 0||(Wa&1073741824)!==0&&(Et&261930)===0?l.memoizedState=h:(l.memoizedState=f,l=a$(),vt.lanes|=l,Bo|=l,f)}function ak(l,h,f,y){return Mr(f,h)?f:Rc.current!==null?(l=Y1(l,f,y),Mr(l,h)||(Kn=!0),l):(Wa&42)===0||(Wa&1073741824)!==0&&(Et&261930)===0?(Kn=!0,l.memoizedState=f):(l=a$(),vt.lanes|=l,Bo|=l,h)}function ok(l,h,f,y,S){var k=ee.p;ee.p=k!==0&&8>k?k:8;var _=W.T,V={};W.T=V,J1(l,!1,h,f);try{var ne=S(),xe=W.S;if(xe!==null&&xe(V,ne),ne!==null&&typeof ne=="object"&&typeof ne.then=="function"){var ke=BL(ne,y);bp(l,h,ke,Gr(l))}else bp(l,h,y,Gr(l))}catch(Te){bp(l,h,{then:function(){},status:"rejected",reason:Te},Gr())}finally{ee.p=k,_!==null&&V.types!==null&&(_.types=V.types),W.T=_}}function jL(){}function Q1(l,h,f,y){if(l.tag!==5)throw Error(s(476));var S=lk(l).queue;ok(l,S,h,ie,f===null?jL:function(){return uk(l),f(y)})}function lk(l){var h=l.memoizedState;if(h!==null)return h;h={memoizedState:ie,baseState:ie,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ga,lastRenderedState:ie},next:null};var f={};return h.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ga,lastRenderedState:f},next:null},l.memoizedState=h,l=l.alternate,l!==null&&(l.memoizedState=h),h}function uk(l){var h=lk(l);h.next===null&&(h=l.alternate.memoizedState),bp(l,h.next.queue,{},Gr())}function Z1(){return Ds(zp)}function ck(){return Un().memoizedState}function hk(){return Un().memoizedState}function qL(l){for(var h=l.return;h!==null;){switch(h.tag){case 24:case 3:var f=Gr();l=Oo(f);var y=Fo(h,l,f);y!==null&&(wr(y,h,f),fp(y,h,f)),h={cache:I1()},l.payload=h;return}h=h.return}}function XL(l,h,f){var y=Gr();f={lane:y,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},Pg(l)?pk(h,f):(f=g1(l,h,f,y),f!==null&&(wr(f,l,y),fk(f,h,y)))}function dk(l,h,f){var y=Gr();bp(l,h,f,y)}function bp(l,h,f,y){var S={lane:y,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(Pg(l))pk(h,S);else{var k=l.alternate;if(l.lanes===0&&(k===null||k.lanes===0)&&(k=h.lastRenderedReducer,k!==null))try{var _=h.lastRenderedState,V=k(_,f);if(S.hasEagerState=!0,S.eagerState=V,Mr(V,_))return bg(l,h,S,0),hn===null&&xg(),!1}catch{}finally{}if(f=g1(l,h,S,y),f!==null)return wr(f,l,y),fk(f,h,y),!0}return!1}function J1(l,h,f,y){if(y={lane:2,revertLane:Av(),gesture:null,action:y,hasEagerState:!1,eagerState:null,next:null},Pg(l)){if(h)throw Error(s(479))}else h=g1(l,f,y,2),h!==null&&wr(h,l,2)}function Pg(l){var h=l.alternate;return l===vt||h!==null&&h===vt}function pk(l,h){Ac=Dg=!0;var f=l.pending;f===null?h.next=h:(h.next=f.next,f.next=h),l.pending=h}function fk(l,h,f){if((f&4194048)!==0){var y=h.lanes;y&=l.pendingLanes,f|=y,h.lanes=f,eg(l,f)}}var vp={readContext:Ds,use:Fg,useCallback:On,useContext:On,useEffect:On,useImperativeHandle:On,useLayoutEffect:On,useInsertionEffect:On,useMemo:On,useReducer:On,useRef:On,useState:On,useDebugValue:On,useDeferredValue:On,useTransition:On,useSyncExternalStore:On,useId:On,useHostTransitionStatus:On,useFormState:On,useActionState:On,useOptimistic:On,useMemoCache:On,useCacheRefresh:On};vp.useEffectEvent=On;var mk={readContext:Ds,use:Fg,useCallback:function(l,h){return rr().memoizedState=[l,h===void 0?null:h],l},useContext:Ds,useEffect:ZN,useImperativeHandle:function(l,h,f){f=f!=null?f.concat([l]):null,Lg(4194308,4,nk.bind(null,h,l),f)},useLayoutEffect:function(l,h){return Lg(4194308,4,l,h)},useInsertionEffect:function(l,h){Lg(4,2,l,h)},useMemo:function(l,h){var f=rr();h=h===void 0?null:h;var y=l();if(eu){Or(!0);try{l()}finally{Or(!1)}}return f.memoizedState=[y,h],y},useReducer:function(l,h,f){var y=rr();if(f!==void 0){var S=f(h);if(eu){Or(!0);try{f(h)}finally{Or(!1)}}}else S=h;return y.memoizedState=y.baseState=S,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:S},y.queue=l,l=l.dispatch=XL.bind(null,vt,l),[y.memoizedState,l]},useRef:function(l){var h=rr();return l={current:l},h.memoizedState=l},useState:function(l){l=j1(l);var h=l.queue,f=dk.bind(null,vt,h);return h.dispatch=f,[l.memoizedState,f]},useDebugValue:K1,useDeferredValue:function(l,h){var f=rr();return Y1(f,l,h)},useTransition:function(){var l=j1(!1);return l=ok.bind(null,vt,l.queue,!0,!1),rr().memoizedState=l,[!1,l]},useSyncExternalStore:function(l,h,f){var y=vt,S=rr();if(Lt){if(f===void 0)throw Error(s(407));f=f()}else{if(f=h(),hn===null)throw Error(s(349));(Et&127)!==0||zN(y,h,f)}S.memoizedState=f;var k={value:f,getSnapshot:h};return S.queue=k,ZN(MN.bind(null,y,k,l),[l]),y.flags|=2048,_c(9,{destroy:void 0},LN.bind(null,y,k,f,h),null),f},useId:function(){var l=rr(),h=hn.identifierPrefix;if(Lt){var f=ua,y=la;f=(y&~(1<<32-nr(y)-1)).toString(32)+f,h="_"+h+"R_"+f,f=_g++,0<f&&(h+="H"+f.toString(32)),h+="_"}else f=VL++,h="_"+h+"r_"+f.toString(32)+"_";return l.memoizedState=h},useHostTransitionStatus:Z1,useFormState:qN,useActionState:qN,useOptimistic:function(l){var h=rr();h.memoizedState=h.baseState=l;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return h.queue=f,h=J1.bind(null,vt,!0,f),f.dispatch=h,[l,h]},useMemoCache:W1,useCacheRefresh:function(){return rr().memoizedState=qL.bind(null,vt)},useEffectEvent:function(l){var h=rr(),f={impl:l};return h.memoizedState=f,function(){if((Xt&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},ev={readContext:Ds,use:Fg,useCallback:rk,useContext:Ds,useEffect:X1,useImperativeHandle:sk,useInsertionEffect:ek,useLayoutEffect:tk,useMemo:ik,useReducer:zg,useRef:QN,useState:function(){return zg(Ga)},useDebugValue:K1,useDeferredValue:function(l,h){var f=Un();return ak(f,an.memoizedState,l,h)},useTransition:function(){var l=zg(Ga)[0],h=Un().memoizedState;return[typeof l=="boolean"?l:xp(l),h]},useSyncExternalStore:FN,useId:ck,useHostTransitionStatus:Z1,useFormState:XN,useActionState:XN,useOptimistic:function(l,h){var f=Un();return VN(f,an,l,h)},useMemoCache:W1,useCacheRefresh:hk};ev.useEffectEvent=JN;var gk={readContext:Ds,use:Fg,useCallback:rk,useContext:Ds,useEffect:X1,useImperativeHandle:sk,useInsertionEffect:ek,useLayoutEffect:tk,useMemo:ik,useReducer:H1,useRef:QN,useState:function(){return H1(Ga)},useDebugValue:K1,useDeferredValue:function(l,h){var f=Un();return an===null?Y1(f,l,h):ak(f,an.memoizedState,l,h)},useTransition:function(){var l=H1(Ga)[0],h=Un().memoizedState;return[typeof l=="boolean"?l:xp(l),h]},useSyncExternalStore:FN,useId:ck,useHostTransitionStatus:Z1,useFormState:YN,useActionState:YN,useOptimistic:function(l,h){var f=Un();return an!==null?VN(f,an,l,h):(f.baseState=l,[l,f.queue.dispatch])},useMemoCache:W1,useCacheRefresh:hk};gk.useEffectEvent=JN;function tv(l,h,f,y){h=l.memoizedState,f=f(y,h),f=f==null?h:p({},h,f),l.memoizedState=f,l.lanes===0&&(l.updateQueue.baseState=f)}var nv={enqueueSetState:function(l,h,f){l=l._reactInternals;var y=Gr(),S=Oo(y);S.payload=h,f!=null&&(S.callback=f),h=Fo(l,S,y),h!==null&&(wr(h,l,y),fp(h,l,y))},enqueueReplaceState:function(l,h,f){l=l._reactInternals;var y=Gr(),S=Oo(y);S.tag=1,S.payload=h,f!=null&&(S.callback=f),h=Fo(l,S,y),h!==null&&(wr(h,l,y),fp(h,l,y))},enqueueForceUpdate:function(l,h){l=l._reactInternals;var f=Gr(),y=Oo(f);y.tag=2,h!=null&&(y.callback=h),h=Fo(l,y,f),h!==null&&(wr(h,l,f),fp(h,l,f))}};function yk(l,h,f,y,S,k,_){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(y,k,_):h.prototype&&h.prototype.isPureReactComponent?!ap(f,y)||!ap(S,k):!0}function xk(l,h,f,y){l=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(f,y),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(f,y),h.state!==l&&nv.enqueueReplaceState(h,h.state,null)}function tu(l,h){var f=h;if("ref"in h){f={};for(var y in h)y!=="ref"&&(f[y]=h[y])}if(l=l.defaultProps){f===h&&(f=p({},f));for(var S in l)f[S]===void 0&&(f[S]=l[S])}return f}function bk(l){yg(l)}function vk(l){console.error(l)}function wk(l){yg(l)}function Bg(l,h){try{var f=l.onUncaughtError;f(h.value,{componentStack:h.stack})}catch(y){setTimeout(function(){throw y})}}function Sk(l,h,f){try{var y=l.onCaughtError;y(f.value,{componentStack:f.stack,errorBoundary:h.tag===1?h.stateNode:null})}catch(S){setTimeout(function(){throw S})}}function sv(l,h,f){return f=Oo(f),f.tag=3,f.payload={element:null},f.callback=function(){Bg(l,h)},f}function Ck(l){return l=Oo(l),l.tag=3,l}function Nk(l,h,f,y){var S=f.type.getDerivedStateFromError;if(typeof S=="function"){var k=y.value;l.payload=function(){return S(k)},l.callback=function(){Sk(h,f,y)}}var _=f.stateNode;_!==null&&typeof _.componentDidCatch=="function"&&(l.callback=function(){Sk(h,f,y),typeof S!="function"&&(Vo===null?Vo=new Set([this]):Vo.add(this));var V=y.stack;this.componentDidCatch(y.value,{componentStack:V!==null?V:""})})}function KL(l,h,f,y,S){if(f.flags|=32768,y!==null&&typeof y=="object"&&typeof y.then=="function"){if(h=f.alternate,h!==null&&kc(h,f,S,!0),f=Br.current,f!==null){switch(f.tag){case 31:case 13:return ci===null?Zg():f.alternate===null&&Fn===0&&(Fn=3),f.flags&=-257,f.flags|=65536,f.lanes=S,y===Ig?f.flags|=16384:(h=f.updateQueue,h===null?f.updateQueue=new Set([y]):h.add(y),Tv(l,y,S)),!1;case 22:return f.flags|=65536,y===Ig?f.flags|=16384:(h=f.updateQueue,h===null?(h={transitions:null,markerInstances:null,retryQueue:new Set([y])},f.updateQueue=h):(f=h.retryQueue,f===null?h.retryQueue=new Set([y]):f.add(y)),Tv(l,y,S)),!1}throw Error(s(435,f.tag))}return Tv(l,y,S),Zg(),!1}if(Lt)return h=Br.current,h!==null?((h.flags&65536)===0&&(h.flags|=256),h.flags|=65536,h.lanes=S,y!==S1&&(l=Error(s(422),{cause:y}),up(ai(l,f)))):(y!==S1&&(h=Error(s(423),{cause:y}),up(ai(h,f))),l=l.current.alternate,l.flags|=65536,S&=-S,l.lanes|=S,y=ai(y,f),S=sv(l.stateNode,y,S),_1(l,S),Fn!==4&&(Fn=2)),!1;var k=Error(s(520),{cause:y});if(k=ai(k,f),Tp===null?Tp=[k]:Tp.push(k),Fn!==4&&(Fn=2),h===null)return!0;y=ai(y,f),f=h;do{switch(f.tag){case 3:return f.flags|=65536,l=S&-S,f.lanes|=l,l=sv(f.stateNode,y,l),_1(f,l),!1;case 1:if(h=f.type,k=f.stateNode,(f.flags&128)===0&&(typeof h.getDerivedStateFromError=="function"||k!==null&&typeof k.componentDidCatch=="function"&&(Vo===null||!Vo.has(k))))return f.flags|=65536,S&=-S,f.lanes|=S,S=Ck(S),Nk(S,l,f,y),_1(f,S),!1}f=f.return}while(f!==null);return!1}var rv=Error(s(461)),Kn=!1;function _s(l,h,f,y){h.child=l===null?TN(h,null,f,y):Jl(h,l.child,f,y)}function kk(l,h,f,y,S){f=f.render;var k=h.ref;if("ref"in y){var _={};for(var V in y)V!=="ref"&&(_[V]=y[V])}else _=y;return Kl(h),y=P1(l,h,f,_,k,S),V=B1(),l!==null&&!Kn?(V1(l,h,S),Ha(l,h,S)):(Lt&&V&&v1(h),h.flags|=1,_s(l,h,y,S),h.child)}function $k(l,h,f,y,S){if(l===null){var k=f.type;return typeof k=="function"&&!y1(k)&&k.defaultProps===void 0&&f.compare===null?(h.tag=15,h.type=k,Ik(l,h,k,y,S)):(l=wg(f.type,null,y,h,h.mode,S),l.ref=h.ref,l.return=h,h.child=l)}if(k=l.child,!dv(l,S)){var _=k.memoizedProps;if(f=f.compare,f=f!==null?f:ap,f(_,y)&&l.ref===h.ref)return Ha(l,h,S)}return h.flags|=1,l=Pa(k,y),l.ref=h.ref,l.return=h,h.child=l}function Ik(l,h,f,y,S){if(l!==null){var k=l.memoizedProps;if(ap(k,y)&&l.ref===h.ref)if(Kn=!1,h.pendingProps=y=k,dv(l,S))(l.flags&131072)!==0&&(Kn=!0);else return h.lanes=l.lanes,Ha(l,h,S)}return iv(l,h,f,y,S)}function Tk(l,h,f,y){var S=y.children,k=l!==null?l.memoizedState:null;if(l===null&&h.stateNode===null&&(h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),y.mode==="hidden"){if((h.flags&128)!==0){if(k=k!==null?k.baseLanes|f:f,l!==null){for(y=h.child=l.child,S=0;y!==null;)S=S|y.lanes|y.childLanes,y=y.sibling;y=S&~k}else y=0,h.child=null;return Ek(l,h,k,f,y)}if((f&536870912)!==0)h.memoizedState={baseLanes:0,cachePool:null},l!==null&&kg(h,k!==null?k.cachePool:null),k!==null?AN(h,k):F1(),DN(h);else return y=h.lanes=536870912,Ek(l,h,k!==null?k.baseLanes|f:f,f,y)}else k!==null?(kg(h,k.cachePool),AN(h,k),Lo(),h.memoizedState=null):(l!==null&&kg(h,null),F1(),Lo());return _s(l,h,S,f),h.child}function wp(l,h){return l!==null&&l.tag===22||h.stateNode!==null||(h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),h.sibling}function Ek(l,h,f,y,S){var k=E1();return k=k===null?null:{parent:qn._currentValue,pool:k},h.memoizedState={baseLanes:f,cachePool:k},l!==null&&kg(h,null),F1(),DN(h),l!==null&&kc(l,h,y,!0),h.childLanes=S,null}function Vg(l,h){return h=Wg({mode:h.mode,children:h.children},l.mode),h.ref=l.ref,l.child=h,h.return=l,h}function Rk(l,h,f){return Jl(h,l.child,null,f),l=Vg(h,h.pendingProps),l.flags|=2,Vr(h),h.memoizedState=null,l}function YL(l,h,f){var y=h.pendingProps,S=(h.flags&128)!==0;if(h.flags&=-129,l===null){if(Lt){if(y.mode==="hidden")return l=Vg(h,y),h.lanes=536870912,wp(null,l);if(L1(h),(l=xn)?(l=U$(l,ui),l=l!==null&&l.data==="&"?l:null,l!==null&&(h.memoizedState={dehydrated:l,treeContext:Eo!==null?{id:la,overflow:ua}:null,retryLane:536870912,hydrationErrors:null},f=pN(l),f.return=h,h.child=f,As=h,xn=null)):l=null,l===null)throw Ao(h);return h.lanes=536870912,null}return Vg(h,y)}var k=l.memoizedState;if(k!==null){var _=k.dehydrated;if(L1(h),S)if(h.flags&256)h.flags&=-257,h=Rk(l,h,f);else if(h.memoizedState!==null)h.child=l.child,h.flags|=128,h=null;else throw Error(s(558));else if(Kn||kc(l,h,f,!1),S=(f&l.childLanes)!==0,Kn||S){if(y=hn,y!==null&&(_=ti(y,f),_!==0&&_!==k.retryLane))throw k.retryLane=_,Hl(l,_),wr(y,l,_),rv;Zg(),h=Rk(l,h,f)}else l=k.treeContext,xn=hi(_.nextSibling),As=h,Lt=!0,Ro=null,ui=!1,l!==null&&gN(h,l),h=Vg(h,y),h.flags|=4096;return h}return l=Pa(l.child,{mode:y.mode,children:y.children}),l.ref=h.ref,h.child=l,l.return=h,l}function Ug(l,h){var f=h.ref;if(f===null)l!==null&&l.ref!==null&&(h.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(l===null||l.ref!==f)&&(h.flags|=4194816)}}function iv(l,h,f,y,S){return Kl(h),f=P1(l,h,f,y,void 0,S),y=B1(),l!==null&&!Kn?(V1(l,h,S),Ha(l,h,S)):(Lt&&y&&v1(h),h.flags|=1,_s(l,h,f,S),h.child)}function Ak(l,h,f,y,S,k){return Kl(h),h.updateQueue=null,f=ON(h,y,f,S),_N(l),y=B1(),l!==null&&!Kn?(V1(l,h,k),Ha(l,h,k)):(Lt&&y&&v1(h),h.flags|=1,_s(l,h,f,k),h.child)}function Dk(l,h,f,y,S){if(Kl(h),h.stateNode===null){var k=wc,_=f.contextType;typeof _=="object"&&_!==null&&(k=Ds(_)),k=new f(y,k),h.memoizedState=k.state!==null&&k.state!==void 0?k.state:null,k.updater=nv,h.stateNode=k,k._reactInternals=h,k=h.stateNode,k.props=y,k.state=h.memoizedState,k.refs={},A1(h),_=f.contextType,k.context=typeof _=="object"&&_!==null?Ds(_):wc,k.state=h.memoizedState,_=f.getDerivedStateFromProps,typeof _=="function"&&(tv(h,f,_,y),k.state=h.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof k.getSnapshotBeforeUpdate=="function"||typeof k.UNSAFE_componentWillMount!="function"&&typeof k.componentWillMount!="function"||(_=k.state,typeof k.componentWillMount=="function"&&k.componentWillMount(),typeof k.UNSAFE_componentWillMount=="function"&&k.UNSAFE_componentWillMount(),_!==k.state&&nv.enqueueReplaceState(k,k.state,null),gp(h,y,k,S),mp(),k.state=h.memoizedState),typeof k.componentDidMount=="function"&&(h.flags|=4194308),y=!0}else if(l===null){k=h.stateNode;var V=h.memoizedProps,ne=tu(f,V);k.props=ne;var xe=k.context,ke=f.contextType;_=wc,typeof ke=="object"&&ke!==null&&(_=Ds(ke));var Te=f.getDerivedStateFromProps;ke=typeof Te=="function"||typeof k.getSnapshotBeforeUpdate=="function",V=h.pendingProps!==V,ke||typeof k.UNSAFE_componentWillReceiveProps!="function"&&typeof k.componentWillReceiveProps!="function"||(V||xe!==_)&&xk(h,k,y,_),_o=!1;var be=h.memoizedState;k.state=be,gp(h,y,k,S),mp(),xe=h.memoizedState,V||be!==xe||_o?(typeof Te=="function"&&(tv(h,f,Te,y),xe=h.memoizedState),(ne=_o||yk(h,f,ne,y,be,xe,_))?(ke||typeof k.UNSAFE_componentWillMount!="function"&&typeof k.componentWillMount!="function"||(typeof k.componentWillMount=="function"&&k.componentWillMount(),typeof k.UNSAFE_componentWillMount=="function"&&k.UNSAFE_componentWillMount()),typeof k.componentDidMount=="function"&&(h.flags|=4194308)):(typeof k.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=y,h.memoizedState=xe),k.props=y,k.state=xe,k.context=_,y=ne):(typeof k.componentDidMount=="function"&&(h.flags|=4194308),y=!1)}else{k=h.stateNode,D1(l,h),_=h.memoizedProps,ke=tu(f,_),k.props=ke,Te=h.pendingProps,be=k.context,xe=f.contextType,ne=wc,typeof xe=="object"&&xe!==null&&(ne=Ds(xe)),V=f.getDerivedStateFromProps,(xe=typeof V=="function"||typeof k.getSnapshotBeforeUpdate=="function")||typeof k.UNSAFE_componentWillReceiveProps!="function"&&typeof k.componentWillReceiveProps!="function"||(_!==Te||be!==ne)&&xk(h,k,y,ne),_o=!1,be=h.memoizedState,k.state=be,gp(h,y,k,S),mp();var Se=h.memoizedState;_!==Te||be!==Se||_o||l!==null&&l.dependencies!==null&&Cg(l.dependencies)?(typeof V=="function"&&(tv(h,f,V,y),Se=h.memoizedState),(ke=_o||yk(h,f,ke,y,be,Se,ne)||l!==null&&l.dependencies!==null&&Cg(l.dependencies))?(xe||typeof k.UNSAFE_componentWillUpdate!="function"&&typeof k.componentWillUpdate!="function"||(typeof k.componentWillUpdate=="function"&&k.componentWillUpdate(y,Se,ne),typeof k.UNSAFE_componentWillUpdate=="function"&&k.UNSAFE_componentWillUpdate(y,Se,ne)),typeof k.componentDidUpdate=="function"&&(h.flags|=4),typeof k.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof k.componentDidUpdate!="function"||_===l.memoizedProps&&be===l.memoizedState||(h.flags|=4),typeof k.getSnapshotBeforeUpdate!="function"||_===l.memoizedProps&&be===l.memoizedState||(h.flags|=1024),h.memoizedProps=y,h.memoizedState=Se),k.props=y,k.state=Se,k.context=ne,y=ke):(typeof k.componentDidUpdate!="function"||_===l.memoizedProps&&be===l.memoizedState||(h.flags|=4),typeof k.getSnapshotBeforeUpdate!="function"||_===l.memoizedProps&&be===l.memoizedState||(h.flags|=1024),y=!1)}return k=y,Ug(l,h),y=(h.flags&128)!==0,k||y?(k=h.stateNode,f=y&&typeof f.getDerivedStateFromError!="function"?null:k.render(),h.flags|=1,l!==null&&y?(h.child=Jl(h,l.child,null,S),h.child=Jl(h,null,f,S)):_s(l,h,f,S),h.memoizedState=k.state,l=h.child):l=Ha(l,h,S),l}function _k(l,h,f,y){return ql(),h.flags|=256,_s(l,h,f,y),h.child}var av={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function ov(l){return{baseLanes:l,cachePool:SN()}}function lv(l,h,f){return l=l!==null?l.childLanes&~f:0,h&&(l|=Wr),l}function Ok(l,h,f){var y=h.pendingProps,S=!1,k=(h.flags&128)!==0,_;if((_=k)||(_=l!==null&&l.memoizedState===null?!1:(Vn.current&2)!==0),_&&(S=!0,h.flags&=-129),_=(h.flags&32)!==0,h.flags&=-33,l===null){if(Lt){if(S?zo(h):Lo(),(l=xn)?(l=U$(l,ui),l=l!==null&&l.data!=="&"?l:null,l!==null&&(h.memoizedState={dehydrated:l,treeContext:Eo!==null?{id:la,overflow:ua}:null,retryLane:536870912,hydrationErrors:null},f=pN(l),f.return=h,h.child=f,As=h,xn=null)):l=null,l===null)throw Ao(h);return Gv(l)?h.lanes=32:h.lanes=536870912,null}var V=y.children;return y=y.fallback,S?(Lo(),S=h.mode,V=Wg({mode:"hidden",children:V},S),y=jl(y,S,f,null),V.return=h,y.return=h,V.sibling=y,h.child=V,y=h.child,y.memoizedState=ov(f),y.childLanes=lv(l,_,f),h.memoizedState=av,wp(null,y)):(zo(h),uv(h,V))}var ne=l.memoizedState;if(ne!==null&&(V=ne.dehydrated,V!==null)){if(k)h.flags&256?(zo(h),h.flags&=-257,h=cv(l,h,f)):h.memoizedState!==null?(Lo(),h.child=l.child,h.flags|=128,h=null):(Lo(),V=y.fallback,S=h.mode,y=Wg({mode:"visible",children:y.children},S),V=jl(V,S,f,null),V.flags|=2,y.return=h,V.return=h,y.sibling=V,h.child=y,Jl(h,l.child,null,f),y=h.child,y.memoizedState=ov(f),y.childLanes=lv(l,_,f),h.memoizedState=av,h=wp(null,y));else if(zo(h),Gv(V)){if(_=V.nextSibling&&V.nextSibling.dataset,_)var xe=_.dgst;_=xe,y=Error(s(419)),y.stack="",y.digest=_,up({value:y,source:null,stack:null}),h=cv(l,h,f)}else if(Kn||kc(l,h,f,!1),_=(f&l.childLanes)!==0,Kn||_){if(_=hn,_!==null&&(y=ti(_,f),y!==0&&y!==ne.retryLane))throw ne.retryLane=y,Hl(l,y),wr(_,l,y),rv;Wv(V)||Zg(),h=cv(l,h,f)}else Wv(V)?(h.flags|=192,h.child=l.child,h=null):(l=ne.treeContext,xn=hi(V.nextSibling),As=h,Lt=!0,Ro=null,ui=!1,l!==null&&gN(h,l),h=uv(h,y.children),h.flags|=4096);return h}return S?(Lo(),V=y.fallback,S=h.mode,ne=l.child,xe=ne.sibling,y=Pa(ne,{mode:"hidden",children:y.children}),y.subtreeFlags=ne.subtreeFlags&65011712,xe!==null?V=Pa(xe,V):(V=jl(V,S,f,null),V.flags|=2),V.return=h,y.return=h,y.sibling=V,h.child=y,wp(null,y),y=h.child,V=l.child.memoizedState,V===null?V=ov(f):(S=V.cachePool,S!==null?(ne=qn._currentValue,S=S.parent!==ne?{parent:ne,pool:ne}:S):S=SN(),V={baseLanes:V.baseLanes|f,cachePool:S}),y.memoizedState=V,y.childLanes=lv(l,_,f),h.memoizedState=av,wp(l.child,y)):(zo(h),f=l.child,l=f.sibling,f=Pa(f,{mode:"visible",children:y.children}),f.return=h,f.sibling=null,l!==null&&(_=h.deletions,_===null?(h.deletions=[l],h.flags|=16):_.push(l)),h.child=f,h.memoizedState=null,f)}function uv(l,h){return h=Wg({mode:"visible",children:h},l.mode),h.return=l,l.child=h}function Wg(l,h){return l=Pr(22,l,null,h),l.lanes=0,l}function cv(l,h,f){return Jl(h,l.child,null,f),l=uv(h,h.pendingProps.children),l.flags|=2,h.memoizedState=null,l}function Fk(l,h,f){l.lanes|=h;var y=l.alternate;y!==null&&(y.lanes|=h),k1(l.return,h,f)}function hv(l,h,f,y,S,k){var _=l.memoizedState;_===null?l.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:y,tail:f,tailMode:S,treeForkCount:k}:(_.isBackwards=h,_.rendering=null,_.renderingStartTime=0,_.last=y,_.tail=f,_.tailMode=S,_.treeForkCount=k)}function zk(l,h,f){var y=h.pendingProps,S=y.revealOrder,k=y.tail;y=y.children;var _=Vn.current,V=(_&2)!==0;if(V?(_=_&1|2,h.flags|=128):_&=1,pe(Vn,_),_s(l,h,y,f),y=Lt?lp:0,!V&&l!==null&&(l.flags&128)!==0)e:for(l=h.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&Fk(l,f,h);else if(l.tag===19)Fk(l,f,h);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===h)break e;for(;l.sibling===null;){if(l.return===null||l.return===h)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}switch(S){case"forwards":for(f=h.child,S=null;f!==null;)l=f.alternate,l!==null&&Ag(l)===null&&(S=f),f=f.sibling;f=S,f===null?(S=h.child,h.child=null):(S=f.sibling,f.sibling=null),hv(h,!1,S,f,k,y);break;case"backwards":case"unstable_legacy-backwards":for(f=null,S=h.child,h.child=null;S!==null;){if(l=S.alternate,l!==null&&Ag(l)===null){h.child=S;break}l=S.sibling,S.sibling=f,f=S,S=l}hv(h,!0,f,null,k,y);break;case"together":hv(h,!1,null,null,void 0,y);break;default:h.memoizedState=null}return h.child}function Ha(l,h,f){if(l!==null&&(h.dependencies=l.dependencies),Bo|=h.lanes,(f&h.childLanes)===0)if(l!==null){if(kc(l,h,f,!1),(f&h.childLanes)===0)return null}else return null;if(l!==null&&h.child!==l.child)throw Error(s(153));if(h.child!==null){for(l=h.child,f=Pa(l,l.pendingProps),h.child=f,f.return=h;l.sibling!==null;)l=l.sibling,f=f.sibling=Pa(l,l.pendingProps),f.return=h;f.sibling=null}return h.child}function dv(l,h){return(l.lanes&h)!==0?!0:(l=l.dependencies,!!(l!==null&&Cg(l)))}function QL(l,h,f){switch(h.tag){case 3:je(h,h.stateNode.containerInfo),Do(h,qn,l.memoizedState.cache),ql();break;case 27:case 5:at(h);break;case 4:je(h,h.stateNode.containerInfo);break;case 10:Do(h,h.type,h.memoizedProps.value);break;case 31:if(h.memoizedState!==null)return h.flags|=128,L1(h),null;break;case 13:var y=h.memoizedState;if(y!==null)return y.dehydrated!==null?(zo(h),h.flags|=128,null):(f&h.child.childLanes)!==0?Ok(l,h,f):(zo(h),l=Ha(l,h,f),l!==null?l.sibling:null);zo(h);break;case 19:var S=(l.flags&128)!==0;if(y=(f&h.childLanes)!==0,y||(kc(l,h,f,!1),y=(f&h.childLanes)!==0),S){if(y)return zk(l,h,f);h.flags|=128}if(S=h.memoizedState,S!==null&&(S.rendering=null,S.tail=null,S.lastEffect=null),pe(Vn,Vn.current),y)break;return null;case 22:return h.lanes=0,Tk(l,h,f,h.pendingProps);case 24:Do(h,qn,l.memoizedState.cache)}return Ha(l,h,f)}function Lk(l,h,f){if(l!==null)if(l.memoizedProps!==h.pendingProps)Kn=!0;else{if(!dv(l,f)&&(h.flags&128)===0)return Kn=!1,QL(l,h,f);Kn=(l.flags&131072)!==0}else Kn=!1,Lt&&(h.flags&1048576)!==0&&mN(h,lp,h.index);switch(h.lanes=0,h.tag){case 16:e:{var y=h.pendingProps;if(l=Ql(h.elementType),h.type=l,typeof l=="function")y1(l)?(y=tu(l,y),h.tag=1,h=Dk(null,h,l,y,f)):(h.tag=0,h=iv(null,h,l,y,f));else{if(l!=null){var S=l.$$typeof;if(S===$){h.tag=11,h=kk(null,h,l,y,f);break e}else if(S===F){h.tag=14,h=$k(null,h,l,y,f);break e}}throw h=te(l)||l,Error(s(306,h,""))}}return h;case 0:return iv(l,h,h.type,h.pendingProps,f);case 1:return y=h.type,S=tu(y,h.pendingProps),Dk(l,h,y,S,f);case 3:e:{if(je(h,h.stateNode.containerInfo),l===null)throw Error(s(387));y=h.pendingProps;var k=h.memoizedState;S=k.element,D1(l,h),gp(h,y,null,f);var _=h.memoizedState;if(y=_.cache,Do(h,qn,y),y!==k.cache&&$1(h,[qn],f,!0),mp(),y=_.element,k.isDehydrated)if(k={element:y,isDehydrated:!1,cache:_.cache},h.updateQueue.baseState=k,h.memoizedState=k,h.flags&256){h=_k(l,h,y,f);break e}else if(y!==S){S=ai(Error(s(424)),h),up(S),h=_k(l,h,y,f);break e}else{switch(l=h.stateNode.containerInfo,l.nodeType){case 9:l=l.body;break;default:l=l.nodeName==="HTML"?l.ownerDocument.body:l}for(xn=hi(l.firstChild),As=h,Lt=!0,Ro=null,ui=!0,f=TN(h,null,y,f),h.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling}else{if(ql(),y===S){h=Ha(l,h,f);break e}_s(l,h,y,f)}h=h.child}return h;case 26:return Ug(l,h),l===null?(f=X$(h.type,null,h.pendingProps,null))?h.memoizedState=f:Lt||(f=h.type,l=h.pendingProps,y=iy(Ee.current).createElement(f),y[us]=h,y[cs]=l,Os(y,f,l),_n(y),h.stateNode=y):h.memoizedState=X$(h.type,l.memoizedProps,h.pendingProps,l.memoizedState),null;case 27:return at(h),l===null&&Lt&&(y=h.stateNode=H$(h.type,h.pendingProps,Ee.current),As=h,ui=!0,S=xn,Ho(h.type)?(Hv=S,xn=hi(y.firstChild)):xn=S),_s(l,h,h.pendingProps.children,f),Ug(l,h),l===null&&(h.flags|=4194304),h.child;case 5:return l===null&&Lt&&((S=y=xn)&&(y=IM(y,h.type,h.pendingProps,ui),y!==null?(h.stateNode=y,As=h,xn=hi(y.firstChild),ui=!1,S=!0):S=!1),S||Ao(h)),at(h),S=h.type,k=h.pendingProps,_=l!==null?l.memoizedProps:null,y=k.children,Bv(S,k)?y=null:_!==null&&Bv(S,_)&&(h.flags|=32),h.memoizedState!==null&&(S=P1(l,h,UL,null,null,f),zp._currentValue=S),Ug(l,h),_s(l,h,y,f),h.child;case 6:return l===null&&Lt&&((l=f=xn)&&(f=TM(f,h.pendingProps,ui),f!==null?(h.stateNode=f,As=h,xn=null,l=!0):l=!1),l||Ao(h)),null;case 13:return Ok(l,h,f);case 4:return je(h,h.stateNode.containerInfo),y=h.pendingProps,l===null?h.child=Jl(h,null,y,f):_s(l,h,y,f),h.child;case 11:return kk(l,h,h.type,h.pendingProps,f);case 7:return _s(l,h,h.pendingProps,f),h.child;case 8:return _s(l,h,h.pendingProps.children,f),h.child;case 12:return _s(l,h,h.pendingProps.children,f),h.child;case 10:return y=h.pendingProps,Do(h,h.type,y.value),_s(l,h,y.children,f),h.child;case 9:return S=h.type._context,y=h.pendingProps.children,Kl(h),S=Ds(S),y=y(S),h.flags|=1,_s(l,h,y,f),h.child;case 14:return $k(l,h,h.type,h.pendingProps,f);case 15:return Ik(l,h,h.type,h.pendingProps,f);case 19:return zk(l,h,f);case 31:return YL(l,h,f);case 22:return Tk(l,h,f,h.pendingProps);case 24:return Kl(h),y=Ds(qn),l===null?(S=E1(),S===null&&(S=hn,k=I1(),S.pooledCache=k,k.refCount++,k!==null&&(S.pooledCacheLanes|=f),S=k),h.memoizedState={parent:y,cache:S},A1(h),Do(h,qn,S)):((l.lanes&f)!==0&&(D1(l,h),gp(h,null,null,f),mp()),S=l.memoizedState,k=h.memoizedState,S.parent!==y?(S={parent:y,cache:y},h.memoizedState=S,h.lanes===0&&(h.memoizedState=h.updateQueue.baseState=S),Do(h,qn,y)):(y=k.cache,Do(h,qn,y),y!==S.cache&&$1(h,[qn],f,!0))),_s(l,h,h.pendingProps.children,f),h.child;case 29:throw h.pendingProps}throw Error(s(156,h.tag))}function ja(l){l.flags|=4}function pv(l,h,f,y,S){if((h=(l.mode&32)!==0)&&(h=!1),h){if(l.flags|=16777216,(S&335544128)===S)if(l.stateNode.complete)l.flags|=8192;else if(c$())l.flags|=8192;else throw Zl=Ig,R1}else l.flags&=-16777217}function Mk(l,h){if(h.type!=="stylesheet"||(h.state.loading&4)!==0)l.flags&=-16777217;else if(l.flags|=16777216,!J$(h))if(c$())l.flags|=8192;else throw Zl=Ig,R1}function Gg(l,h){h!==null&&(l.flags|=4),l.flags&16384&&(h=l.tag!==22?Wd():536870912,l.lanes|=h,Lc|=h)}function Sp(l,h){if(!Lt)switch(l.tailMode){case"hidden":h=l.tail;for(var f=null;h!==null;)h.alternate!==null&&(f=h),h=h.sibling;f===null?l.tail=null:f.sibling=null;break;case"collapsed":f=l.tail;for(var y=null;f!==null;)f.alternate!==null&&(y=f),f=f.sibling;y===null?h||l.tail===null?l.tail=null:l.tail.sibling=null:y.sibling=null}}function bn(l){var h=l.alternate!==null&&l.alternate.child===l.child,f=0,y=0;if(h)for(var S=l.child;S!==null;)f|=S.lanes|S.childLanes,y|=S.subtreeFlags&65011712,y|=S.flags&65011712,S.return=l,S=S.sibling;else for(S=l.child;S!==null;)f|=S.lanes|S.childLanes,y|=S.subtreeFlags,y|=S.flags,S.return=l,S=S.sibling;return l.subtreeFlags|=y,l.childLanes=f,h}function ZL(l,h,f){var y=h.pendingProps;switch(w1(h),h.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return bn(h),null;case 1:return bn(h),null;case 3:return f=h.stateNode,y=null,l!==null&&(y=l.memoizedState.cache),h.memoizedState.cache!==y&&(h.flags|=2048),Ua(qn),Be(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(l===null||l.child===null)&&(Nc(h)?ja(h):l===null||l.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,C1())),bn(h),null;case 26:var S=h.type,k=h.memoizedState;return l===null?(ja(h),k!==null?(bn(h),Mk(h,k)):(bn(h),pv(h,S,null,y,f))):k?k!==l.memoizedState?(ja(h),bn(h),Mk(h,k)):(bn(h),h.flags&=-16777217):(l=l.memoizedProps,l!==y&&ja(h),bn(h),pv(h,S,l,y,f)),null;case 27:if(ot(h),f=Ee.current,S=h.type,l!==null&&h.stateNode!=null)l.memoizedProps!==y&&ja(h);else{if(!y){if(h.stateNode===null)throw Error(s(166));return bn(h),null}l=ve.current,Nc(h)?yN(h):(l=H$(S,y,f),h.stateNode=l,ja(h))}return bn(h),null;case 5:if(ot(h),S=h.type,l!==null&&h.stateNode!=null)l.memoizedProps!==y&&ja(h);else{if(!y){if(h.stateNode===null)throw Error(s(166));return bn(h),null}if(k=ve.current,Nc(h))yN(h);else{var _=iy(Ee.current);switch(k){case 1:k=_.createElementNS("http://www.w3.org/2000/svg",S);break;case 2:k=_.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;default:switch(S){case"svg":k=_.createElementNS("http://www.w3.org/2000/svg",S);break;case"math":k=_.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;case"script":k=_.createElement("div"),k.innerHTML="<script><\/script>",k=k.removeChild(k.firstChild);break;case"select":k=typeof y.is=="string"?_.createElement("select",{is:y.is}):_.createElement("select"),y.multiple?k.multiple=!0:y.size&&(k.size=y.size);break;default:k=typeof y.is=="string"?_.createElement(S,{is:y.is}):_.createElement(S)}}k[us]=h,k[cs]=y;e:for(_=h.child;_!==null;){if(_.tag===5||_.tag===6)k.appendChild(_.stateNode);else if(_.tag!==4&&_.tag!==27&&_.child!==null){_.child.return=_,_=_.child;continue}if(_===h)break e;for(;_.sibling===null;){if(_.return===null||_.return===h)break e;_=_.return}_.sibling.return=_.return,_=_.sibling}h.stateNode=k;e:switch(Os(k,S,y),S){case"button":case"input":case"select":case"textarea":y=!!y.autoFocus;break e;case"img":y=!0;break e;default:y=!1}y&&ja(h)}}return bn(h),pv(h,h.type,l===null?null:l.memoizedProps,h.pendingProps,f),null;case 6:if(l&&h.stateNode!=null)l.memoizedProps!==y&&ja(h);else{if(typeof y!="string"&&h.stateNode===null)throw Error(s(166));if(l=Ee.current,Nc(h)){if(l=h.stateNode,f=h.memoizedProps,y=null,S=As,S!==null)switch(S.tag){case 27:case 5:y=S.memoizedProps}l[us]=h,l=!!(l.nodeValue===f||y!==null&&y.suppressHydrationWarning===!0||O$(l.nodeValue,f)),l||Ao(h,!0)}else l=iy(l).createTextNode(y),l[us]=h,h.stateNode=l}return bn(h),null;case 31:if(f=h.memoizedState,l===null||l.memoizedState!==null){if(y=Nc(h),f!==null){if(l===null){if(!y)throw Error(s(318));if(l=h.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(557));l[us]=h}else ql(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;bn(h),l=!1}else f=C1(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=f),l=!0;if(!l)return h.flags&256?(Vr(h),h):(Vr(h),null);if((h.flags&128)!==0)throw Error(s(558))}return bn(h),null;case 13:if(y=h.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(S=Nc(h),y!==null&&y.dehydrated!==null){if(l===null){if(!S)throw Error(s(318));if(S=h.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(s(317));S[us]=h}else ql(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;bn(h),S=!1}else S=C1(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=S),S=!0;if(!S)return h.flags&256?(Vr(h),h):(Vr(h),null)}return Vr(h),(h.flags&128)!==0?(h.lanes=f,h):(f=y!==null,l=l!==null&&l.memoizedState!==null,f&&(y=h.child,S=null,y.alternate!==null&&y.alternate.memoizedState!==null&&y.alternate.memoizedState.cachePool!==null&&(S=y.alternate.memoizedState.cachePool.pool),k=null,y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(k=y.memoizedState.cachePool.pool),k!==S&&(y.flags|=2048)),f!==l&&f&&(h.child.flags|=8192),Gg(h,h.updateQueue),bn(h),null);case 4:return Be(),l===null&&Fv(h.stateNode.containerInfo),bn(h),null;case 10:return Ua(h.type),bn(h),null;case 19:if(re(Vn),y=h.memoizedState,y===null)return bn(h),null;if(S=(h.flags&128)!==0,k=y.rendering,k===null)if(S)Sp(y,!1);else{if(Fn!==0||l!==null&&(l.flags&128)!==0)for(l=h.child;l!==null;){if(k=Ag(l),k!==null){for(h.flags|=128,Sp(y,!1),l=k.updateQueue,h.updateQueue=l,Gg(h,l),h.subtreeFlags=0,l=f,f=h.child;f!==null;)dN(f,l),f=f.sibling;return pe(Vn,Vn.current&1|2),Lt&&Ba(h,y.treeForkCount),h.child}l=l.sibling}y.tail!==null&&Ut()>Kg&&(h.flags|=128,S=!0,Sp(y,!1),h.lanes=4194304)}else{if(!S)if(l=Ag(k),l!==null){if(h.flags|=128,S=!0,l=l.updateQueue,h.updateQueue=l,Gg(h,l),Sp(y,!0),y.tail===null&&y.tailMode==="hidden"&&!k.alternate&&!Lt)return bn(h),null}else 2*Ut()-y.renderingStartTime>Kg&&f!==536870912&&(h.flags|=128,S=!0,Sp(y,!1),h.lanes=4194304);y.isBackwards?(k.sibling=h.child,h.child=k):(l=y.last,l!==null?l.sibling=k:h.child=k,y.last=k)}return y.tail!==null?(l=y.tail,y.rendering=l,y.tail=l.sibling,y.renderingStartTime=Ut(),l.sibling=null,f=Vn.current,pe(Vn,S?f&1|2:f&1),Lt&&Ba(h,y.treeForkCount),l):(bn(h),null);case 22:case 23:return Vr(h),z1(),y=h.memoizedState!==null,l!==null?l.memoizedState!==null!==y&&(h.flags|=8192):y&&(h.flags|=8192),y?(f&536870912)!==0&&(h.flags&128)===0&&(bn(h),h.subtreeFlags&6&&(h.flags|=8192)):bn(h),f=h.updateQueue,f!==null&&Gg(h,f.retryQueue),f=null,l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),y=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(y=h.memoizedState.cachePool.pool),y!==f&&(h.flags|=2048),l!==null&&re(Yl),null;case 24:return f=null,l!==null&&(f=l.memoizedState.cache),h.memoizedState.cache!==f&&(h.flags|=2048),Ua(qn),bn(h),null;case 25:return null;case 30:return null}throw Error(s(156,h.tag))}function JL(l,h){switch(w1(h),h.tag){case 1:return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 3:return Ua(qn),Be(),l=h.flags,(l&65536)!==0&&(l&128)===0?(h.flags=l&-65537|128,h):null;case 26:case 27:case 5:return ot(h),null;case 31:if(h.memoizedState!==null){if(Vr(h),h.alternate===null)throw Error(s(340));ql()}return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 13:if(Vr(h),l=h.memoizedState,l!==null&&l.dehydrated!==null){if(h.alternate===null)throw Error(s(340));ql()}return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 19:return re(Vn),null;case 4:return Be(),null;case 10:return Ua(h.type),null;case 22:case 23:return Vr(h),z1(),l!==null&&re(Yl),l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 24:return Ua(qn),null;case 25:return null;default:return null}}function Pk(l,h){switch(w1(h),h.tag){case 3:Ua(qn),Be();break;case 26:case 27:case 5:ot(h);break;case 4:Be();break;case 31:h.memoizedState!==null&&Vr(h);break;case 13:Vr(h);break;case 19:re(Vn);break;case 10:Ua(h.type);break;case 22:case 23:Vr(h),z1(),l!==null&&re(Yl);break;case 24:Ua(qn)}}function Cp(l,h){try{var f=h.updateQueue,y=f!==null?f.lastEffect:null;if(y!==null){var S=y.next;f=S;do{if((f.tag&l)===l){y=void 0;var k=f.create,_=f.inst;y=k(),_.destroy=y}f=f.next}while(f!==S)}}catch(V){en(h,h.return,V)}}function Mo(l,h,f){try{var y=h.updateQueue,S=y!==null?y.lastEffect:null;if(S!==null){var k=S.next;y=k;do{if((y.tag&l)===l){var _=y.inst,V=_.destroy;if(V!==void 0){_.destroy=void 0,S=h;var ne=f,xe=V;try{xe()}catch(ke){en(S,ne,ke)}}}y=y.next}while(y!==k)}}catch(ke){en(h,h.return,ke)}}function Bk(l){var h=l.updateQueue;if(h!==null){var f=l.stateNode;try{RN(h,f)}catch(y){en(l,l.return,y)}}}function Vk(l,h,f){f.props=tu(l.type,l.memoizedProps),f.state=l.memoizedState;try{f.componentWillUnmount()}catch(y){en(l,h,y)}}function Np(l,h){try{var f=l.ref;if(f!==null){switch(l.tag){case 26:case 27:case 5:var y=l.stateNode;break;case 30:y=l.stateNode;break;default:y=l.stateNode}typeof f=="function"?l.refCleanup=f(y):f.current=y}}catch(S){en(l,h,S)}}function ca(l,h){var f=l.ref,y=l.refCleanup;if(f!==null)if(typeof y=="function")try{y()}catch(S){en(l,h,S)}finally{l.refCleanup=null,l=l.alternate,l!=null&&(l.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(S){en(l,h,S)}else f.current=null}function Uk(l){var h=l.type,f=l.memoizedProps,y=l.stateNode;try{e:switch(h){case"button":case"input":case"select":case"textarea":f.autoFocus&&y.focus();break e;case"img":f.src?y.src=f.src:f.srcSet&&(y.srcset=f.srcSet)}}catch(S){en(l,l.return,S)}}function fv(l,h,f){try{var y=l.stateNode;wM(y,l.type,f,h),y[cs]=h}catch(S){en(l,l.return,S)}}function Wk(l){return l.tag===5||l.tag===3||l.tag===26||l.tag===27&&Ho(l.type)||l.tag===4}function mv(l){e:for(;;){for(;l.sibling===null;){if(l.return===null||Wk(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.tag===27&&Ho(l.type)||l.flags&2||l.child===null||l.tag===4)continue e;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function gv(l,h,f){var y=l.tag;if(y===5||y===6)l=l.stateNode,h?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(l,h):(h=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,h.appendChild(l),f=f._reactRootContainer,f!=null||h.onclick!==null||(h.onclick=Oi));else if(y!==4&&(y===27&&Ho(l.type)&&(f=l.stateNode,h=null),l=l.child,l!==null))for(gv(l,h,f),l=l.sibling;l!==null;)gv(l,h,f),l=l.sibling}function Hg(l,h,f){var y=l.tag;if(y===5||y===6)l=l.stateNode,h?f.insertBefore(l,h):f.appendChild(l);else if(y!==4&&(y===27&&Ho(l.type)&&(f=l.stateNode),l=l.child,l!==null))for(Hg(l,h,f),l=l.sibling;l!==null;)Hg(l,h,f),l=l.sibling}function Gk(l){var h=l.stateNode,f=l.memoizedProps;try{for(var y=l.type,S=h.attributes;S.length;)h.removeAttributeNode(S[0]);Os(h,y,f),h[us]=l,h[cs]=f}catch(k){en(l,l.return,k)}}var qa=!1,Yn=!1,yv=!1,Hk=typeof WeakSet=="function"?WeakSet:Set,ws=null;function eM(l,h){if(l=l.containerInfo,Mv=dy,l=sN(l),c1(l)){if("selectionStart"in l)var f={start:l.selectionStart,end:l.selectionEnd};else e:{f=(f=l.ownerDocument)&&f.defaultView||window;var y=f.getSelection&&f.getSelection();if(y&&y.rangeCount!==0){f=y.anchorNode;var S=y.anchorOffset,k=y.focusNode;y=y.focusOffset;try{f.nodeType,k.nodeType}catch{f=null;break e}var _=0,V=-1,ne=-1,xe=0,ke=0,Te=l,be=null;t:for(;;){for(var Se;Te!==f||S!==0&&Te.nodeType!==3||(V=_+S),Te!==k||y!==0&&Te.nodeType!==3||(ne=_+y),Te.nodeType===3&&(_+=Te.nodeValue.length),(Se=Te.firstChild)!==null;)be=Te,Te=Se;for(;;){if(Te===l)break t;if(be===f&&++xe===S&&(V=_),be===k&&++ke===y&&(ne=_),(Se=Te.nextSibling)!==null)break;Te=be,be=Te.parentNode}Te=Se}f=V===-1||ne===-1?null:{start:V,end:ne}}else f=null}f=f||{start:0,end:0}}else f=null;for(Pv={focusedElem:l,selectionRange:f},dy=!1,ws=h;ws!==null;)if(h=ws,l=h.child,(h.subtreeFlags&1028)!==0&&l!==null)l.return=h,ws=l;else for(;ws!==null;){switch(h=ws,k=h.alternate,l=h.flags,h.tag){case 0:if((l&4)!==0&&(l=h.updateQueue,l=l!==null?l.events:null,l!==null))for(f=0;f<l.length;f++)S=l[f],S.ref.impl=S.nextImpl;break;case 11:case 15:break;case 1:if((l&1024)!==0&&k!==null){l=void 0,f=h,S=k.memoizedProps,k=k.memoizedState,y=f.stateNode;try{var qe=tu(f.type,S);l=y.getSnapshotBeforeUpdate(qe,k),y.__reactInternalSnapshotBeforeUpdate=l}catch(lt){en(f,f.return,lt)}}break;case 3:if((l&1024)!==0){if(l=h.stateNode.containerInfo,f=l.nodeType,f===9)Uv(l);else if(f===1)switch(l.nodeName){case"HEAD":case"HTML":case"BODY":Uv(l);break;default:l.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((l&1024)!==0)throw Error(s(163))}if(l=h.sibling,l!==null){l.return=h.return,ws=l;break}ws=h.return}}function jk(l,h,f){var y=f.flags;switch(f.tag){case 0:case 11:case 15:Ka(l,f),y&4&&Cp(5,f);break;case 1:if(Ka(l,f),y&4)if(l=f.stateNode,h===null)try{l.componentDidMount()}catch(_){en(f,f.return,_)}else{var S=tu(f.type,h.memoizedProps);h=h.memoizedState;try{l.componentDidUpdate(S,h,l.__reactInternalSnapshotBeforeUpdate)}catch(_){en(f,f.return,_)}}y&64&&Bk(f),y&512&&Np(f,f.return);break;case 3:if(Ka(l,f),y&64&&(l=f.updateQueue,l!==null)){if(h=null,f.child!==null)switch(f.child.tag){case 27:case 5:h=f.child.stateNode;break;case 1:h=f.child.stateNode}try{RN(l,h)}catch(_){en(f,f.return,_)}}break;case 27:h===null&&y&4&&Gk(f);case 26:case 5:Ka(l,f),h===null&&y&4&&Uk(f),y&512&&Np(f,f.return);break;case 12:Ka(l,f);break;case 31:Ka(l,f),y&4&&Kk(l,f);break;case 13:Ka(l,f),y&4&&Yk(l,f),y&64&&(l=f.memoizedState,l!==null&&(l=l.dehydrated,l!==null&&(f=uM.bind(null,f),EM(l,f))));break;case 22:if(y=f.memoizedState!==null||qa,!y){h=h!==null&&h.memoizedState!==null||Yn,S=qa;var k=Yn;qa=y,(Yn=h)&&!k?Ya(l,f,(f.subtreeFlags&8772)!==0):Ka(l,f),qa=S,Yn=k}break;case 30:break;default:Ka(l,f)}}function qk(l){var h=l.alternate;h!==null&&(l.alternate=null,qk(h)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(h=l.stateNode,h!==null&&rc(h)),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}var Cn=null,yr=!1;function Xa(l,h,f){for(f=f.child;f!==null;)Xk(l,h,f),f=f.sibling}function Xk(l,h,f){if(ls&&typeof ls.onCommitFiberUnmount=="function")try{ls.onCommitFiberUnmount(Vs,f)}catch{}switch(f.tag){case 26:Yn||ca(f,h),Xa(l,h,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:Yn||ca(f,h);var y=Cn,S=yr;Ho(f.type)&&(Cn=f.stateNode,yr=!1),Xa(l,h,f),_p(f.stateNode),Cn=y,yr=S;break;case 5:Yn||ca(f,h);case 6:if(y=Cn,S=yr,Cn=null,Xa(l,h,f),Cn=y,yr=S,Cn!==null)if(yr)try{(Cn.nodeType===9?Cn.body:Cn.nodeName==="HTML"?Cn.ownerDocument.body:Cn).removeChild(f.stateNode)}catch(k){en(f,h,k)}else try{Cn.removeChild(f.stateNode)}catch(k){en(f,h,k)}break;case 18:Cn!==null&&(yr?(l=Cn,B$(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,f.stateNode),Hc(l)):B$(Cn,f.stateNode));break;case 4:y=Cn,S=yr,Cn=f.stateNode.containerInfo,yr=!0,Xa(l,h,f),Cn=y,yr=S;break;case 0:case 11:case 14:case 15:Mo(2,f,h),Yn||Mo(4,f,h),Xa(l,h,f);break;case 1:Yn||(ca(f,h),y=f.stateNode,typeof y.componentWillUnmount=="function"&&Vk(f,h,y)),Xa(l,h,f);break;case 21:Xa(l,h,f);break;case 22:Yn=(y=Yn)||f.memoizedState!==null,Xa(l,h,f),Yn=y;break;default:Xa(l,h,f)}}function Kk(l,h){if(h.memoizedState===null&&(l=h.alternate,l!==null&&(l=l.memoizedState,l!==null))){l=l.dehydrated;try{Hc(l)}catch(f){en(h,h.return,f)}}}function Yk(l,h){if(h.memoizedState===null&&(l=h.alternate,l!==null&&(l=l.memoizedState,l!==null&&(l=l.dehydrated,l!==null))))try{Hc(l)}catch(f){en(h,h.return,f)}}function tM(l){switch(l.tag){case 31:case 13:case 19:var h=l.stateNode;return h===null&&(h=l.stateNode=new Hk),h;case 22:return l=l.stateNode,h=l._retryCache,h===null&&(h=l._retryCache=new Hk),h;default:throw Error(s(435,l.tag))}}function jg(l,h){var f=tM(l);h.forEach(function(y){if(!f.has(y)){f.add(y);var S=cM.bind(null,l,y);y.then(S,S)}})}function xr(l,h){var f=h.deletions;if(f!==null)for(var y=0;y<f.length;y++){var S=f[y],k=l,_=h,V=_;e:for(;V!==null;){switch(V.tag){case 27:if(Ho(V.type)){Cn=V.stateNode,yr=!1;break e}break;case 5:Cn=V.stateNode,yr=!1;break e;case 3:case 4:Cn=V.stateNode.containerInfo,yr=!0;break e}V=V.return}if(Cn===null)throw Error(s(160));Xk(k,_,S),Cn=null,yr=!1,k=S.alternate,k!==null&&(k.return=null),S.return=null}if(h.subtreeFlags&13886)for(h=h.child;h!==null;)Qk(h,l),h=h.sibling}var Li=null;function Qk(l,h){var f=l.alternate,y=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:xr(h,l),br(l),y&4&&(Mo(3,l,l.return),Cp(3,l),Mo(5,l,l.return));break;case 1:xr(h,l),br(l),y&512&&(Yn||f===null||ca(f,f.return)),y&64&&qa&&(l=l.updateQueue,l!==null&&(y=l.callbacks,y!==null&&(f=l.shared.hiddenCallbacks,l.shared.hiddenCallbacks=f===null?y:f.concat(y))));break;case 26:var S=Li;if(xr(h,l),br(l),y&512&&(Yn||f===null||ca(f,f.return)),y&4){var k=f!==null?f.memoizedState:null;if(y=l.memoizedState,f===null)if(y===null)if(l.stateNode===null){e:{y=l.type,f=l.memoizedProps,S=S.ownerDocument||S;t:switch(y){case"title":k=S.getElementsByTagName("title")[0],(!k||k[Da]||k[us]||k.namespaceURI==="http://www.w3.org/2000/svg"||k.hasAttribute("itemprop"))&&(k=S.createElement(y),S.head.insertBefore(k,S.querySelector("head > title"))),Os(k,y,f),k[us]=l,_n(k),y=k;break e;case"link":var _=Q$("link","href",S).get(y+(f.href||""));if(_){for(var V=0;V<_.length;V++)if(k=_[V],k.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&k.getAttribute("rel")===(f.rel==null?null:f.rel)&&k.getAttribute("title")===(f.title==null?null:f.title)&&k.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){_.splice(V,1);break t}}k=S.createElement(y),Os(k,y,f),S.head.appendChild(k);break;case"meta":if(_=Q$("meta","content",S).get(y+(f.content||""))){for(V=0;V<_.length;V++)if(k=_[V],k.getAttribute("content")===(f.content==null?null:""+f.content)&&k.getAttribute("name")===(f.name==null?null:f.name)&&k.getAttribute("property")===(f.property==null?null:f.property)&&k.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&k.getAttribute("charset")===(f.charSet==null?null:f.charSet)){_.splice(V,1);break t}}k=S.createElement(y),Os(k,y,f),S.head.appendChild(k);break;default:throw Error(s(468,y))}k[us]=l,_n(k),y=k}l.stateNode=y}else Z$(S,l.type,l.stateNode);else l.stateNode=Y$(S,y,l.memoizedProps);else k!==y?(k===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):k.count--,y===null?Z$(S,l.type,l.stateNode):Y$(S,y,l.memoizedProps)):y===null&&l.stateNode!==null&&fv(l,l.memoizedProps,f.memoizedProps)}break;case 27:xr(h,l),br(l),y&512&&(Yn||f===null||ca(f,f.return)),f!==null&&y&4&&fv(l,l.memoizedProps,f.memoizedProps);break;case 5:if(xr(h,l),br(l),y&512&&(Yn||f===null||ca(f,f.return)),l.flags&32){S=l.stateNode;try{Oa(S,"")}catch(qe){en(l,l.return,qe)}}y&4&&l.stateNode!=null&&(S=l.memoizedProps,fv(l,S,f!==null?f.memoizedProps:S)),y&1024&&(yv=!0);break;case 6:if(xr(h,l),br(l),y&4){if(l.stateNode===null)throw Error(s(162));y=l.memoizedProps,f=l.stateNode;try{f.nodeValue=y}catch(qe){en(l,l.return,qe)}}break;case 3:if(ly=null,S=Li,Li=ay(h.containerInfo),xr(h,l),Li=S,br(l),y&4&&f!==null&&f.memoizedState.isDehydrated)try{Hc(h.containerInfo)}catch(qe){en(l,l.return,qe)}yv&&(yv=!1,Zk(l));break;case 4:y=Li,Li=ay(l.stateNode.containerInfo),xr(h,l),br(l),Li=y;break;case 12:xr(h,l),br(l);break;case 31:xr(h,l),br(l),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,jg(l,y)));break;case 13:xr(h,l),br(l),l.child.flags&8192&&l.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(Xg=Ut()),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,jg(l,y)));break;case 22:S=l.memoizedState!==null;var ne=f!==null&&f.memoizedState!==null,xe=qa,ke=Yn;if(qa=xe||S,Yn=ke||ne,xr(h,l),Yn=ke,qa=xe,br(l),y&8192)e:for(h=l.stateNode,h._visibility=S?h._visibility&-2:h._visibility|1,S&&(f===null||ne||qa||Yn||nu(l)),f=null,h=l;;){if(h.tag===5||h.tag===26){if(f===null){ne=f=h;try{if(k=ne.stateNode,S)_=k.style,typeof _.setProperty=="function"?_.setProperty("display","none","important"):_.display="none";else{V=ne.stateNode;var Te=ne.memoizedProps.style,be=Te!=null&&Te.hasOwnProperty("display")?Te.display:null;V.style.display=be==null||typeof be=="boolean"?"":(""+be).trim()}}catch(qe){en(ne,ne.return,qe)}}}else if(h.tag===6){if(f===null){ne=h;try{ne.stateNode.nodeValue=S?"":ne.memoizedProps}catch(qe){en(ne,ne.return,qe)}}}else if(h.tag===18){if(f===null){ne=h;try{var Se=ne.stateNode;S?V$(Se,!0):V$(ne.stateNode,!1)}catch(qe){en(ne,ne.return,qe)}}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===l)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===l)break e;for(;h.sibling===null;){if(h.return===null||h.return===l)break e;f===h&&(f=null),h=h.return}f===h&&(f=null),h.sibling.return=h.return,h=h.sibling}y&4&&(y=l.updateQueue,y!==null&&(f=y.retryQueue,f!==null&&(y.retryQueue=null,jg(l,f))));break;case 19:xr(h,l),br(l),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,jg(l,y)));break;case 30:break;case 21:break;default:xr(h,l),br(l)}}function br(l){var h=l.flags;if(h&2){try{for(var f,y=l.return;y!==null;){if(Wk(y)){f=y;break}y=y.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var S=f.stateNode,k=mv(l);Hg(l,k,S);break;case 5:var _=f.stateNode;f.flags&32&&(Oa(_,""),f.flags&=-33);var V=mv(l);Hg(l,V,_);break;case 3:case 4:var ne=f.stateNode.containerInfo,xe=mv(l);gv(l,xe,ne);break;default:throw Error(s(161))}}catch(ke){en(l,l.return,ke)}l.flags&=-3}h&4096&&(l.flags&=-4097)}function Zk(l){if(l.subtreeFlags&1024)for(l=l.child;l!==null;){var h=l;Zk(h),h.tag===5&&h.flags&1024&&h.stateNode.reset(),l=l.sibling}}function Ka(l,h){if(h.subtreeFlags&8772)for(h=h.child;h!==null;)jk(l,h.alternate,h),h=h.sibling}function nu(l){for(l=l.child;l!==null;){var h=l;switch(h.tag){case 0:case 11:case 14:case 15:Mo(4,h,h.return),nu(h);break;case 1:ca(h,h.return);var f=h.stateNode;typeof f.componentWillUnmount=="function"&&Vk(h,h.return,f),nu(h);break;case 27:_p(h.stateNode);case 26:case 5:ca(h,h.return),nu(h);break;case 22:h.memoizedState===null&&nu(h);break;case 30:nu(h);break;default:nu(h)}l=l.sibling}}function Ya(l,h,f){for(f=f&&(h.subtreeFlags&8772)!==0,h=h.child;h!==null;){var y=h.alternate,S=l,k=h,_=k.flags;switch(k.tag){case 0:case 11:case 15:Ya(S,k,f),Cp(4,k);break;case 1:if(Ya(S,k,f),y=k,S=y.stateNode,typeof S.componentDidMount=="function")try{S.componentDidMount()}catch(xe){en(y,y.return,xe)}if(y=k,S=y.updateQueue,S!==null){var V=y.stateNode;try{var ne=S.shared.hiddenCallbacks;if(ne!==null)for(S.shared.hiddenCallbacks=null,S=0;S<ne.length;S++)EN(ne[S],V)}catch(xe){en(y,y.return,xe)}}f&&_&64&&Bk(k),Np(k,k.return);break;case 27:Gk(k);case 26:case 5:Ya(S,k,f),f&&y===null&&_&4&&Uk(k),Np(k,k.return);break;case 12:Ya(S,k,f);break;case 31:Ya(S,k,f),f&&_&4&&Kk(S,k);break;case 13:Ya(S,k,f),f&&_&4&&Yk(S,k);break;case 22:k.memoizedState===null&&Ya(S,k,f),Np(k,k.return);break;case 30:break;default:Ya(S,k,f)}h=h.sibling}}function xv(l,h){var f=null;l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),l=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(l=h.memoizedState.cachePool.pool),l!==f&&(l!=null&&l.refCount++,f!=null&&cp(f))}function bv(l,h){l=null,h.alternate!==null&&(l=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==l&&(h.refCount++,l!=null&&cp(l))}function Mi(l,h,f,y){if(h.subtreeFlags&10256)for(h=h.child;h!==null;)Jk(l,h,f,y),h=h.sibling}function Jk(l,h,f,y){var S=h.flags;switch(h.tag){case 0:case 11:case 15:Mi(l,h,f,y),S&2048&&Cp(9,h);break;case 1:Mi(l,h,f,y);break;case 3:Mi(l,h,f,y),S&2048&&(l=null,h.alternate!==null&&(l=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==l&&(h.refCount++,l!=null&&cp(l)));break;case 12:if(S&2048){Mi(l,h,f,y),l=h.stateNode;try{var k=h.memoizedProps,_=k.id,V=k.onPostCommit;typeof V=="function"&&V(_,h.alternate===null?"mount":"update",l.passiveEffectDuration,-0)}catch(ne){en(h,h.return,ne)}}else Mi(l,h,f,y);break;case 31:Mi(l,h,f,y);break;case 13:Mi(l,h,f,y);break;case 23:break;case 22:k=h.stateNode,_=h.alternate,h.memoizedState!==null?k._visibility&2?Mi(l,h,f,y):kp(l,h):k._visibility&2?Mi(l,h,f,y):(k._visibility|=2,Oc(l,h,f,y,(h.subtreeFlags&10256)!==0||!1)),S&2048&&xv(_,h);break;case 24:Mi(l,h,f,y),S&2048&&bv(h.alternate,h);break;default:Mi(l,h,f,y)}}function Oc(l,h,f,y,S){for(S=S&&((h.subtreeFlags&10256)!==0||!1),h=h.child;h!==null;){var k=l,_=h,V=f,ne=y,xe=_.flags;switch(_.tag){case 0:case 11:case 15:Oc(k,_,V,ne,S),Cp(8,_);break;case 23:break;case 22:var ke=_.stateNode;_.memoizedState!==null?ke._visibility&2?Oc(k,_,V,ne,S):kp(k,_):(ke._visibility|=2,Oc(k,_,V,ne,S)),S&&xe&2048&&xv(_.alternate,_);break;case 24:Oc(k,_,V,ne,S),S&&xe&2048&&bv(_.alternate,_);break;default:Oc(k,_,V,ne,S)}h=h.sibling}}function kp(l,h){if(h.subtreeFlags&10256)for(h=h.child;h!==null;){var f=l,y=h,S=y.flags;switch(y.tag){case 22:kp(f,y),S&2048&&xv(y.alternate,y);break;case 24:kp(f,y),S&2048&&bv(y.alternate,y);break;default:kp(f,y)}h=h.sibling}}var $p=8192;function Fc(l,h,f){if(l.subtreeFlags&$p)for(l=l.child;l!==null;)e$(l,h,f),l=l.sibling}function e$(l,h,f){switch(l.tag){case 26:Fc(l,h,f),l.flags&$p&&l.memoizedState!==null&&VM(f,Li,l.memoizedState,l.memoizedProps);break;case 5:Fc(l,h,f);break;case 3:case 4:var y=Li;Li=ay(l.stateNode.containerInfo),Fc(l,h,f),Li=y;break;case 22:l.memoizedState===null&&(y=l.alternate,y!==null&&y.memoizedState!==null?(y=$p,$p=16777216,Fc(l,h,f),$p=y):Fc(l,h,f));break;default:Fc(l,h,f)}}function t$(l){var h=l.alternate;if(h!==null&&(l=h.child,l!==null)){h.child=null;do h=l.sibling,l.sibling=null,l=h;while(l!==null)}}function Ip(l){var h=l.deletions;if((l.flags&16)!==0){if(h!==null)for(var f=0;f<h.length;f++){var y=h[f];ws=y,s$(y,l)}t$(l)}if(l.subtreeFlags&10256)for(l=l.child;l!==null;)n$(l),l=l.sibling}function n$(l){switch(l.tag){case 0:case 11:case 15:Ip(l),l.flags&2048&&Mo(9,l,l.return);break;case 3:Ip(l);break;case 12:Ip(l);break;case 22:var h=l.stateNode;l.memoizedState!==null&&h._visibility&2&&(l.return===null||l.return.tag!==13)?(h._visibility&=-3,qg(l)):Ip(l);break;default:Ip(l)}}function qg(l){var h=l.deletions;if((l.flags&16)!==0){if(h!==null)for(var f=0;f<h.length;f++){var y=h[f];ws=y,s$(y,l)}t$(l)}for(l=l.child;l!==null;){switch(h=l,h.tag){case 0:case 11:case 15:Mo(8,h,h.return),qg(h);break;case 22:f=h.stateNode,f._visibility&2&&(f._visibility&=-3,qg(h));break;default:qg(h)}l=l.sibling}}function s$(l,h){for(;ws!==null;){var f=ws;switch(f.tag){case 0:case 11:case 15:Mo(8,f,h);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var y=f.memoizedState.cachePool.pool;y!=null&&y.refCount++}break;case 24:cp(f.memoizedState.cache)}if(y=f.child,y!==null)y.return=f,ws=y;else e:for(f=l;ws!==null;){y=ws;var S=y.sibling,k=y.return;if(qk(y),y===f){ws=null;break e}if(S!==null){S.return=k,ws=S;break e}ws=k}}}var nM={getCacheForType:function(l){var h=Ds(qn),f=h.data.get(l);return f===void 0&&(f=l(),h.data.set(l,f)),f},cacheSignal:function(){return Ds(qn).controller.signal}},sM=typeof WeakMap=="function"?WeakMap:Map,Xt=0,hn=null,$t=null,Et=0,Jt=0,Ur=null,Po=!1,zc=!1,vv=!1,Qa=0,Fn=0,Bo=0,su=0,wv=0,Wr=0,Lc=0,Tp=null,vr=null,Sv=!1,Xg=0,r$=0,Kg=1/0,Yg=null,Vo=null,ps=0,Uo=null,Mc=null,Za=0,Cv=0,Nv=null,i$=null,Ep=0,kv=null;function Gr(){return(Xt&2)!==0&&Et!==0?Et&-Et:W.T!==null?Av():Sn()}function a$(){if(Wr===0)if((Et&536870912)===0||Lt){var l=Al;Al<<=1,(Al&3932160)===0&&(Al=262144),Wr=l}else Wr=536870912;return l=Br.current,l!==null&&(l.flags|=32),Wr}function wr(l,h,f){(l===hn&&(Jt===2||Jt===9)||l.cancelPendingCommit!==null)&&(Pc(l,0),Wo(l,Et,Wr,!1)),ra(l,f),((Xt&2)===0||l!==hn)&&(l===hn&&((Xt&2)===0&&(su|=f),Fn===4&&Wo(l,Et,Wr,!1)),ha(l))}function o$(l,h,f){if((Xt&6)!==0)throw Error(s(327));var y=!f&&(h&127)===0&&(h&l.expiredLanes)===0||Fr(l,h),S=y?aM(l,h):Iv(l,h,!0),k=y;do{if(S===0){zc&&!y&&Wo(l,h,0,!1);break}else{if(f=l.current.alternate,k&&!rM(f)){S=Iv(l,h,!1),k=!1;continue}if(S===2){if(k=h,l.errorRecoveryDisabledLanes&k)var _=0;else _=l.pendingLanes&-536870913,_=_!==0?_:_&536870912?536870912:0;if(_!==0){h=_;e:{var V=l;S=Tp;var ne=V.current.memoizedState.isDehydrated;if(ne&&(Pc(V,_).flags|=256),_=Iv(V,_,!1),_!==2){if(vv&&!ne){V.errorRecoveryDisabledLanes|=k,su|=k,S=4;break e}k=vr,vr=S,k!==null&&(vr===null?vr=k:vr.push.apply(vr,k))}S=_}if(k=!1,S!==2)continue}}if(S===1){Pc(l,0),Wo(l,h,0,!0);break}e:{switch(y=l,k=S,k){case 0:case 1:throw Error(s(345));case 4:if((h&4194048)!==h)break;case 6:Wo(y,h,Wr,!Po);break e;case 2:vr=null;break;case 3:case 5:break;default:throw Error(s(329))}if((h&62914560)===h&&(S=Xg+300-Ut(),10<S)){if(Wo(y,h,Wr,!Po),_l(y,0,!0)!==0)break e;Za=h,y.timeoutHandle=M$(l$.bind(null,y,f,vr,Yg,Sv,h,Wr,su,Lc,Po,k,"Throttled",-0,0),S);break e}l$(y,f,vr,Yg,Sv,h,Wr,su,Lc,Po,k,null,-0,0)}}break}while(!0);ha(l)}function l$(l,h,f,y,S,k,_,V,ne,xe,ke,Te,be,Se){if(l.timeoutHandle=-1,Te=h.subtreeFlags,Te&8192||(Te&16785408)===16785408){Te={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Oi},e$(h,k,Te);var qe=(k&62914560)===k?Xg-Ut():(k&4194048)===k?r$-Ut():0;if(qe=UM(Te,qe),qe!==null){Za=k,l.cancelPendingCommit=qe(g$.bind(null,l,h,k,f,y,S,_,V,ne,ke,Te,null,be,Se)),Wo(l,k,_,!xe);return}}g$(l,h,k,f,y,S,_,V,ne)}function rM(l){for(var h=l;;){var f=h.tag;if((f===0||f===11||f===15)&&h.flags&16384&&(f=h.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var y=0;y<f.length;y++){var S=f[y],k=S.getSnapshot;S=S.value;try{if(!Mr(k(),S))return!1}catch{return!1}}if(f=h.child,h.subtreeFlags&16384&&f!==null)f.return=h,h=f;else{if(h===l)break;for(;h.sibling===null;){if(h.return===null||h.return===l)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Wo(l,h,f,y){h&=~wv,h&=~su,l.suspendedLanes|=h,l.pingedLanes&=~h,y&&(l.warmLanes|=h),y=l.expirationTimes;for(var S=h;0<S;){var k=31-nr(S),_=1<<k;y[k]=-1,S&=~_}f!==0&&Aa(l,f,h)}function Qg(){return(Xt&6)===0?(Rp(0),!1):!0}function $v(){if($t!==null){if(Jt===0)var l=$t.return;else l=$t,Va=Xl=null,U1(l),Ec=null,dp=0,l=$t;for(;l!==null;)Pk(l.alternate,l),l=l.return;$t=null}}function Pc(l,h){var f=l.timeoutHandle;f!==-1&&(l.timeoutHandle=-1,NM(f)),f=l.cancelPendingCommit,f!==null&&(l.cancelPendingCommit=null,f()),Za=0,$v(),hn=l,$t=f=Pa(l.current,null),Et=h,Jt=0,Ur=null,Po=!1,zc=Fr(l,h),vv=!1,Lc=Wr=wv=su=Bo=Fn=0,vr=Tp=null,Sv=!1,(h&8)!==0&&(h|=h&32);var y=l.entangledLanes;if(y!==0)for(l=l.entanglements,y&=h;0<y;){var S=31-nr(y),k=1<<S;h|=l[S],y&=~k}return Qa=h,xg(),f}function u$(l,h){vt=null,W.H=vp,h===Tc||h===$g?(h=kN(),Jt=3):h===R1?(h=kN(),Jt=4):Jt=h===rv?8:h!==null&&typeof h=="object"&&typeof h.then=="function"?6:1,Ur=h,$t===null&&(Fn=1,Bg(l,ai(h,l.current)))}function c$(){var l=Br.current;return l===null?!0:(Et&4194048)===Et?ci===null:(Et&62914560)===Et||(Et&536870912)!==0?l===ci:!1}function h$(){var l=W.H;return W.H=vp,l===null?vp:l}function d$(){var l=W.A;return W.A=nM,l}function Zg(){Fn=4,Po||(Et&4194048)!==Et&&Br.current!==null||(zc=!0),(Bo&134217727)===0&&(su&134217727)===0||hn===null||Wo(hn,Et,Wr,!1)}function Iv(l,h,f){var y=Xt;Xt|=2;var S=h$(),k=d$();(hn!==l||Et!==h)&&(Yg=null,Pc(l,h)),h=!1;var _=Fn;e:do try{if(Jt!==0&&$t!==null){var V=$t,ne=Ur;switch(Jt){case 8:$v(),_=6;break e;case 3:case 2:case 9:case 6:Br.current===null&&(h=!0);var xe=Jt;if(Jt=0,Ur=null,Bc(l,V,ne,xe),f&&zc){_=0;break e}break;default:xe=Jt,Jt=0,Ur=null,Bc(l,V,ne,xe)}}iM(),_=Fn;break}catch(ke){u$(l,ke)}while(!0);return h&&l.shellSuspendCounter++,Va=Xl=null,Xt=y,W.H=S,W.A=k,$t===null&&(hn=null,Et=0,xg()),_}function iM(){for(;$t!==null;)p$($t)}function aM(l,h){var f=Xt;Xt|=2;var y=h$(),S=d$();hn!==l||Et!==h?(Yg=null,Kg=Ut()+500,Pc(l,h)):zc=Fr(l,h);e:do try{if(Jt!==0&&$t!==null){h=$t;var k=Ur;t:switch(Jt){case 1:Jt=0,Ur=null,Bc(l,h,k,1);break;case 2:case 9:if(CN(k)){Jt=0,Ur=null,f$(h);break}h=function(){Jt!==2&&Jt!==9||hn!==l||(Jt=7),ha(l)},k.then(h,h);break e;case 3:Jt=7;break e;case 4:Jt=5;break e;case 7:CN(k)?(Jt=0,Ur=null,f$(h)):(Jt=0,Ur=null,Bc(l,h,k,7));break;case 5:var _=null;switch($t.tag){case 26:_=$t.memoizedState;case 5:case 27:var V=$t;if(_?J$(_):V.stateNode.complete){Jt=0,Ur=null;var ne=V.sibling;if(ne!==null)$t=ne;else{var xe=V.return;xe!==null?($t=xe,Jg(xe)):$t=null}break t}}Jt=0,Ur=null,Bc(l,h,k,5);break;case 6:Jt=0,Ur=null,Bc(l,h,k,6);break;case 8:$v(),Fn=6;break e;default:throw Error(s(462))}}oM();break}catch(ke){u$(l,ke)}while(!0);return Va=Xl=null,W.H=y,W.A=S,Xt=f,$t!==null?0:(hn=null,Et=0,xg(),Fn)}function oM(){for(;$t!==null&&!os();)p$($t)}function p$(l){var h=Lk(l.alternate,l,Qa);l.memoizedProps=l.pendingProps,h===null?Jg(l):$t=h}function f$(l){var h=l,f=h.alternate;switch(h.tag){case 15:case 0:h=Ak(f,h,h.pendingProps,h.type,void 0,Et);break;case 11:h=Ak(f,h,h.pendingProps,h.type.render,h.ref,Et);break;case 5:U1(h);default:Pk(f,h),h=$t=dN(h,Qa),h=Lk(f,h,Qa)}l.memoizedProps=l.pendingProps,h===null?Jg(l):$t=h}function Bc(l,h,f,y){Va=Xl=null,U1(h),Ec=null,dp=0;var S=h.return;try{if(KL(l,S,h,f,Et)){Fn=1,Bg(l,ai(f,l.current)),$t=null;return}}catch(k){if(S!==null)throw $t=S,k;Fn=1,Bg(l,ai(f,l.current)),$t=null;return}h.flags&32768?(Lt||y===1?l=!0:zc||(Et&536870912)!==0?l=!1:(Po=l=!0,(y===2||y===9||y===3||y===6)&&(y=Br.current,y!==null&&y.tag===13&&(y.flags|=16384))),m$(h,l)):Jg(h)}function Jg(l){var h=l;do{if((h.flags&32768)!==0){m$(h,Po);return}l=h.return;var f=ZL(h.alternate,h,Qa);if(f!==null){$t=f;return}if(h=h.sibling,h!==null){$t=h;return}$t=h=l}while(h!==null);Fn===0&&(Fn=5)}function m$(l,h){do{var f=JL(l.alternate,l);if(f!==null){f.flags&=32767,$t=f;return}if(f=l.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!h&&(l=l.sibling,l!==null)){$t=l;return}$t=l=f}while(l!==null);Fn=6,$t=null}function g$(l,h,f,y,S,k,_,V,ne){l.cancelPendingCommit=null;do ey();while(ps!==0);if((Xt&6)!==0)throw Error(s(327));if(h!==null){if(h===l.current)throw Error(s(177));if(k=h.lanes|h.childLanes,k|=m1,Xb(l,f,k,_,V,ne),l===hn&&($t=hn=null,Et=0),Mc=h,Uo=l,Za=f,Cv=k,Nv=S,i$=y,(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?(l.callbackNode=null,l.callbackPriority=0,hM(tr,function(){return w$(),null})):(l.callbackNode=null,l.callbackPriority=0),y=(h.flags&13878)!==0,(h.subtreeFlags&13878)!==0||y){y=W.T,W.T=null,S=ee.p,ee.p=2,_=Xt,Xt|=4;try{eM(l,h,f)}finally{Xt=_,ee.p=S,W.T=y}}ps=1,y$(),x$(),b$()}}function y$(){if(ps===1){ps=0;var l=Uo,h=Mc,f=(h.flags&13878)!==0;if((h.subtreeFlags&13878)!==0||f){f=W.T,W.T=null;var y=ee.p;ee.p=2;var S=Xt;Xt|=4;try{Qk(h,l);var k=Pv,_=sN(l.containerInfo),V=k.focusedElem,ne=k.selectionRange;if(_!==V&&V&&V.ownerDocument&&nN(V.ownerDocument.documentElement,V)){if(ne!==null&&c1(V)){var xe=ne.start,ke=ne.end;if(ke===void 0&&(ke=xe),"selectionStart"in V)V.selectionStart=xe,V.selectionEnd=Math.min(ke,V.value.length);else{var Te=V.ownerDocument||document,be=Te&&Te.defaultView||window;if(be.getSelection){var Se=be.getSelection(),qe=V.textContent.length,lt=Math.min(ne.start,qe),ln=ne.end===void 0?lt:Math.min(ne.end,qe);!Se.extend&&lt>ln&&(_=ln,ln=lt,lt=_);var me=tN(V,lt),le=tN(V,ln);if(me&&le&&(Se.rangeCount!==1||Se.anchorNode!==me.node||Se.anchorOffset!==me.offset||Se.focusNode!==le.node||Se.focusOffset!==le.offset)){var ye=Te.createRange();ye.setStart(me.node,me.offset),Se.removeAllRanges(),lt>ln?(Se.addRange(ye),Se.extend(le.node,le.offset)):(ye.setEnd(le.node,le.offset),Se.addRange(ye))}}}}for(Te=[],Se=V;Se=Se.parentNode;)Se.nodeType===1&&Te.push({element:Se,left:Se.scrollLeft,top:Se.scrollTop});for(typeof V.focus=="function"&&V.focus(),V=0;V<Te.length;V++){var Ie=Te[V];Ie.element.scrollLeft=Ie.left,Ie.element.scrollTop=Ie.top}}dy=!!Mv,Pv=Mv=null}finally{Xt=S,ee.p=y,W.T=f}}l.current=h,ps=2}}function x$(){if(ps===2){ps=0;var l=Uo,h=Mc,f=(h.flags&8772)!==0;if((h.subtreeFlags&8772)!==0||f){f=W.T,W.T=null;var y=ee.p;ee.p=2;var S=Xt;Xt|=4;try{jk(l,h.alternate,h)}finally{Xt=S,ee.p=y,W.T=f}}ps=3}}function b$(){if(ps===4||ps===3){ps=0,ei();var l=Uo,h=Mc,f=Za,y=i$;(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?ps=5:(ps=0,Mc=Uo=null,v$(l,l.pendingLanes));var S=l.pendingLanes;if(S===0&&(Vo=null),nc(f),h=h.stateNode,ls&&typeof ls.onCommitFiberRoot=="function")try{ls.onCommitFiberRoot(Vs,h,void 0,(h.current.flags&128)===128)}catch{}if(y!==null){h=W.T,S=ee.p,ee.p=2,W.T=null;try{for(var k=l.onRecoverableError,_=0;_<y.length;_++){var V=y[_];k(V.value,{componentStack:V.stack})}}finally{W.T=h,ee.p=S}}(Za&3)!==0&&ey(),ha(l),S=l.pendingLanes,(f&261930)!==0&&(S&42)!==0?l===kv?Ep++:(Ep=0,kv=l):Ep=0,Rp(0)}}function v$(l,h){(l.pooledCacheLanes&=h)===0&&(h=l.pooledCache,h!=null&&(l.pooledCache=null,cp(h)))}function ey(){return y$(),x$(),b$(),w$()}function w$(){if(ps!==5)return!1;var l=Uo,h=Cv;Cv=0;var f=nc(Za),y=W.T,S=ee.p;try{ee.p=32>f?32:f,W.T=null,f=Nv,Nv=null;var k=Uo,_=Za;if(ps=0,Mc=Uo=null,Za=0,(Xt&6)!==0)throw Error(s(331));var V=Xt;if(Xt|=4,n$(k.current),Jk(k,k.current,_,f),Xt=V,Rp(0,!1),ls&&typeof ls.onPostCommitFiberRoot=="function")try{ls.onPostCommitFiberRoot(Vs,k)}catch{}return!0}finally{ee.p=S,W.T=y,v$(l,h)}}function S$(l,h,f){h=ai(f,h),h=sv(l.stateNode,h,2),l=Fo(l,h,2),l!==null&&(ra(l,2),ha(l))}function en(l,h,f){if(l.tag===3)S$(l,l,f);else for(;h!==null;){if(h.tag===3){S$(h,l,f);break}else if(h.tag===1){var y=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof y.componentDidCatch=="function"&&(Vo===null||!Vo.has(y))){l=ai(f,l),f=Ck(2),y=Fo(h,f,2),y!==null&&(Nk(f,y,h,l),ra(y,2),ha(y));break}}h=h.return}}function Tv(l,h,f){var y=l.pingCache;if(y===null){y=l.pingCache=new sM;var S=new Set;y.set(h,S)}else S=y.get(h),S===void 0&&(S=new Set,y.set(h,S));S.has(f)||(vv=!0,S.add(f),l=lM.bind(null,l,h,f),h.then(l,l))}function lM(l,h,f){var y=l.pingCache;y!==null&&y.delete(h),l.pingedLanes|=l.suspendedLanes&f,l.warmLanes&=~f,hn===l&&(Et&f)===f&&(Fn===4||Fn===3&&(Et&62914560)===Et&&300>Ut()-Xg?(Xt&2)===0&&Pc(l,0):wv|=f,Lc===Et&&(Lc=0)),ha(l)}function C$(l,h){h===0&&(h=Wd()),l=Hl(l,h),l!==null&&(ra(l,h),ha(l))}function uM(l){var h=l.memoizedState,f=0;h!==null&&(f=h.retryLane),C$(l,f)}function cM(l,h){var f=0;switch(l.tag){case 31:case 13:var y=l.stateNode,S=l.memoizedState;S!==null&&(f=S.retryLane);break;case 19:y=l.stateNode;break;case 22:y=l.stateNode._retryCache;break;default:throw Error(s(314))}y!==null&&y.delete(h),C$(l,f)}function hM(l,h){return yn(l,h)}var ty=null,Vc=null,Ev=!1,ny=!1,Rv=!1,Go=0;function ha(l){l!==Vc&&l.next===null&&(Vc===null?ty=Vc=l:Vc=Vc.next=l),ny=!0,Ev||(Ev=!0,pM())}function Rp(l,h){if(!Rv&&ny){Rv=!0;do for(var f=!1,y=ty;y!==null;){if(l!==0){var S=y.pendingLanes;if(S===0)var k=0;else{var _=y.suspendedLanes,V=y.pingedLanes;k=(1<<31-nr(42|l)+1)-1,k&=S&~(_&~V),k=k&201326741?k&201326741|1:k?k|2:0}k!==0&&(f=!0,I$(y,k))}else k=Et,k=_l(y,y===hn?k:0,y.cancelPendingCommit!==null||y.timeoutHandle!==-1),(k&3)===0||Fr(y,k)||(f=!0,I$(y,k));y=y.next}while(f);Rv=!1}}function dM(){N$()}function N$(){ny=Ev=!1;var l=0;Go!==0&&CM()&&(l=Go);for(var h=Ut(),f=null,y=ty;y!==null;){var S=y.next,k=k$(y,h);k===0?(y.next=null,f===null?ty=S:f.next=S,S===null&&(Vc=f)):(f=y,(l!==0||(k&3)!==0)&&(ny=!0)),y=S}ps!==0&&ps!==5||Rp(l),Go!==0&&(Go=0)}function k$(l,h){for(var f=l.suspendedLanes,y=l.pingedLanes,S=l.expirationTimes,k=l.pendingLanes&-62914561;0<k;){var _=31-nr(k),V=1<<_,ne=S[_];ne===-1?((V&f)===0||(V&y)!==0)&&(S[_]=Ud(V,h)):ne<=h&&(l.expiredLanes|=V),k&=~V}if(h=hn,f=Et,f=_l(l,l===h?f:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),y=l.callbackNode,f===0||l===h&&(Jt===2||Jt===9)||l.cancelPendingCommit!==null)return y!==null&&y!==null&&Js(y),l.callbackNode=null,l.callbackPriority=0;if((f&3)===0||Fr(l,f)){if(h=f&-f,h===l.callbackPriority)return h;switch(y!==null&&Js(y),nc(f)){case 2:case 8:f=er;break;case 32:f=tr;break;case 268435456:f=yo;break;default:f=tr}return y=$$.bind(null,l),f=yn(f,y),l.callbackPriority=h,l.callbackNode=f,h}return y!==null&&y!==null&&Js(y),l.callbackPriority=2,l.callbackNode=null,2}function $$(l,h){if(ps!==0&&ps!==5)return l.callbackNode=null,l.callbackPriority=0,null;var f=l.callbackNode;if(ey()&&l.callbackNode!==f)return null;var y=Et;return y=_l(l,l===hn?y:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),y===0?null:(o$(l,y,h),k$(l,Ut()),l.callbackNode!=null&&l.callbackNode===f?$$.bind(null,l):null)}function I$(l,h){if(ey())return null;o$(l,h,!0)}function pM(){kM(function(){(Xt&6)!==0?yn(Bs,dM):N$()})}function Av(){if(Go===0){var l=$c;l===0&&(l=sa,sa<<=1,(sa&261888)===0&&(sa=256)),Go=l}return Go}function T$(l){return l==null||typeof l=="symbol"||typeof l=="boolean"?null:typeof l=="function"?l:cc(""+l)}function E$(l,h){var f=h.ownerDocument.createElement("input");return f.name=h.name,f.value=h.value,l.id&&f.setAttribute("form",l.id),h.parentNode.insertBefore(f,h),l=new FormData(l),f.parentNode.removeChild(f),l}function fM(l,h,f,y,S){if(h==="submit"&&f&&f.stateNode===S){var k=T$((S[cs]||null).action),_=y.submitter;_&&(h=(h=_[cs]||null)?T$(h.formAction):_.getAttribute("formAction"),h!==null&&(k=h,_=null));var V=new dc("action","action",null,y,S);l.push({event:V,listeners:[{instance:null,listener:function(){if(y.defaultPrevented){if(Go!==0){var ne=_?E$(S,_):new FormData(S);Q1(f,{pending:!0,data:ne,method:S.method,action:k},null,ne)}}else typeof k=="function"&&(V.preventDefault(),ne=_?E$(S,_):new FormData(S),Q1(f,{pending:!0,data:ne,method:S.method,action:k},k,ne))},currentTarget:S}]})}}for(var Dv=0;Dv<f1.length;Dv++){var _v=f1[Dv],mM=_v.toLowerCase(),gM=_v[0].toUpperCase()+_v.slice(1);zi(mM,"on"+gM)}zi(aN,"onAnimationEnd"),zi(oN,"onAnimationIteration"),zi(lN,"onAnimationStart"),zi("dblclick","onDoubleClick"),zi("focusin","onFocus"),zi("focusout","onBlur"),zi(DL,"onTransitionRun"),zi(_L,"onTransitionStart"),zi(OL,"onTransitionCancel"),zi(uN,"onTransitionEnd"),_a("onMouseEnter",["mouseout","mouseover"]),_a("onMouseLeave",["mouseout","mouseover"]),_a("onPointerEnter",["pointerout","pointerover"]),_a("onPointerLeave",["pointerout","pointerover"]),vs("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),vs("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),vs("onBeforeInput",["compositionend","keypress","textInput","paste"]),vs("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),vs("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),vs("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ap="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),yM=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ap));function R$(l,h){h=(h&4)!==0;for(var f=0;f<l.length;f++){var y=l[f],S=y.event;y=y.listeners;e:{var k=void 0;if(h)for(var _=y.length-1;0<=_;_--){var V=y[_],ne=V.instance,xe=V.currentTarget;if(V=V.listener,ne!==k&&S.isPropagationStopped())break e;k=V,S.currentTarget=xe;try{k(S)}catch(ke){yg(ke)}S.currentTarget=null,k=ne}else for(_=0;_<y.length;_++){if(V=y[_],ne=V.instance,xe=V.currentTarget,V=V.listener,ne!==k&&S.isPropagationStopped())break e;k=V,S.currentTarget=xe;try{k(S)}catch(ke){yg(ke)}S.currentTarget=null,k=ne}}}}function It(l,h){var f=h[vo];f===void 0&&(f=h[vo]=new Set);var y=l+"__bubble";f.has(y)||(A$(h,l,2,!1),f.add(y))}function Ov(l,h,f){var y=0;h&&(y|=4),A$(f,l,y,h)}var sy="_reactListening"+Math.random().toString(36).slice(2);function Fv(l){if(!l[sy]){l[sy]=!0,Gd.forEach(function(f){f!=="selectionchange"&&(yM.has(f)||Ov(f,!1,l),Ov(f,!0,l))});var h=l.nodeType===9?l:l.ownerDocument;h===null||h[sy]||(h[sy]=!0,Ov("selectionchange",!1,h))}}function A$(l,h,f,y){switch(aI(h)){case 2:var S=HM;break;case 8:S=jM;break;default:S=Yv}f=S.bind(null,h,f,l),S=void 0,!La||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(S=!0),y?S!==void 0?l.addEventListener(h,f,{capture:!0,passive:S}):l.addEventListener(h,f,!0):S!==void 0?l.addEventListener(h,f,{passive:S}):l.addEventListener(h,f,!1)}function zv(l,h,f,y,S){var k=y;if((h&1)===0&&(h&2)===0&&y!==null)e:for(;;){if(y===null)return;var _=y.tag;if(_===3||_===4){var V=y.stateNode.containerInfo;if(V===S)break;if(_===4)for(_=y.return;_!==null;){var ne=_.tag;if((ne===3||ne===4)&&_.stateNode.containerInfo===S)return;_=_.return}for(;V!==null;){if(_=bs(V),_===null)return;if(ne=_.tag,ne===5||ne===6||ne===26||ne===27){y=k=_;continue e}V=V.parentNode}}y=y.return}hc(function(){var xe=k,ke=za(f),Te=[];e:{var be=cN.get(l);if(be!==void 0){var Se=dc,qe=l;switch(l){case"keypress":if(Io(f)===0)break e;case"keydown":case"keyup":Se=r1;break;case"focusin":qe="focus",Se=ep;break;case"focusout":qe="blur",Se=ep;break;case"beforeblur":case"afterblur":Se=ep;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Se=Ul;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Se=Zb;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Se=a1;break;case aN:case oN:case lN:Se=tp;break;case uN:Se=l1;break;case"scroll":case"scrollend":Se=Bl;break;case"wheel":Se=pg;break;case"copy":case"cut":case"paste":Se=lg;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Se=hg;break;case"toggle":case"beforetoggle":Se=T}var lt=(h&4)!==0,ln=!lt&&(l==="scroll"||l==="scrollend"),me=lt?be!==null?be+"Capture":null:be;lt=[];for(var le=xe,ye;le!==null;){var Ie=le;if(ye=Ie.stateNode,Ie=Ie.tag,Ie!==5&&Ie!==26&&Ie!==27||ye===null||me===null||(Ie=$o(le,me),Ie!=null&&lt.push(Dp(le,Ie,ye))),ln)break;le=le.return}0<lt.length&&(be=new Se(be,qe,null,f,ke),Te.push({event:be,listeners:lt}))}}if((h&7)===0){e:{if(be=l==="mouseover"||l==="pointerover",Se=l==="mouseout"||l==="pointerout",be&&f!==Ll&&(qe=f.relatedTarget||f.fromElement)&&(bs(qe)||qe[ia]))break e;if((Se||be)&&(be=ke.window===ke?ke:(be=ke.ownerDocument)?be.defaultView||be.parentWindow:window,Se?(qe=f.relatedTarget||f.toElement,Se=xe,qe=qe?bs(qe):null,qe!==null&&(ln=i(qe),lt=qe.tag,qe!==ln||lt!==5&&lt!==27&&lt!==6)&&(qe=null)):(Se=null,qe=xe),Se!==qe)){if(lt=Ul,Ie="onMouseLeave",me="onMouseEnter",le="mouse",(l==="pointerout"||l==="pointerover")&&(lt=hg,Ie="onPointerLeave",me="onPointerEnter",le="pointer"),ln=Se==null?be:Di(Se),ye=qe==null?be:Di(qe),be=new lt(Ie,le+"leave",Se,f,ke),be.target=ln,be.relatedTarget=ye,Ie=null,bs(ke)===xe&&(lt=new lt(me,le+"enter",qe,f,ke),lt.target=ye,lt.relatedTarget=ln,Ie=lt),ln=Ie,Se&&qe)t:{for(lt=xM,me=Se,le=qe,ye=0,Ie=me;Ie;Ie=lt(Ie))ye++;Ie=0;for(var st=le;st;st=lt(st))Ie++;for(;0<ye-Ie;)me=lt(me),ye--;for(;0<Ie-ye;)le=lt(le),Ie--;for(;ye--;){if(me===le||le!==null&&me===le.alternate){lt=me;break t}me=lt(me),le=lt(le)}lt=null}else lt=null;Se!==null&&D$(Te,be,Se,lt,!1),qe!==null&&ln!==null&&D$(Te,ln,qe,lt,!0)}}e:{if(be=xe?Di(xe):window,Se=be.nodeName&&be.nodeName.toLowerCase(),Se==="select"||Se==="input"&&be.type==="file")var Ht=zt;else if(bt(be))if(jn)Ht=EL;else{Ht=yc;var et=u1}else Se=be.nodeName,!Se||Se.toLowerCase()!=="input"||be.type!=="checkbox"&&be.type!=="radio"?xe&&Fa(xe.elementType)&&(Ht=zt):Ht=TL;if(Ht&&(Ht=Ht(l,xe))){rn(Te,Ht,f,ke);break e}et&&et(l,be,xe),l==="focusout"&&xe&&be.type==="number"&&xe.memoizedProps.value!=null&&lc(be,"number",be.value)}switch(et=xe?Di(xe):window,l){case"focusin":(bt(et)||et.contentEditable==="true")&&(xc=et,h1=xe,op=null);break;case"focusout":op=h1=xc=null;break;case"mousedown":d1=!0;break;case"contextmenu":case"mouseup":case"dragend":d1=!1,rN(Te,f,ke);break;case"selectionchange":if(AL)break;case"keydown":case"keyup":rN(Te,f,ke)}var Ct;if(P)e:{switch(l){case"compositionstart":var Rt="onCompositionStart";break e;case"compositionend":Rt="onCompositionEnd";break e;case"compositionupdate":Rt="onCompositionUpdate";break e}Rt=void 0}else nt?De(l,f)&&(Rt="onCompositionEnd"):l==="keydown"&&f.keyCode===229&&(Rt="onCompositionStart");Rt&&(K&&f.locale!=="ko"&&(nt||Rt!=="onCompositionStart"?Rt==="onCompositionEnd"&&nt&&(Ct=Jd()):(oa=ke,Zd="value"in oa?oa.value:oa.textContent,nt=!0)),et=ry(xe,Rt),0<et.length&&(Rt=new ug(Rt,l,null,f,ke),Te.push({event:Rt,listeners:et}),Ct?Rt.data=Ct:(Ct=Me(f),Ct!==null&&(Rt.data=Ct)))),(Ct=Y?tt(l,f):Ge(l,f))&&(Rt=ry(xe,"onBeforeInput"),0<Rt.length&&(et=new ug("onBeforeInput","beforeinput",null,f,ke),Te.push({event:et,listeners:Rt}),et.data=Ct)),fM(Te,l,xe,f,ke)}R$(Te,h)})}function Dp(l,h,f){return{instance:l,listener:h,currentTarget:f}}function ry(l,h){for(var f=h+"Capture",y=[];l!==null;){var S=l,k=S.stateNode;if(S=S.tag,S!==5&&S!==26&&S!==27||k===null||(S=$o(l,f),S!=null&&y.unshift(Dp(l,S,k)),S=$o(l,h),S!=null&&y.push(Dp(l,S,k))),l.tag===3)return y;l=l.return}return[]}function xM(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5&&l.tag!==27);return l||null}function D$(l,h,f,y,S){for(var k=h._reactName,_=[];f!==null&&f!==y;){var V=f,ne=V.alternate,xe=V.stateNode;if(V=V.tag,ne!==null&&ne===y)break;V!==5&&V!==26&&V!==27||xe===null||(ne=xe,S?(xe=$o(f,k),xe!=null&&_.unshift(Dp(f,xe,ne))):S||(xe=$o(f,k),xe!=null&&_.push(Dp(f,xe,ne)))),f=f.return}_.length!==0&&l.push({event:h,listeners:_})}var bM=/\r\n?/g,vM=/\u0000|\uFFFD/g;function _$(l){return(typeof l=="string"?l:""+l).replace(bM,`
`).replace(vM,"")}function O$(l,h){return h=_$(h),_$(l)===h}function on(l,h,f,y,S,k){switch(f){case"children":typeof y=="string"?h==="body"||h==="textarea"&&y===""||Oa(l,y):(typeof y=="number"||typeof y=="bigint")&&h!=="body"&&Oa(l,""+y);break;case"className":wo(l,"class",y);break;case"tabIndex":wo(l,"tabindex",y);break;case"dir":case"role":case"viewBox":case"width":case"height":wo(l,f,y);break;case"style":Yd(l,y,k);break;case"data":if(h!=="object"){wo(l,"data",y);break}case"src":case"href":if(y===""&&(h!=="a"||f!=="href")){l.removeAttribute(f);break}if(y==null||typeof y=="function"||typeof y=="symbol"||typeof y=="boolean"){l.removeAttribute(f);break}y=cc(""+y),l.setAttribute(f,y);break;case"action":case"formAction":if(typeof y=="function"){l.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof k=="function"&&(f==="formAction"?(h!=="input"&&on(l,h,"name",S.name,S,null),on(l,h,"formEncType",S.formEncType,S,null),on(l,h,"formMethod",S.formMethod,S,null),on(l,h,"formTarget",S.formTarget,S,null)):(on(l,h,"encType",S.encType,S,null),on(l,h,"method",S.method,S,null),on(l,h,"target",S.target,S,null)));if(y==null||typeof y=="symbol"||typeof y=="boolean"){l.removeAttribute(f);break}y=cc(""+y),l.setAttribute(f,y);break;case"onClick":y!=null&&(l.onclick=Oi);break;case"onScroll":y!=null&&It("scroll",l);break;case"onScrollEnd":y!=null&&It("scrollend",l);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(s(61));if(f=y.__html,f!=null){if(S.children!=null)throw Error(s(60));l.innerHTML=f}}break;case"multiple":l.multiple=y&&typeof y!="function"&&typeof y!="symbol";break;case"muted":l.muted=y&&typeof y!="function"&&typeof y!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(y==null||typeof y=="function"||typeof y=="boolean"||typeof y=="symbol"){l.removeAttribute("xlink:href");break}f=cc(""+y),l.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":y!=null&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(f,""+y):l.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":y&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(f,""):l.removeAttribute(f);break;case"capture":case"download":y===!0?l.setAttribute(f,""):y!==!1&&y!=null&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(f,y):l.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":y!=null&&typeof y!="function"&&typeof y!="symbol"&&!isNaN(y)&&1<=y?l.setAttribute(f,y):l.removeAttribute(f);break;case"rowSpan":case"start":y==null||typeof y=="function"||typeof y=="symbol"||isNaN(y)?l.removeAttribute(f):l.setAttribute(f,y);break;case"popover":It("beforetoggle",l),It("toggle",l),zl(l,"popover",y);break;case"xlinkActuate":_i(l,"http://www.w3.org/1999/xlink","xlink:actuate",y);break;case"xlinkArcrole":_i(l,"http://www.w3.org/1999/xlink","xlink:arcrole",y);break;case"xlinkRole":_i(l,"http://www.w3.org/1999/xlink","xlink:role",y);break;case"xlinkShow":_i(l,"http://www.w3.org/1999/xlink","xlink:show",y);break;case"xlinkTitle":_i(l,"http://www.w3.org/1999/xlink","xlink:title",y);break;case"xlinkType":_i(l,"http://www.w3.org/1999/xlink","xlink:type",y);break;case"xmlBase":_i(l,"http://www.w3.org/XML/1998/namespace","xml:base",y);break;case"xmlLang":_i(l,"http://www.w3.org/XML/1998/namespace","xml:lang",y);break;case"xmlSpace":_i(l,"http://www.w3.org/XML/1998/namespace","xml:space",y);break;case"is":zl(l,"is",y);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=Yb.get(f)||f,zl(l,f,y))}}function Lv(l,h,f,y,S,k){switch(f){case"style":Yd(l,y,k);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(s(61));if(f=y.__html,f!=null){if(S.children!=null)throw Error(s(60));l.innerHTML=f}}break;case"children":typeof y=="string"?Oa(l,y):(typeof y=="number"||typeof y=="bigint")&&Oa(l,""+y);break;case"onScroll":y!=null&&It("scroll",l);break;case"onScrollEnd":y!=null&&It("scrollend",l);break;case"onClick":y!=null&&(l.onclick=Oi);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!ic.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(S=f.endsWith("Capture"),h=f.slice(2,S?f.length-7:void 0),k=l[cs]||null,k=k!=null?k[f]:null,typeof k=="function"&&l.removeEventListener(h,k,S),typeof y=="function")){typeof k!="function"&&k!==null&&(f in l?l[f]=null:l.hasAttribute(f)&&l.removeAttribute(f)),l.addEventListener(h,y,S);break e}f in l?l[f]=y:y===!0?l.setAttribute(f,""):zl(l,f,y)}}}function Os(l,h,f){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":It("error",l),It("load",l);var y=!1,S=!1,k;for(k in f)if(f.hasOwnProperty(k)){var _=f[k];if(_!=null)switch(k){case"src":y=!0;break;case"srcSet":S=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,h));default:on(l,h,k,_,f,null)}}S&&on(l,h,"srcSet",f.srcSet,f,null),y&&on(l,h,"src",f.src,f,null);return;case"input":It("invalid",l);var V=k=_=S=null,ne=null,xe=null;for(y in f)if(f.hasOwnProperty(y)){var ke=f[y];if(ke!=null)switch(y){case"name":S=ke;break;case"type":_=ke;break;case"checked":ne=ke;break;case"defaultChecked":xe=ke;break;case"value":k=ke;break;case"defaultValue":V=ke;break;case"children":case"dangerouslySetInnerHTML":if(ke!=null)throw Error(s(137,h));break;default:on(l,h,y,ke,f,null)}}qd(l,k,V,ne,xe,_,S,!1);return;case"select":It("invalid",l),y=_=k=null;for(S in f)if(f.hasOwnProperty(S)&&(V=f[S],V!=null))switch(S){case"value":k=V;break;case"defaultValue":_=V;break;case"multiple":y=V;default:on(l,h,S,V,f,null)}h=k,f=_,l.multiple=!!y,h!=null?Co(l,!!y,h,!1):f!=null&&Co(l,!!y,f,!0);return;case"textarea":It("invalid",l),k=S=y=null;for(_ in f)if(f.hasOwnProperty(_)&&(V=f[_],V!=null))switch(_){case"value":y=V;break;case"defaultValue":S=V;break;case"children":k=V;break;case"dangerouslySetInnerHTML":if(V!=null)throw Error(s(91));break;default:on(l,h,_,V,f,null)}Xd(l,y,S,k);return;case"option":for(ne in f)if(f.hasOwnProperty(ne)&&(y=f[ne],y!=null))switch(ne){case"selected":l.selected=y&&typeof y!="function"&&typeof y!="symbol";break;default:on(l,h,ne,y,f,null)}return;case"dialog":It("beforetoggle",l),It("toggle",l),It("cancel",l),It("close",l);break;case"iframe":case"object":It("load",l);break;case"video":case"audio":for(y=0;y<Ap.length;y++)It(Ap[y],l);break;case"image":It("error",l),It("load",l);break;case"details":It("toggle",l);break;case"embed":case"source":case"link":It("error",l),It("load",l);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(xe in f)if(f.hasOwnProperty(xe)&&(y=f[xe],y!=null))switch(xe){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,h));default:on(l,h,xe,y,f,null)}return;default:if(Fa(h)){for(ke in f)f.hasOwnProperty(ke)&&(y=f[ke],y!==void 0&&Lv(l,h,ke,y,f,void 0));return}}for(V in f)f.hasOwnProperty(V)&&(y=f[V],y!=null&&on(l,h,V,y,f,null))}function wM(l,h,f,y){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var S=null,k=null,_=null,V=null,ne=null,xe=null,ke=null;for(Se in f){var Te=f[Se];if(f.hasOwnProperty(Se)&&Te!=null)switch(Se){case"checked":break;case"value":break;case"defaultValue":ne=Te;default:y.hasOwnProperty(Se)||on(l,h,Se,null,y,Te)}}for(var be in y){var Se=y[be];if(Te=f[be],y.hasOwnProperty(be)&&(Se!=null||Te!=null))switch(be){case"type":k=Se;break;case"name":S=Se;break;case"checked":xe=Se;break;case"defaultChecked":ke=Se;break;case"value":_=Se;break;case"defaultValue":V=Se;break;case"children":case"dangerouslySetInnerHTML":if(Se!=null)throw Error(s(137,h));break;default:Se!==Te&&on(l,h,be,Se,y,Te)}}So(l,_,V,ne,xe,ke,k,S);return;case"select":Se=_=V=be=null;for(k in f)if(ne=f[k],f.hasOwnProperty(k)&&ne!=null)switch(k){case"value":break;case"multiple":Se=ne;default:y.hasOwnProperty(k)||on(l,h,k,null,y,ne)}for(S in y)if(k=y[S],ne=f[S],y.hasOwnProperty(S)&&(k!=null||ne!=null))switch(S){case"value":be=k;break;case"defaultValue":V=k;break;case"multiple":_=k;default:k!==ne&&on(l,h,S,k,y,ne)}h=V,f=_,y=Se,be!=null?Co(l,!!f,be,!1):!!y!=!!f&&(h!=null?Co(l,!!f,h,!0):Co(l,!!f,f?[]:"",!1));return;case"textarea":Se=be=null;for(V in f)if(S=f[V],f.hasOwnProperty(V)&&S!=null&&!y.hasOwnProperty(V))switch(V){case"value":break;case"children":break;default:on(l,h,V,null,y,S)}for(_ in y)if(S=y[_],k=f[_],y.hasOwnProperty(_)&&(S!=null||k!=null))switch(_){case"value":be=S;break;case"defaultValue":Se=S;break;case"children":break;case"dangerouslySetInnerHTML":if(S!=null)throw Error(s(91));break;default:S!==k&&on(l,h,_,S,y,k)}rg(l,be,Se);return;case"option":for(var qe in f)if(be=f[qe],f.hasOwnProperty(qe)&&be!=null&&!y.hasOwnProperty(qe))switch(qe){case"selected":l.selected=!1;break;default:on(l,h,qe,null,y,be)}for(ne in y)if(be=y[ne],Se=f[ne],y.hasOwnProperty(ne)&&be!==Se&&(be!=null||Se!=null))switch(ne){case"selected":l.selected=be&&typeof be!="function"&&typeof be!="symbol";break;default:on(l,h,ne,be,y,Se)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var lt in f)be=f[lt],f.hasOwnProperty(lt)&&be!=null&&!y.hasOwnProperty(lt)&&on(l,h,lt,null,y,be);for(xe in y)if(be=y[xe],Se=f[xe],y.hasOwnProperty(xe)&&be!==Se&&(be!=null||Se!=null))switch(xe){case"children":case"dangerouslySetInnerHTML":if(be!=null)throw Error(s(137,h));break;default:on(l,h,xe,be,y,Se)}return;default:if(Fa(h)){for(var ln in f)be=f[ln],f.hasOwnProperty(ln)&&be!==void 0&&!y.hasOwnProperty(ln)&&Lv(l,h,ln,void 0,y,be);for(ke in y)be=y[ke],Se=f[ke],!y.hasOwnProperty(ke)||be===Se||be===void 0&&Se===void 0||Lv(l,h,ke,be,y,Se);return}}for(var me in f)be=f[me],f.hasOwnProperty(me)&&be!=null&&!y.hasOwnProperty(me)&&on(l,h,me,null,y,be);for(Te in y)be=y[Te],Se=f[Te],!y.hasOwnProperty(Te)||be===Se||be==null&&Se==null||on(l,h,Te,be,y,Se)}function F$(l){switch(l){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function SM(){if(typeof performance.getEntriesByType=="function"){for(var l=0,h=0,f=performance.getEntriesByType("resource"),y=0;y<f.length;y++){var S=f[y],k=S.transferSize,_=S.initiatorType,V=S.duration;if(k&&V&&F$(_)){for(_=0,V=S.responseEnd,y+=1;y<f.length;y++){var ne=f[y],xe=ne.startTime;if(xe>V)break;var ke=ne.transferSize,Te=ne.initiatorType;ke&&F$(Te)&&(ne=ne.responseEnd,_+=ke*(ne<V?1:(V-xe)/(ne-xe)))}if(--y,h+=8*(k+_)/(S.duration/1e3),l++,10<l)break}}if(0<l)return h/l/1e6}return navigator.connection&&(l=navigator.connection.downlink,typeof l=="number")?l:5}var Mv=null,Pv=null;function iy(l){return l.nodeType===9?l:l.ownerDocument}function z$(l){switch(l){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function L$(l,h){if(l===0)switch(h){case"svg":return 1;case"math":return 2;default:return 0}return l===1&&h==="foreignObject"?0:l}function Bv(l,h){return l==="textarea"||l==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.children=="bigint"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var Vv=null;function CM(){var l=window.event;return l&&l.type==="popstate"?l===Vv?!1:(Vv=l,!0):(Vv=null,!1)}var M$=typeof setTimeout=="function"?setTimeout:void 0,NM=typeof clearTimeout=="function"?clearTimeout:void 0,P$=typeof Promise=="function"?Promise:void 0,kM=typeof queueMicrotask=="function"?queueMicrotask:typeof P$<"u"?function(l){return P$.resolve(null).then(l).catch($M)}:M$;function $M(l){setTimeout(function(){throw l})}function Ho(l){return l==="head"}function B$(l,h){var f=h,y=0;do{var S=f.nextSibling;if(l.removeChild(f),S&&S.nodeType===8)if(f=S.data,f==="/$"||f==="/&"){if(y===0){l.removeChild(S),Hc(h);return}y--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")y++;else if(f==="html")_p(l.ownerDocument.documentElement);else if(f==="head"){f=l.ownerDocument.head,_p(f);for(var k=f.firstChild;k;){var _=k.nextSibling,V=k.nodeName;k[Da]||V==="SCRIPT"||V==="STYLE"||V==="LINK"&&k.rel.toLowerCase()==="stylesheet"||f.removeChild(k),k=_}}else f==="body"&&_p(l.ownerDocument.body);f=S}while(f);Hc(h)}function V$(l,h){var f=l;l=0;do{var y=f.nextSibling;if(f.nodeType===1?h?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(h?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),y&&y.nodeType===8)if(f=y.data,f==="/$"){if(l===0)break;l--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||l++;f=y}while(f)}function Uv(l){var h=l.firstChild;for(h&&h.nodeType===10&&(h=h.nextSibling);h;){var f=h;switch(h=h.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":Uv(f),rc(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}l.removeChild(f)}}function IM(l,h,f,y){for(;l.nodeType===1;){var S=f;if(l.nodeName.toLowerCase()!==h.toLowerCase()){if(!y&&(l.nodeName!=="INPUT"||l.type!=="hidden"))break}else if(y){if(!l[Da])switch(h){case"meta":if(!l.hasAttribute("itemprop"))break;return l;case"link":if(k=l.getAttribute("rel"),k==="stylesheet"&&l.hasAttribute("data-precedence"))break;if(k!==S.rel||l.getAttribute("href")!==(S.href==null||S.href===""?null:S.href)||l.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin)||l.getAttribute("title")!==(S.title==null?null:S.title))break;return l;case"style":if(l.hasAttribute("data-precedence"))break;return l;case"script":if(k=l.getAttribute("src"),(k!==(S.src==null?null:S.src)||l.getAttribute("type")!==(S.type==null?null:S.type)||l.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin))&&k&&l.hasAttribute("async")&&!l.hasAttribute("itemprop"))break;return l;default:return l}}else if(h==="input"&&l.type==="hidden"){var k=S.name==null?null:""+S.name;if(S.type==="hidden"&&l.getAttribute("name")===k)return l}else return l;if(l=hi(l.nextSibling),l===null)break}return null}function TM(l,h,f){if(h==="")return null;for(;l.nodeType!==3;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!f||(l=hi(l.nextSibling),l===null))return null;return l}function U$(l,h){for(;l.nodeType!==8;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!h||(l=hi(l.nextSibling),l===null))return null;return l}function Wv(l){return l.data==="$?"||l.data==="$~"}function Gv(l){return l.data==="$!"||l.data==="$?"&&l.ownerDocument.readyState!=="loading"}function EM(l,h){var f=l.ownerDocument;if(l.data==="$~")l._reactRetry=h;else if(l.data!=="$?"||f.readyState!=="loading")h();else{var y=function(){h(),f.removeEventListener("DOMContentLoaded",y)};f.addEventListener("DOMContentLoaded",y),l._reactRetry=y}}function hi(l){for(;l!=null;l=l.nextSibling){var h=l.nodeType;if(h===1||h===3)break;if(h===8){if(h=l.data,h==="$"||h==="$!"||h==="$?"||h==="$~"||h==="&"||h==="F!"||h==="F")break;if(h==="/$"||h==="/&")return null}}return l}var Hv=null;function W$(l){l=l.nextSibling;for(var h=0;l;){if(l.nodeType===8){var f=l.data;if(f==="/$"||f==="/&"){if(h===0)return hi(l.nextSibling);h--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||h++}l=l.nextSibling}return null}function G$(l){l=l.previousSibling;for(var h=0;l;){if(l.nodeType===8){var f=l.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(h===0)return l;h--}else f!=="/$"&&f!=="/&"||h++}l=l.previousSibling}return null}function H$(l,h,f){switch(h=iy(f),l){case"html":if(l=h.documentElement,!l)throw Error(s(452));return l;case"head":if(l=h.head,!l)throw Error(s(453));return l;case"body":if(l=h.body,!l)throw Error(s(454));return l;default:throw Error(s(451))}}function _p(l){for(var h=l.attributes;h.length;)l.removeAttributeNode(h[0]);rc(l)}var di=new Map,j$=new Set;function ay(l){return typeof l.getRootNode=="function"?l.getRootNode():l.nodeType===9?l:l.ownerDocument}var Ja=ee.d;ee.d={f:RM,r:AM,D:DM,C:_M,L:OM,m:FM,X:LM,S:zM,M:MM};function RM(){var l=Ja.f(),h=Qg();return l||h}function AM(l){var h=Ts(l);h!==null&&h.tag===5&&h.type==="form"?uk(h):Ja.r(l)}var Uc=typeof document>"u"?null:document;function q$(l,h,f){var y=Uc;if(y&&typeof h=="string"&&h){var S=sr(h);S='link[rel="'+l+'"][href="'+S+'"]',typeof f=="string"&&(S+='[crossorigin="'+f+'"]'),j$.has(S)||(j$.add(S),l={rel:l,crossOrigin:f,href:h},y.querySelector(S)===null&&(h=y.createElement("link"),Os(h,"link",l),_n(h),y.head.appendChild(h)))}}function DM(l){Ja.D(l),q$("dns-prefetch",l,null)}function _M(l,h){Ja.C(l,h),q$("preconnect",l,h)}function OM(l,h,f){Ja.L(l,h,f);var y=Uc;if(y&&l&&h){var S='link[rel="preload"][as="'+sr(h)+'"]';h==="image"&&f&&f.imageSrcSet?(S+='[imagesrcset="'+sr(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(S+='[imagesizes="'+sr(f.imageSizes)+'"]')):S+='[href="'+sr(l)+'"]';var k=S;switch(h){case"style":k=Wc(l);break;case"script":k=Gc(l)}di.has(k)||(l=p({rel:"preload",href:h==="image"&&f&&f.imageSrcSet?void 0:l,as:h},f),di.set(k,l),y.querySelector(S)!==null||h==="style"&&y.querySelector(Op(k))||h==="script"&&y.querySelector(Fp(k))||(h=y.createElement("link"),Os(h,"link",l),_n(h),y.head.appendChild(h)))}}function FM(l,h){Ja.m(l,h);var f=Uc;if(f&&l){var y=h&&typeof h.as=="string"?h.as:"script",S='link[rel="modulepreload"][as="'+sr(y)+'"][href="'+sr(l)+'"]',k=S;switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":k=Gc(l)}if(!di.has(k)&&(l=p({rel:"modulepreload",href:l},h),di.set(k,l),f.querySelector(S)===null)){switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(Fp(k)))return}y=f.createElement("link"),Os(y,"link",l),_n(y),f.head.appendChild(y)}}}function zM(l,h,f){Ja.S(l,h,f);var y=Uc;if(y&&l){var S=aa(y).hoistableStyles,k=Wc(l);h=h||"default";var _=S.get(k);if(!_){var V={loading:0,preload:null};if(_=y.querySelector(Op(k)))V.loading=5;else{l=p({rel:"stylesheet",href:l,"data-precedence":h},f),(f=di.get(k))&&jv(l,f);var ne=_=y.createElement("link");_n(ne),Os(ne,"link",l),ne._p=new Promise(function(xe,ke){ne.onload=xe,ne.onerror=ke}),ne.addEventListener("load",function(){V.loading|=1}),ne.addEventListener("error",function(){V.loading|=2}),V.loading|=4,oy(_,h,y)}_={type:"stylesheet",instance:_,count:1,state:V},S.set(k,_)}}}function LM(l,h){Ja.X(l,h);var f=Uc;if(f&&l){var y=aa(f).hoistableScripts,S=Gc(l),k=y.get(S);k||(k=f.querySelector(Fp(S)),k||(l=p({src:l,async:!0},h),(h=di.get(S))&&qv(l,h),k=f.createElement("script"),_n(k),Os(k,"link",l),f.head.appendChild(k)),k={type:"script",instance:k,count:1,state:null},y.set(S,k))}}function MM(l,h){Ja.M(l,h);var f=Uc;if(f&&l){var y=aa(f).hoistableScripts,S=Gc(l),k=y.get(S);k||(k=f.querySelector(Fp(S)),k||(l=p({src:l,async:!0,type:"module"},h),(h=di.get(S))&&qv(l,h),k=f.createElement("script"),_n(k),Os(k,"link",l),f.head.appendChild(k)),k={type:"script",instance:k,count:1,state:null},y.set(S,k))}}function X$(l,h,f,y){var S=(S=Ee.current)?ay(S):null;if(!S)throw Error(s(446));switch(l){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(h=Wc(f.href),f=aa(S).hoistableStyles,y=f.get(h),y||(y={type:"style",instance:null,count:0,state:null},f.set(h,y)),y):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){l=Wc(f.href);var k=aa(S).hoistableStyles,_=k.get(l);if(_||(S=S.ownerDocument||S,_={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},k.set(l,_),(k=S.querySelector(Op(l)))&&!k._p&&(_.instance=k,_.state.loading=5),di.has(l)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},di.set(l,f),k||PM(S,l,f,_.state))),h&&y===null)throw Error(s(528,""));return _}if(h&&y!==null)throw Error(s(529,""));return null;case"script":return h=f.async,f=f.src,typeof f=="string"&&h&&typeof h!="function"&&typeof h!="symbol"?(h=Gc(f),f=aa(S).hoistableScripts,y=f.get(h),y||(y={type:"script",instance:null,count:0,state:null},f.set(h,y)),y):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,l))}}function Wc(l){return'href="'+sr(l)+'"'}function Op(l){return'link[rel="stylesheet"]['+l+"]"}function K$(l){return p({},l,{"data-precedence":l.precedence,precedence:null})}function PM(l,h,f,y){l.querySelector('link[rel="preload"][as="style"]['+h+"]")?y.loading=1:(h=l.createElement("link"),y.preload=h,h.addEventListener("load",function(){return y.loading|=1}),h.addEventListener("error",function(){return y.loading|=2}),Os(h,"link",f),_n(h),l.head.appendChild(h))}function Gc(l){return'[src="'+sr(l)+'"]'}function Fp(l){return"script[async]"+l}function Y$(l,h,f){if(h.count++,h.instance===null)switch(h.type){case"style":var y=l.querySelector('style[data-href~="'+sr(f.href)+'"]');if(y)return h.instance=y,_n(y),y;var S=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return y=(l.ownerDocument||l).createElement("style"),_n(y),Os(y,"style",S),oy(y,f.precedence,l),h.instance=y;case"stylesheet":S=Wc(f.href);var k=l.querySelector(Op(S));if(k)return h.state.loading|=4,h.instance=k,_n(k),k;y=K$(f),(S=di.get(S))&&jv(y,S),k=(l.ownerDocument||l).createElement("link"),_n(k);var _=k;return _._p=new Promise(function(V,ne){_.onload=V,_.onerror=ne}),Os(k,"link",y),h.state.loading|=4,oy(k,f.precedence,l),h.instance=k;case"script":return k=Gc(f.src),(S=l.querySelector(Fp(k)))?(h.instance=S,_n(S),S):(y=f,(S=di.get(k))&&(y=p({},f),qv(y,S)),l=l.ownerDocument||l,S=l.createElement("script"),_n(S),Os(S,"link",y),l.head.appendChild(S),h.instance=S);case"void":return null;default:throw Error(s(443,h.type))}else h.type==="stylesheet"&&(h.state.loading&4)===0&&(y=h.instance,h.state.loading|=4,oy(y,f.precedence,l));return h.instance}function oy(l,h,f){for(var y=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),S=y.length?y[y.length-1]:null,k=S,_=0;_<y.length;_++){var V=y[_];if(V.dataset.precedence===h)k=V;else if(k!==S)break}k?k.parentNode.insertBefore(l,k.nextSibling):(h=f.nodeType===9?f.head:f,h.insertBefore(l,h.firstChild))}function jv(l,h){l.crossOrigin==null&&(l.crossOrigin=h.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=h.referrerPolicy),l.title==null&&(l.title=h.title)}function qv(l,h){l.crossOrigin==null&&(l.crossOrigin=h.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=h.referrerPolicy),l.integrity==null&&(l.integrity=h.integrity)}var ly=null;function Q$(l,h,f){if(ly===null){var y=new Map,S=ly=new Map;S.set(f,y)}else S=ly,y=S.get(f),y||(y=new Map,S.set(f,y));if(y.has(l))return y;for(y.set(l,null),f=f.getElementsByTagName(l),S=0;S<f.length;S++){var k=f[S];if(!(k[Da]||k[us]||l==="link"&&k.getAttribute("rel")==="stylesheet")&&k.namespaceURI!=="http://www.w3.org/2000/svg"){var _=k.getAttribute(h)||"";_=l+_;var V=y.get(_);V?V.push(k):y.set(_,[k])}}return y}function Z$(l,h,f){l=l.ownerDocument||l,l.head.insertBefore(f,h==="title"?l.querySelector("head > title"):null)}function BM(l,h,f){if(f===1||h.itemProp!=null)return!1;switch(l){case"meta":case"title":return!0;case"style":if(typeof h.precedence!="string"||typeof h.href!="string"||h.href==="")break;return!0;case"link":if(typeof h.rel!="string"||typeof h.href!="string"||h.href===""||h.onLoad||h.onError)break;switch(h.rel){case"stylesheet":return l=h.disabled,typeof h.precedence=="string"&&l==null;default:return!0}case"script":if(h.async&&typeof h.async!="function"&&typeof h.async!="symbol"&&!h.onLoad&&!h.onError&&h.src&&typeof h.src=="string")return!0}return!1}function J$(l){return!(l.type==="stylesheet"&&(l.state.loading&3)===0)}function VM(l,h,f,y){if(f.type==="stylesheet"&&(typeof y.media!="string"||matchMedia(y.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var S=Wc(y.href),k=h.querySelector(Op(S));if(k){h=k._p,h!==null&&typeof h=="object"&&typeof h.then=="function"&&(l.count++,l=uy.bind(l),h.then(l,l)),f.state.loading|=4,f.instance=k,_n(k);return}k=h.ownerDocument||h,y=K$(y),(S=di.get(S))&&jv(y,S),k=k.createElement("link"),_n(k);var _=k;_._p=new Promise(function(V,ne){_.onload=V,_.onerror=ne}),Os(k,"link",y),f.instance=k}l.stylesheets===null&&(l.stylesheets=new Map),l.stylesheets.set(f,h),(h=f.state.preload)&&(f.state.loading&3)===0&&(l.count++,f=uy.bind(l),h.addEventListener("load",f),h.addEventListener("error",f))}}var Xv=0;function UM(l,h){return l.stylesheets&&l.count===0&&hy(l,l.stylesheets),0<l.count||0<l.imgCount?function(f){var y=setTimeout(function(){if(l.stylesheets&&hy(l,l.stylesheets),l.unsuspend){var k=l.unsuspend;l.unsuspend=null,k()}},6e4+h);0<l.imgBytes&&Xv===0&&(Xv=62500*SM());var S=setTimeout(function(){if(l.waitingForImages=!1,l.count===0&&(l.stylesheets&&hy(l,l.stylesheets),l.unsuspend)){var k=l.unsuspend;l.unsuspend=null,k()}},(l.imgBytes>Xv?50:800)+h);return l.unsuspend=f,function(){l.unsuspend=null,clearTimeout(y),clearTimeout(S)}}:null}function uy(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)hy(this,this.stylesheets);else if(this.unsuspend){var l=this.unsuspend;this.unsuspend=null,l()}}}var cy=null;function hy(l,h){l.stylesheets=null,l.unsuspend!==null&&(l.count++,cy=new Map,h.forEach(WM,l),cy=null,uy.call(l))}function WM(l,h){if(!(h.state.loading&4)){var f=cy.get(l);if(f)var y=f.get(null);else{f=new Map,cy.set(l,f);for(var S=l.querySelectorAll("link[data-precedence],style[data-precedence]"),k=0;k<S.length;k++){var _=S[k];(_.nodeName==="LINK"||_.getAttribute("media")!=="not all")&&(f.set(_.dataset.precedence,_),y=_)}y&&f.set(null,y)}S=h.instance,_=S.getAttribute("data-precedence"),k=f.get(_)||y,k===y&&f.set(null,S),f.set(_,S),this.count++,y=uy.bind(this),S.addEventListener("load",y),S.addEventListener("error",y),k?k.parentNode.insertBefore(S,k.nextSibling):(l=l.nodeType===9?l.head:l,l.insertBefore(S,l.firstChild)),h.state.loading|=4}}var zp={$$typeof:I,Provider:null,Consumer:null,_currentValue:ie,_currentValue2:ie,_threadCount:0};function GM(l,h,f,y,S,k,_,V,ne){this.tag=1,this.containerInfo=l,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=bo(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=bo(0),this.hiddenUpdates=bo(null),this.identifierPrefix=y,this.onUncaughtError=S,this.onCaughtError=k,this.onRecoverableError=_,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=ne,this.incompleteTransitions=new Map}function eI(l,h,f,y,S,k,_,V,ne,xe,ke,Te){return l=new GM(l,h,f,_,ne,xe,ke,Te,V),h=1,k===!0&&(h|=24),k=Pr(3,null,null,h),l.current=k,k.stateNode=l,h=I1(),h.refCount++,l.pooledCache=h,h.refCount++,k.memoizedState={element:y,isDehydrated:f,cache:h},A1(k),l}function tI(l){return l?(l=wc,l):wc}function nI(l,h,f,y,S,k){S=tI(S),y.context===null?y.context=S:y.pendingContext=S,y=Oo(h),y.payload={element:f},k=k===void 0?null:k,k!==null&&(y.callback=k),f=Fo(l,y,h),f!==null&&(wr(f,l,h),fp(f,l,h))}function sI(l,h){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var f=l.retryLane;l.retryLane=f!==0&&f<h?f:h}}function Kv(l,h){sI(l,h),(l=l.alternate)&&sI(l,h)}function rI(l){if(l.tag===13||l.tag===31){var h=Hl(l,67108864);h!==null&&wr(h,l,67108864),Kv(l,67108864)}}function iI(l){if(l.tag===13||l.tag===31){var h=Gr();h=Ai(h);var f=Hl(l,h);f!==null&&wr(f,l,h),Kv(l,h)}}var dy=!0;function HM(l,h,f,y){var S=W.T;W.T=null;var k=ee.p;try{ee.p=2,Yv(l,h,f,y)}finally{ee.p=k,W.T=S}}function jM(l,h,f,y){var S=W.T;W.T=null;var k=ee.p;try{ee.p=8,Yv(l,h,f,y)}finally{ee.p=k,W.T=S}}function Yv(l,h,f,y){if(dy){var S=Qv(y);if(S===null)zv(l,h,y,py,f),oI(l,y);else if(XM(S,l,h,f,y))y.stopPropagation();else if(oI(l,y),h&4&&-1<qM.indexOf(l)){for(;S!==null;){var k=Ts(S);if(k!==null)switch(k.tag){case 3:if(k=k.stateNode,k.current.memoizedState.isDehydrated){var _=Ri(k.pendingLanes);if(_!==0){var V=k;for(V.pendingLanes|=2,V.entangledLanes|=2;_;){var ne=1<<31-nr(_);V.entanglements[1]|=ne,_&=~ne}ha(k),(Xt&6)===0&&(Kg=Ut()+500,Rp(0))}}break;case 31:case 13:V=Hl(k,2),V!==null&&wr(V,k,2),Qg(),Kv(k,2)}if(k=Qv(y),k===null&&zv(l,h,y,py,f),k===S)break;S=k}S!==null&&y.stopPropagation()}else zv(l,h,y,null,f)}}function Qv(l){return l=za(l),Zv(l)}var py=null;function Zv(l){if(py=null,l=bs(l),l!==null){var h=i(l);if(h===null)l=null;else{var f=h.tag;if(f===13){if(l=a(h),l!==null)return l;l=null}else if(f===31){if(l=o(h),l!==null)return l;l=null}else if(f===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;l=null}else h!==l&&(l=null)}}return py=l,null}function aI(l){switch(l){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(fr()){case Bs:return 2;case er:return 8;case tr:case na:return 32;case yo:return 268435456;default:return 32}default:return 32}}var Jv=!1,jo=null,qo=null,Xo=null,Lp=new Map,Mp=new Map,Ko=[],qM="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function oI(l,h){switch(l){case"focusin":case"focusout":jo=null;break;case"dragenter":case"dragleave":qo=null;break;case"mouseover":case"mouseout":Xo=null;break;case"pointerover":case"pointerout":Lp.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":Mp.delete(h.pointerId)}}function Pp(l,h,f,y,S,k){return l===null||l.nativeEvent!==k?(l={blockedOn:h,domEventName:f,eventSystemFlags:y,nativeEvent:k,targetContainers:[S]},h!==null&&(h=Ts(h),h!==null&&rI(h)),l):(l.eventSystemFlags|=y,h=l.targetContainers,S!==null&&h.indexOf(S)===-1&&h.push(S),l)}function XM(l,h,f,y,S){switch(h){case"focusin":return jo=Pp(jo,l,h,f,y,S),!0;case"dragenter":return qo=Pp(qo,l,h,f,y,S),!0;case"mouseover":return Xo=Pp(Xo,l,h,f,y,S),!0;case"pointerover":var k=S.pointerId;return Lp.set(k,Pp(Lp.get(k)||null,l,h,f,y,S)),!0;case"gotpointercapture":return k=S.pointerId,Mp.set(k,Pp(Mp.get(k)||null,l,h,f,y,S)),!0}return!1}function lI(l){var h=bs(l.target);if(h!==null){var f=i(h);if(f!==null){if(h=f.tag,h===13){if(h=a(f),h!==null){l.blockedOn=h,zr(l.priority,function(){iI(f)});return}}else if(h===31){if(h=o(f),h!==null){l.blockedOn=h,zr(l.priority,function(){iI(f)});return}}else if(h===3&&f.stateNode.current.memoizedState.isDehydrated){l.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}l.blockedOn=null}function fy(l){if(l.blockedOn!==null)return!1;for(var h=l.targetContainers;0<h.length;){var f=Qv(l.nativeEvent);if(f===null){f=l.nativeEvent;var y=new f.constructor(f.type,f);Ll=y,f.target.dispatchEvent(y),Ll=null}else return h=Ts(f),h!==null&&rI(h),l.blockedOn=f,!1;h.shift()}return!0}function uI(l,h,f){fy(l)&&f.delete(h)}function KM(){Jv=!1,jo!==null&&fy(jo)&&(jo=null),qo!==null&&fy(qo)&&(qo=null),Xo!==null&&fy(Xo)&&(Xo=null),Lp.forEach(uI),Mp.forEach(uI)}function my(l,h){l.blockedOn===h&&(l.blockedOn=null,Jv||(Jv=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,KM)))}var gy=null;function cI(l){gy!==l&&(gy=l,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){gy===l&&(gy=null);for(var h=0;h<l.length;h+=3){var f=l[h],y=l[h+1],S=l[h+2];if(typeof y!="function"){if(Zv(y||f)===null)continue;break}var k=Ts(f);k!==null&&(l.splice(h,3),h-=3,Q1(k,{pending:!0,data:S,method:f.method,action:y},y,S))}}))}function Hc(l){function h(ne){return my(ne,l)}jo!==null&&my(jo,l),qo!==null&&my(qo,l),Xo!==null&&my(Xo,l),Lp.forEach(h),Mp.forEach(h);for(var f=0;f<Ko.length;f++){var y=Ko[f];y.blockedOn===l&&(y.blockedOn=null)}for(;0<Ko.length&&(f=Ko[0],f.blockedOn===null);)lI(f),f.blockedOn===null&&Ko.shift();if(f=(l.ownerDocument||l).$$reactFormReplay,f!=null)for(y=0;y<f.length;y+=3){var S=f[y],k=f[y+1],_=S[cs]||null;if(typeof k=="function")_||cI(f);else if(_){var V=null;if(k&&k.hasAttribute("formAction")){if(S=k,_=k[cs]||null)V=_.formAction;else if(Zv(S)!==null)continue}else V=_.action;typeof V=="function"?f[y+1]=V:(f.splice(y,3),y-=3),cI(f)}}}function hI(){function l(k){k.canIntercept&&k.info==="react-transition"&&k.intercept({handler:function(){return new Promise(function(_){return S=_})},focusReset:"manual",scroll:"manual"})}function h(){S!==null&&(S(),S=null),y||setTimeout(f,20)}function f(){if(!y&&!navigation.transition){var k=navigation.currentEntry;k&&k.url!=null&&navigation.navigate(k.url,{state:k.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var y=!1,S=null;return navigation.addEventListener("navigate",l),navigation.addEventListener("navigatesuccess",h),navigation.addEventListener("navigateerror",h),setTimeout(f,100),function(){y=!0,navigation.removeEventListener("navigate",l),navigation.removeEventListener("navigatesuccess",h),navigation.removeEventListener("navigateerror",h),S!==null&&(S(),S=null)}}}function ew(l){this._internalRoot=l}yy.prototype.render=ew.prototype.render=function(l){var h=this._internalRoot;if(h===null)throw Error(s(409));var f=h.current,y=Gr();nI(f,y,l,h,null,null)},yy.prototype.unmount=ew.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var h=l.containerInfo;nI(l.current,2,null,l,null,null),Qg(),h[ia]=null}};function yy(l){this._internalRoot=l}yy.prototype.unstable_scheduleHydration=function(l){if(l){var h=Sn();l={blockedOn:null,target:l,priority:h};for(var f=0;f<Ko.length&&h!==0&&h<Ko[f].priority;f++);Ko.splice(f,0,l),f===0&&lI(l)}};var dI=e.version;if(dI!=="19.2.1")throw Error(s(527,dI,"19.2.1"));ee.findDOMNode=function(l){var h=l._reactInternals;if(h===void 0)throw typeof l.render=="function"?Error(s(188)):(l=Object.keys(l).join(","),Error(s(268,l)));return l=c(h),l=l!==null?d(l):null,l=l===null?null:l.stateNode,l};var YM={bundleType:0,version:"19.2.1",rendererPackageName:"react-dom",currentDispatcherRef:W,reconcilerVersion:"19.2.1"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var xy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!xy.isDisabled&&xy.supportsFiber)try{Vs=xy.inject(YM),ls=xy}catch{}}return Vp.createRoot=function(l,h){if(!r(l))throw Error(s(299));var f=!1,y="",S=bk,k=vk,_=wk;return h!=null&&(h.unstable_strictMode===!0&&(f=!0),h.identifierPrefix!==void 0&&(y=h.identifierPrefix),h.onUncaughtError!==void 0&&(S=h.onUncaughtError),h.onCaughtError!==void 0&&(k=h.onCaughtError),h.onRecoverableError!==void 0&&(_=h.onRecoverableError)),h=eI(l,1,!1,null,null,f,y,null,S,k,_,hI),l[ia]=h.current,Fv(l),new ew(h)},Vp.hydrateRoot=function(l,h,f){if(!r(l))throw Error(s(299));var y=!1,S="",k=bk,_=vk,V=wk,ne=null;return f!=null&&(f.unstable_strictMode===!0&&(y=!0),f.identifierPrefix!==void 0&&(S=f.identifierPrefix),f.onUncaughtError!==void 0&&(k=f.onUncaughtError),f.onCaughtError!==void 0&&(_=f.onCaughtError),f.onRecoverableError!==void 0&&(V=f.onRecoverableError),f.formState!==void 0&&(ne=f.formState)),h=eI(l,1,!0,h,f??null,y,S,ne,k,_,V,hI),h.context=tI(null),f=h.current,y=Gr(),y=Ai(y),S=Oo(y),S.callback=null,Fo(f,S,y),f=y,h.current.lanes=f,ra(h,f),ha(h),l[ia]=h.current,Fv(l),new yy(h)},Vp.version="19.2.1",Vp}var CI;function lP(){if(CI)return sw.exports;CI=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),sw.exports=oP(),sw.exports}var uP=lP();wR();function nf(){return nf=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(n[s]=t[s])}return n},nf.apply(this,arguments)}var Jo;(function(n){n.Pop="POP",n.Push="PUSH",n.Replace="REPLACE"})(Jo||(Jo={}));const NI="popstate";function cP(n){n===void 0&&(n={});function e(s,r){let{pathname:i,search:a,hash:o}=s.location;return Vw("",{pathname:i,search:a,hash:o},r.state&&r.state.usr||null,r.state&&r.state.key||"default")}function t(s,r){return typeof r=="string"?r:Ky(r)}return dP(e,t,null,n)}function Rn(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function X2(n,e){if(!n){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function hP(){return Math.random().toString(36).substr(2,8)}function kI(n,e){return{usr:n.state,key:n.key,idx:e}}function Vw(n,e,t,s){return t===void 0&&(t=null),nf({pathname:typeof n=="string"?n:n.pathname,search:"",hash:""},typeof e=="string"?Nh(e):e,{state:t,key:e&&e.key||s||hP()})}function Ky(n){let{pathname:e="/",search:t="",hash:s=""}=n;return t&&t!=="?"&&(e+=t.charAt(0)==="?"?t:"?"+t),s&&s!=="#"&&(e+=s.charAt(0)==="#"?s:"#"+s),e}function Nh(n){let e={};if(n){let t=n.indexOf("#");t>=0&&(e.hash=n.substr(t),n=n.substr(0,t));let s=n.indexOf("?");s>=0&&(e.search=n.substr(s),n=n.substr(0,s)),n&&(e.pathname=n)}return e}function dP(n,e,t,s){s===void 0&&(s={});let{window:r=document.defaultView,v5Compat:i=!1}=s,a=r.history,o=Jo.Pop,u=null,c=d();c==null&&(c=0,a.replaceState(nf({},a.state,{idx:c}),""));function d(){return(a.state||{idx:null}).idx}function p(){o=Jo.Pop;let v=d(),w=v==null?null:v-c;c=v,u&&u({action:o,location:b.location,delta:w})}function m(v,w){o=Jo.Push;let N=Vw(b.location,v,w);c=d()+1;let I=kI(N,c),$=b.createHref(N);try{a.pushState(I,"",$)}catch(E){if(E instanceof DOMException&&E.name==="DataCloneError")throw E;r.location.assign($)}i&&u&&u({action:o,location:b.location,delta:1})}function g(v,w){o=Jo.Replace;let N=Vw(b.location,v,w);c=d();let I=kI(N,c),$=b.createHref(N);a.replaceState(I,"",$),i&&u&&u({action:o,location:b.location,delta:0})}function x(v){let w=r.location.origin!=="null"?r.location.origin:r.location.href,N=typeof v=="string"?v:Ky(v);return N=N.replace(/ $/,"%20"),Rn(w,"No window.location.(origin|href) available to create URL for href: "+N),new URL(N,w)}let b={get action(){return o},get location(){return n(r,a)},listen(v){if(u)throw new Error("A history only accepts one active listener");return r.addEventListener(NI,p),u=v,()=>{r.removeEventListener(NI,p),u=null}},createHref(v){return e(r,v)},createURL:x,encodeLocation(v){let w=x(v);return{pathname:w.pathname,search:w.search,hash:w.hash}},push:m,replace:g,go(v){return a.go(v)}};return b}var $I;(function(n){n.data="data",n.deferred="deferred",n.redirect="redirect",n.error="error"})($I||($I={}));function pP(n,e,t){return t===void 0&&(t="/"),fP(n,e,t)}function fP(n,e,t,s){let r=typeof e=="string"?Nh(e):e,i=ch(r.pathname||"/",t);if(i==null)return null;let a=SR(n);mP(a);let o=null;for(let u=0;o==null&&u<a.length;++u){let c=$P(i);o=NP(a[u],c)}return o}function SR(n,e,t,s){e===void 0&&(e=[]),t===void 0&&(t=[]),s===void 0&&(s="");let r=(i,a,o)=>{let u={relativePath:o===void 0?i.path||"":o,caseSensitive:i.caseSensitive===!0,childrenIndex:a,route:i};u.relativePath.startsWith("/")&&(Rn(u.relativePath.startsWith(s),'Absolute route path "'+u.relativePath+'" nested under path '+('"'+s+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),u.relativePath=u.relativePath.slice(s.length));let c=rl([s,u.relativePath]),d=t.concat(u);i.children&&i.children.length>0&&(Rn(i.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+c+'".')),SR(i.children,e,d,c)),!(i.path==null&&!i.index)&&e.push({path:c,score:SP(c,i.index),routesMeta:d})};return n.forEach((i,a)=>{var o;if(i.path===""||!((o=i.path)!=null&&o.includes("?")))r(i,a);else for(let u of CR(i.path))r(i,a,u)}),e}function CR(n){let e=n.split("/");if(e.length===0)return[];let[t,...s]=e,r=t.endsWith("?"),i=t.replace(/\?$/,"");if(s.length===0)return r?[i,""]:[i];let a=CR(s.join("/")),o=[];return o.push(...a.map(u=>u===""?i:[i,u].join("/"))),r&&o.push(...a),o.map(u=>n.startsWith("/")&&u===""?"/":u)}function mP(n){n.sort((e,t)=>e.score!==t.score?t.score-e.score:CP(e.routesMeta.map(s=>s.childrenIndex),t.routesMeta.map(s=>s.childrenIndex)))}const gP=/^:[\w-]+$/,yP=3,xP=2,bP=1,vP=10,wP=-2,II=n=>n==="*";function SP(n,e){let t=n.split("/"),s=t.length;return t.some(II)&&(s+=wP),e&&(s+=xP),t.filter(r=>!II(r)).reduce((r,i)=>r+(gP.test(i)?yP:i===""?bP:vP),s)}function CP(n,e){return n.length===e.length&&n.slice(0,-1).every((s,r)=>s===e[r])?n[n.length-1]-e[e.length-1]:0}function NP(n,e,t){let{routesMeta:s}=n,r={},i="/",a=[];for(let o=0;o<s.length;++o){let u=s[o],c=o===s.length-1,d=i==="/"?e:e.slice(i.length)||"/",p=Uw({path:u.relativePath,caseSensitive:u.caseSensitive,end:c},d),m=u.route;if(!p)return null;Object.assign(r,p.params),a.push({params:r,pathname:rl([i,p.pathname]),pathnameBase:AP(rl([i,p.pathnameBase])),route:m}),p.pathnameBase!=="/"&&(i=rl([i,p.pathnameBase]))}return a}function Uw(n,e){typeof n=="string"&&(n={path:n,caseSensitive:!1,end:!0});let[t,s]=kP(n.path,n.caseSensitive,n.end),r=e.match(t);if(!r)return null;let i=r[0],a=i.replace(/(.)\/+$/,"$1"),o=r.slice(1);return{params:s.reduce((c,d,p)=>{let{paramName:m,isOptional:g}=d;if(m==="*"){let b=o[p]||"";a=i.slice(0,i.length-b.length).replace(/(.)\/+$/,"$1")}const x=o[p];return g&&!x?c[m]=void 0:c[m]=(x||"").replace(/%2F/g,"/"),c},{}),pathname:i,pathnameBase:a,pattern:n}}function kP(n,e,t){e===void 0&&(e=!1),t===void 0&&(t=!0),X2(n==="*"||!n.endsWith("*")||n.endsWith("/*"),'Route path "'+n+'" will be treated as if it were '+('"'+n.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+n.replace(/\*$/,"/*")+'".'));let s=[],r="^"+n.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(a,o,u)=>(s.push({paramName:o,isOptional:u!=null}),u?"/?([^\\/]+)?":"/([^\\/]+)"));return n.endsWith("*")?(s.push({paramName:"*"}),r+=n==="*"||n==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?r+="\\/*$":n!==""&&n!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,e?void 0:"i"),s]}function $P(n){try{return n.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return X2(!1,'The URL path "'+n+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+e+").")),n}}function ch(n,e){if(e==="/")return n;if(!n.toLowerCase().startsWith(e.toLowerCase()))return null;let t=e.endsWith("/")?e.length-1:e.length,s=n.charAt(t);return s&&s!=="/"?null:n.slice(t)||"/"}const IP=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,TP=n=>IP.test(n);function EP(n,e){e===void 0&&(e="/");let{pathname:t,search:s="",hash:r=""}=typeof n=="string"?Nh(n):n,i;if(t)if(TP(t))i=t;else{if(t.includes("//")){let a=t;t=t.replace(/\/\/+/g,"/"),X2(!1,"Pathnames cannot have embedded double slashes - normalizing "+(a+" -> "+t))}t.startsWith("/")?i=TI(t.substring(1),"/"):i=TI(t,e)}else i=e;return{pathname:i,search:DP(s),hash:_P(r)}}function TI(n,e){let t=e.replace(/\/+$/,"").split("/");return n.split("/").forEach(r=>{r===".."?t.length>1&&t.pop():r!=="."&&t.push(r)}),t.length>1?t.join("/"):"/"}function ow(n,e,t,s){return"Cannot include a '"+n+"' character in a manually specified "+("`to."+e+"` field ["+JSON.stringify(s)+"].  Please separate it out to the ")+("`to."+t+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function RP(n){return n.filter((e,t)=>t===0||e.route.path&&e.route.path.length>0)}function K2(n,e){let t=RP(n);return e?t.map((s,r)=>r===t.length-1?s.pathname:s.pathnameBase):t.map(s=>s.pathnameBase)}function Y2(n,e,t,s){s===void 0&&(s=!1);let r;typeof n=="string"?r=Nh(n):(r=nf({},n),Rn(!r.pathname||!r.pathname.includes("?"),ow("?","pathname","search",r)),Rn(!r.pathname||!r.pathname.includes("#"),ow("#","pathname","hash",r)),Rn(!r.search||!r.search.includes("#"),ow("#","search","hash",r)));let i=n===""||r.pathname==="",a=i?"/":r.pathname,o;if(a==null)o=t;else{let p=e.length-1;if(!s&&a.startsWith("..")){let m=a.split("/");for(;m[0]==="..";)m.shift(),p-=1;r.pathname=m.join("/")}o=p>=0?e[p]:"/"}let u=EP(r,o),c=a&&a!=="/"&&a.endsWith("/"),d=(i||a===".")&&t.endsWith("/");return!u.pathname.endsWith("/")&&(c||d)&&(u.pathname+="/"),u}const rl=n=>n.join("/").replace(/\/\/+/g,"/"),AP=n=>n.replace(/\/+$/,"").replace(/^\/*/,"/"),DP=n=>!n||n==="?"?"":n.startsWith("?")?n:"?"+n,_P=n=>!n||n==="#"?"":n.startsWith("#")?n:"#"+n;function OP(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.internal=="boolean"&&"data"in n}const NR=["post","put","patch","delete"];new Set(NR);const FP=["get",...NR];new Set(FP);function sf(){return sf=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(n[s]=t[s])}return n},sf.apply(this,arguments)}const Dx=Re.createContext(null),kR=Re.createContext(null),ho=Re.createContext(null),_x=Re.createContext(null),bl=Re.createContext({outlet:null,matches:[],isDataRoute:!1}),$R=Re.createContext(null);function zP(n,e){let{relative:t}=e===void 0?{}:e;kh()||Rn(!1);let{basename:s,navigator:r}=Re.useContext(ho),{hash:i,pathname:a,search:o}=Ox(n,{relative:t}),u=a;return s!=="/"&&(u=a==="/"?s:rl([s,a])),r.createHref({pathname:u,search:o,hash:i})}function kh(){return Re.useContext(_x)!=null}function Lu(){return kh()||Rn(!1),Re.useContext(_x).location}function IR(n){Re.useContext(ho).static||Re.useLayoutEffect(n)}function TR(){let{isDataRoute:n}=Re.useContext(bl);return n?KP():LP()}function LP(){kh()||Rn(!1);let n=Re.useContext(Dx),{basename:e,future:t,navigator:s}=Re.useContext(ho),{matches:r}=Re.useContext(bl),{pathname:i}=Lu(),a=JSON.stringify(K2(r,t.v7_relativeSplatPath)),o=Re.useRef(!1);return IR(()=>{o.current=!0}),Re.useCallback(function(c,d){if(d===void 0&&(d={}),!o.current)return;if(typeof c=="number"){s.go(c);return}let p=Y2(c,JSON.parse(a),i,d.relative==="path");n==null&&e!=="/"&&(p.pathname=p.pathname==="/"?e:rl([e,p.pathname])),(d.replace?s.replace:s.push)(p,d.state,d)},[e,s,a,i,n])}function Ox(n,e){let{relative:t}=e===void 0?{}:e,{future:s}=Re.useContext(ho),{matches:r}=Re.useContext(bl),{pathname:i}=Lu(),a=JSON.stringify(K2(r,s.v7_relativeSplatPath));return Re.useMemo(()=>Y2(n,JSON.parse(a),i,t==="path"),[n,a,i,t])}function MP(n,e){return PP(n,e)}function PP(n,e,t,s){kh()||Rn(!1);let{navigator:r}=Re.useContext(ho),{matches:i}=Re.useContext(bl),a=i[i.length-1],o=a?a.params:{};a&&a.pathname;let u=a?a.pathnameBase:"/";a&&a.route;let c=Lu(),d;if(e){var p;let v=typeof e=="string"?Nh(e):e;u==="/"||(p=v.pathname)!=null&&p.startsWith(u)||Rn(!1),d=v}else d=c;let m=d.pathname||"/",g=m;if(u!=="/"){let v=u.replace(/^\//,"").split("/");g="/"+m.replace(/^\//,"").split("/").slice(v.length).join("/")}let x=pP(n,{pathname:g}),b=GP(x&&x.map(v=>Object.assign({},v,{params:Object.assign({},o,v.params),pathname:rl([u,r.encodeLocation?r.encodeLocation(v.pathname).pathname:v.pathname]),pathnameBase:v.pathnameBase==="/"?u:rl([u,r.encodeLocation?r.encodeLocation(v.pathnameBase).pathname:v.pathnameBase])})),i,t,s);return e&&b?Re.createElement(_x.Provider,{value:{location:sf({pathname:"/",search:"",hash:"",state:null,key:"default"},d),navigationType:Jo.Pop}},b):b}function BP(){let n=XP(),e=OP(n)?n.status+" "+n.statusText:n instanceof Error?n.message:JSON.stringify(n),t=n instanceof Error?n.stack:null,r={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return Re.createElement(Re.Fragment,null,Re.createElement("h2",null,"Unexpected Application Error!"),Re.createElement("h3",{style:{fontStyle:"italic"}},e),t?Re.createElement("pre",{style:r},t):null,null)}const VP=Re.createElement(BP,null);class UP extends Re.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||t.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return this.state.error!==void 0?Re.createElement(bl.Provider,{value:this.props.routeContext},Re.createElement($R.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function WP(n){let{routeContext:e,match:t,children:s}=n,r=Re.useContext(Dx);return r&&r.static&&r.staticContext&&(t.route.errorElement||t.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=t.route.id),Re.createElement(bl.Provider,{value:e},s)}function GP(n,e,t,s){var r;if(e===void 0&&(e=[]),t===void 0&&(t=null),s===void 0&&(s=null),n==null){var i;if(!t)return null;if(t.errors)n=t.matches;else if((i=s)!=null&&i.v7_partialHydration&&e.length===0&&!t.initialized&&t.matches.length>0)n=t.matches;else return null}let a=n,o=(r=t)==null?void 0:r.errors;if(o!=null){let d=a.findIndex(p=>p.route.id&&o?.[p.route.id]!==void 0);d>=0||Rn(!1),a=a.slice(0,Math.min(a.length,d+1))}let u=!1,c=-1;if(t&&s&&s.v7_partialHydration)for(let d=0;d<a.length;d++){let p=a[d];if((p.route.HydrateFallback||p.route.hydrateFallbackElement)&&(c=d),p.route.id){let{loaderData:m,errors:g}=t,x=p.route.loader&&m[p.route.id]===void 0&&(!g||g[p.route.id]===void 0);if(p.route.lazy||x){u=!0,c>=0?a=a.slice(0,c+1):a=[a[0]];break}}}return a.reduceRight((d,p,m)=>{let g,x=!1,b=null,v=null;t&&(g=o&&p.route.id?o[p.route.id]:void 0,b=p.route.errorElement||VP,u&&(c<0&&m===0?(YP("route-fallback"),x=!0,v=null):c===m&&(x=!0,v=p.route.hydrateFallbackElement||null)));let w=e.concat(a.slice(0,m+1)),N=()=>{let I;return g?I=b:x?I=v:p.route.Component?I=Re.createElement(p.route.Component,null):p.route.element?I=p.route.element:I=d,Re.createElement(WP,{match:p,routeContext:{outlet:d,matches:w,isDataRoute:t!=null},children:I})};return t&&(p.route.ErrorBoundary||p.route.errorElement||m===0)?Re.createElement(UP,{location:t.location,revalidation:t.revalidation,component:b,error:g,children:N(),routeContext:{outlet:null,matches:w,isDataRoute:!0}}):N()},null)}var ER=(function(n){return n.UseBlocker="useBlocker",n.UseRevalidator="useRevalidator",n.UseNavigateStable="useNavigate",n})(ER||{}),RR=(function(n){return n.UseBlocker="useBlocker",n.UseLoaderData="useLoaderData",n.UseActionData="useActionData",n.UseRouteError="useRouteError",n.UseNavigation="useNavigation",n.UseRouteLoaderData="useRouteLoaderData",n.UseMatches="useMatches",n.UseRevalidator="useRevalidator",n.UseNavigateStable="useNavigate",n.UseRouteId="useRouteId",n})(RR||{});function HP(n){let e=Re.useContext(Dx);return e||Rn(!1),e}function jP(n){let e=Re.useContext(kR);return e||Rn(!1),e}function qP(n){let e=Re.useContext(bl);return e||Rn(!1),e}function AR(n){let e=qP(),t=e.matches[e.matches.length-1];return t.route.id||Rn(!1),t.route.id}function XP(){var n;let e=Re.useContext($R),t=jP(),s=AR();return e!==void 0?e:(n=t.errors)==null?void 0:n[s]}function KP(){let{router:n}=HP(ER.UseNavigateStable),e=AR(RR.UseNavigateStable),t=Re.useRef(!1);return IR(()=>{t.current=!0}),Re.useCallback(function(r,i){i===void 0&&(i={}),t.current&&(typeof r=="number"?n.navigate(r):n.navigate(r,sf({fromRouteId:e},i)))},[n,e])}const EI={};function YP(n,e,t){EI[n]||(EI[n]=!0)}function QP(n,e){n?.v7_startTransition,n?.v7_relativeSplatPath}function ZP(n){let{to:e,replace:t,state:s,relative:r}=n;kh()||Rn(!1);let{future:i,static:a}=Re.useContext(ho),{matches:o}=Re.useContext(bl),{pathname:u}=Lu(),c=TR(),d=Y2(e,K2(o,i.v7_relativeSplatPath),u,r==="path"),p=JSON.stringify(d);return Re.useEffect(()=>c(JSON.parse(p),{replace:t,state:s,relative:r}),[c,p,r,t,s]),null}function Qo(n){Rn(!1)}function JP(n){let{basename:e="/",children:t=null,location:s,navigationType:r=Jo.Pop,navigator:i,static:a=!1,future:o}=n;kh()&&Rn(!1);let u=e.replace(/^\/*/,"/"),c=Re.useMemo(()=>({basename:u,navigator:i,static:a,future:sf({v7_relativeSplatPath:!1},o)}),[u,o,i,a]);typeof s=="string"&&(s=Nh(s));let{pathname:d="/",search:p="",hash:m="",state:g=null,key:x="default"}=s,b=Re.useMemo(()=>{let v=ch(d,u);return v==null?null:{location:{pathname:v,search:p,hash:m,state:g,key:x},navigationType:r}},[u,d,p,m,g,x,r]);return b==null?null:Re.createElement(ho.Provider,{value:c},Re.createElement(_x.Provider,{children:t,value:b}))}function eB(n){let{children:e,location:t}=n;return MP(Ww(e),t)}new Promise(()=>{});function Ww(n,e){e===void 0&&(e=[]);let t=[];return Re.Children.forEach(n,(s,r)=>{if(!Re.isValidElement(s))return;let i=[...e,r];if(s.type===Re.Fragment){t.push.apply(t,Ww(s.props.children,i));return}s.type!==Qo&&Rn(!1),!s.props.index||!s.props.children||Rn(!1);let a={id:s.props.id||i.join("-"),caseSensitive:s.props.caseSensitive,element:s.props.element,Component:s.props.Component,index:s.props.index,path:s.props.path,loader:s.props.loader,action:s.props.action,errorElement:s.props.errorElement,ErrorBoundary:s.props.ErrorBoundary,hasErrorBoundary:s.props.ErrorBoundary!=null||s.props.errorElement!=null,shouldRevalidate:s.props.shouldRevalidate,handle:s.props.handle,lazy:s.props.lazy};s.props.children&&(a.children=Ww(s.props.children,i)),t.push(a)}),t}function Yy(){return Yy=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(n[s]=t[s])}return n},Yy.apply(this,arguments)}function DR(n,e){if(n==null)return{};var t={},s=Object.keys(n),r,i;for(i=0;i<s.length;i++)r=s[i],!(e.indexOf(r)>=0)&&(t[r]=n[r]);return t}function tB(n){return!!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)}function nB(n,e){return n.button===0&&(!e||e==="_self")&&!tB(n)}const sB=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],rB=["aria-current","caseSensitive","className","end","style","to","viewTransition","children"],iB="6";try{window.__reactRouterVersion=iB}catch{}const aB=Re.createContext({isTransitioning:!1}),oB="startTransition",RI=sP[oB];function lB(n){let{basename:e,children:t,future:s,window:r}=n,i=Re.useRef();i.current==null&&(i.current=cP({window:r,v5Compat:!0}));let a=i.current,[o,u]=Re.useState({action:a.action,location:a.location}),{v7_startTransition:c}=s||{},d=Re.useCallback(p=>{c&&RI?RI(()=>u(p)):u(p)},[u,c]);return Re.useLayoutEffect(()=>a.listen(d),[a,d]),Re.useEffect(()=>QP(s),[s]),Re.createElement(JP,{basename:e,children:t,location:o.location,navigationType:o.action,navigator:a,future:s})}const uB=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",cB=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Gw=Re.forwardRef(function(e,t){let{onClick:s,relative:r,reloadDocument:i,replace:a,state:o,target:u,to:c,preventScrollReset:d,viewTransition:p}=e,m=DR(e,sB),{basename:g}=Re.useContext(ho),x,b=!1;if(typeof c=="string"&&cB.test(c)&&(x=c,uB))try{let I=new URL(window.location.href),$=c.startsWith("//")?new URL(I.protocol+c):new URL(c),E=ch($.pathname,g);$.origin===I.origin&&E!=null?c=E+$.search+$.hash:b=!0}catch{}let v=zP(c,{relative:r}),w=dB(c,{replace:a,state:o,target:u,preventScrollReset:d,relative:r,viewTransition:p});function N(I){s&&s(I),I.defaultPrevented||w(I)}return Re.createElement("a",Yy({},m,{href:x||v,onClick:b||i?s:N,ref:t,target:u}))}),pi=Re.forwardRef(function(e,t){let{"aria-current":s="page",caseSensitive:r=!1,className:i="",end:a=!1,style:o,to:u,viewTransition:c,children:d}=e,p=DR(e,rB),m=Ox(u,{relative:p.relative}),g=Lu(),x=Re.useContext(kR),{navigator:b,basename:v}=Re.useContext(ho),w=x!=null&&pB(m)&&c===!0,N=b.encodeLocation?b.encodeLocation(m).pathname:m.pathname,I=g.pathname,$=x&&x.navigation&&x.navigation.location?x.navigation.location.pathname:null;r||(I=I.toLowerCase(),$=$?$.toLowerCase():null,N=N.toLowerCase()),$&&v&&($=ch($,v)||$);const E=N!=="/"&&N.endsWith("/")?N.length-1:N.length;let D=I===N||!a&&I.startsWith(N)&&I.charAt(E)==="/",F=$!=null&&($===N||!a&&$.startsWith(N)&&$.charAt(N.length)==="/"),L={isActive:D,isPending:F,isTransitioning:w},z=D?s:void 0,M;typeof i=="function"?M=i(L):M=[i,D?"active":null,F?"pending":null,w?"transitioning":null].filter(Boolean).join(" ");let O=typeof o=="function"?o(L):o;return Re.createElement(Gw,Yy({},p,{"aria-current":z,className:M,ref:t,style:O,to:u,viewTransition:c}),typeof d=="function"?d(L):d)});var Hw;(function(n){n.UseScrollRestoration="useScrollRestoration",n.UseSubmit="useSubmit",n.UseSubmitFetcher="useSubmitFetcher",n.UseFetcher="useFetcher",n.useViewTransitionState="useViewTransitionState"})(Hw||(Hw={}));var AI;(function(n){n.UseFetcher="useFetcher",n.UseFetchers="useFetchers",n.UseScrollRestoration="useScrollRestoration"})(AI||(AI={}));function hB(n){let e=Re.useContext(Dx);return e||Rn(!1),e}function dB(n,e){let{target:t,replace:s,state:r,preventScrollReset:i,relative:a,viewTransition:o}=e===void 0?{}:e,u=TR(),c=Lu(),d=Ox(n,{relative:a});return Re.useCallback(p=>{if(nB(p,t)){p.preventDefault();let m=s!==void 0?s:Ky(c)===Ky(d);u(n,{replace:m,state:r,preventScrollReset:i,relative:a,viewTransition:o})}},[c,u,d,s,r,t,n,i,a,o])}function pB(n,e){e===void 0&&(e={});let t=Re.useContext(aB);t==null&&Rn(!1);let{basename:s}=hB(Hw.useViewTransitionState),r=Ox(n,{relative:e.relative});if(!t.isTransitioning)return!1;let i=ch(t.currentLocation.pathname,s)||t.currentLocation.pathname,a=ch(t.nextLocation.pathname,s)||t.nextLocation.pathname;return Uw(r.pathname,a)!=null||Uw(r.pathname,i)!=null}function fB(){return q.jsxs("div",{className:"space-y-12",children:[q.jsxs("section",{className:"grid items-center gap-10 rounded-3xl bg-white p-8 shadow-card md:grid-cols-2",children:[q.jsxs("div",{className:"space-y-6",children:[q.jsx("p",{className:"inline-flex items-center gap-2 rounded-full bg-blue-50 px-4 py-2 text-sm font-semibold text-blue-700",children:"  -   "}),q.jsx("h1",{className:"text-3xl font-bold leading-relaxed text-slate-900 md:text-4xl",children:"              ."}),q.jsx("p",{className:"text-lg text-slate-600",children:"                     ."}),q.jsxs("div",{className:"flex flex-wrap gap-3",children:[q.jsx(Gw,{to:"/translation",className:"rounded-full bg-primary px-5 py-3 text-sm font-semibold text-white shadow-md shadow-blue-200 transition hover:bg-blue-700",children:" "}),q.jsx(Gw,{to:"/learning",className:"rounded-full border border-slate-200 px-5 py-3 text-sm font-semibold text-slate-800 transition hover:bg-slate-100",children:"  "})]})]}),q.jsxs("div",{className:"relative",children:[q.jsx("div",{className:"absolute inset-0 -z-10 rounded-3xl bg-gradient-to-br from-blue-100 via-cyan-100 to-white blur-2xl"}),q.jsxs("div",{className:"flex flex-col gap-4 rounded-2xl bg-white/90 p-6 shadow-card",children:[q.jsx("p",{className:"text-sm font-semibold text-blue-600",children:"  "}),q.jsxs("div",{className:"space-y-3 text-slate-700",children:[q.jsxs("div",{className:"flex items-center gap-3 rounded-xl border border-blue-100 bg-blue-50 px-4 py-3",children:[q.jsx("span",{className:"flex h-10 w-10 items-center justify-center rounded-full bg-white font-bold text-blue-600",children:"1"}),q.jsxs("div",{children:[q.jsx("p",{className:"font-semibold",children:"  "}),q.jsx("p",{className:"text-sm text-slate-500",children:"    ."})]})]}),q.jsxs("div",{className:"flex items-center gap-3 rounded-xl border border-cyan-100 bg-cyan-50 px-4 py-3",children:[q.jsx("span",{className:"flex h-10 w-10 items-center justify-center rounded-full bg-white font-bold text-cyan-600",children:"2"}),q.jsxs("div",{children:[q.jsx("p",{className:"font-semibold",children:" "}),q.jsx("p",{className:"text-sm text-slate-500",children:"    ."})]})]}),q.jsxs("div",{className:"flex items-center gap-3 rounded-xl border border-emerald-100 bg-emerald-50 px-4 py-3",children:[q.jsx("span",{className:"flex h-10 w-10 items-center justify-center rounded-full bg-white font-bold text-emerald-600",children:"3"}),q.jsxs("div",{children:[q.jsx("p",{className:"font-semibold",children:"  "}),q.jsx("p",{className:"text-sm text-slate-500",children:"     ."})]})]})]})]})]})]}),q.jsxs("section",{className:"grid gap-6 md:grid-cols-3",children:[q.jsx(lw,{title:"    ",description:"          .",accent:"bg-blue-500"}),q.jsx(lw,{title:"  ",description:"          .",accent:"bg-emerald-500"}),q.jsx(lw,{title:"  ",description:"       .",accent:"bg-cyan-500"})]})]})}function lw({title:n,description:e,accent:t}){return q.jsxs("div",{className:"rounded-2xl border border-slate-200 bg-white p-6 shadow-card",children:[q.jsx("span",{className:`mb-3 inline-flex h-10 w-10 items-center justify-center rounded-xl ${t} text-white`,children:""}),q.jsx("h3",{className:"text-lg font-semibold text-slate-900",children:n}),q.jsx("p",{className:"mt-2 text-sm leading-relaxed text-slate-600",children:e})]})}const _R={:"https://mock-video-url/signs/hello.mp4",:"https://mock-video-url/signs/how.mp4",:"https://mock-video-url/signs/state.mp4",:"https://mock-video-url/signs/today.mp4",:"https://mock-video-url/signs/thanks.mp4",:"https://mock-video-url/signs/yes.mp4",:"https://mock-video-url/signs/no.mp4",:"https://mock-video-url/signs/where.mp4",:"https://mock-video-url/signs/when.mp4",:"https://mock-video-url/signs/help.mp4",:"https://mock-video-url/signs/learn.mp4",:"https://mock-video-url/signs/language.mp4",:"https://mock-video-url/signs/sign.mp4",:"https://mock-video-url/signs/see-you.mp4",:"https://mock-video-url/signs/friend.mp4"},mB=[{letter:"",videoUrl:"https://mock-video-url/alphabet/alif.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/baa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/taa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/thaa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/jeem.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/haa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/khaa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/dal.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/thaal.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/raa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/zaay.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/seen.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/sheen.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/sad.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/dad.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/taa2.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/thaa2.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/ain.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/ghain.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/faa.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/qaaf.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/kaaf.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/laam.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/meem.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/noon.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/haa2.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/waaw.mp4"},{letter:"",videoUrl:"https://mock-video-url/alphabet/yaa.mp4"}],gB=[{number:"1",videoUrl:"https://mock-video-url/numbers/1.mp4"},{number:"2",videoUrl:"https://mock-video-url/numbers/2.mp4"},{number:"3",videoUrl:"https://mock-video-url/numbers/3.mp4"},{number:"4",videoUrl:"https://mock-video-url/numbers/4.mp4"},{number:"5",videoUrl:"https://mock-video-url/numbers/5.mp4"},{number:"6",videoUrl:"https://mock-video-url/numbers/6.mp4"},{number:"7",videoUrl:"https://mock-video-url/numbers/7.mp4"},{number:"8",videoUrl:"https://mock-video-url/numbers/8.mp4"},{number:"9",videoUrl:"https://mock-video-url/numbers/9.mp4"},{number:"10",videoUrl:"https://mock-video-url/numbers/10.mp4"}],DI="   ";function yB(){const[n,e]=Re.useState(""),[t,s]=Re.useState([]),[r,i]=Re.useState(""),a=u=>{const c=u.trim();if(!c){s([]),i("");return}const p=c.split(/\s+/).map(m=>({word:m,videoUrl:_R[m]}));s(p),i("  .")};Re.useEffect(()=>{const u=setTimeout(()=>{n.trim()?a(n):(s([]),i(""))},600);return()=>clearTimeout(u)},[n]);const o=()=>{i(" ..."),setTimeout(()=>{e(DI),a(DI),i("    .")},800)};return q.jsxs("div",{className:"space-y-8",children:[q.jsxs("div",{className:"rounded-3xl bg-white p-8 shadow-card",children:[q.jsxs("div",{className:"flex flex-wrap items-start justify-between gap-4",children:[q.jsxs("div",{children:[q.jsx("p",{className:"text-sm font-semibold text-blue-600",children:"    "}),q.jsx("h2",{className:"mt-1 text-2xl font-bold text-slate-900",children:"      "}),q.jsx("p",{className:"mt-2 text-sm text-slate-600",children:"           ."})]}),r&&q.jsx("span",{className:"rounded-full bg-slate-100 px-4 py-2 text-xs font-semibold text-slate-700",children:r})]}),q.jsxs("div",{className:"mt-6 space-y-3",children:[q.jsx("textarea",{className:"w-full min-h-[140px] rounded-2xl border border-slate-200 bg-slate-50/60 p-4 text-base text-slate-900 shadow-inner focus:border-primary focus:bg-white focus:outline-none",placeholder:"     ...",value:n,onChange:u=>e(u.target.value)}),q.jsxs("div",{className:"flex flex-wrap gap-3",children:[q.jsx("button",{onClick:()=>a(n),className:"rounded-full bg-primary px-5 py-3 text-sm font-semibold text-white shadow-md shadow-blue-200 transition hover:bg-blue-700",children:" "}),q.jsx("button",{onClick:o,className:"rounded-full border border-slate-200 px-5 py-3 text-sm font-semibold text-slate-800 transition hover:bg-slate-100",children:"  ()"}),q.jsx("button",{onClick:()=>{e(""),s([]),i("")},className:"rounded-full border border-rose-100 bg-rose-50 px-4 py-2 text-xs font-semibold text-rose-600 transition hover:bg-rose-100",children:" "})]})]})]}),q.jsxs("div",{className:"rounded-3xl bg-white p-8 shadow-card",children:[q.jsxs("div",{className:"flex items-center justify-between gap-4",children:[q.jsx("h3",{className:"text-xl font-bold text-slate-900",children:" "}),q.jsx("p",{className:"text-sm text-slate-500",children:"         ."})]}),t.length?q.jsx("div",{className:"mt-6 grid gap-4 md:grid-cols-3",children:t.map(({word:u,videoUrl:c},d)=>q.jsxs("div",{className:"flex flex-col gap-3 rounded-2xl border border-slate-200 bg-slate-50/70 p-4 shadow-sm",children:[q.jsxs("div",{className:"flex items-center justify-between",children:[q.jsx("p",{className:"text-base font-semibold text-slate-900",children:u}),q.jsx("span",{className:"rounded-full bg-white px-3 py-1 text-xs font-semibold text-slate-500 shadow-inner",children:""})]}),c?q.jsx("video",{src:c,controls:!0,className:"aspect-video w-full overflow-hidden rounded-xl border border-slate-200 bg-black/5",children:"    "},c):q.jsx("div",{className:"flex aspect-video items-center justify-center rounded-xl border border-dashed border-slate-300 bg-white text-sm font-semibold text-slate-400",children:"    "})]},`${u}-${d}`))}):q.jsx("div",{className:"mt-6 rounded-2xl border border-dashed border-slate-200 bg-slate-50 px-4 py-10 text-center text-slate-500",children:"       ."})]})]})}const xB=[{id:"letters",title:" ",desc:"    .",color:"from-blue-500 to-cyan-500"},{id:"numbers",title:"",desc:"      .",color:"from-emerald-500 to-teal-400"},{id:"words",title:" ",desc:"    .",color:"from-indigo-500 to-purple-500"},{id:"apps",title:" ",desc:"     .",color:"from-orange-500 to-amber-400"}],bB=[{label:"",videoUrl:"https://mock-video-url/apps/whatsapp.mp4",type:""},{label:"",videoUrl:"https://mock-video-url/apps/youtube.mp4",type:""},{label:" ",videoUrl:"https://mock-video-url/apps/tiktok.mp4",type:""},{label:"",videoUrl:"https://mock-video-url/apps/instagram.mp4",type:""}];function vB(){const[n,e]=Re.useState("letters"),[t,s]=Re.useState(null),[r,i]=Re.useState({current:20,total:100}),[a,o]=Re.useState([{id:"alpha",label:" ",unlocked:!0,icon:"",tip:"  10 ."},{id:"numbers",label:" ",unlocked:!1,icon:"",tip:"  ."}]),[u,c]=Re.useState({target:5,done:0,status:" "}),[d,p]=Re.useState(null),[m,g]=Re.useState(!1),x=Re.useMemo(()=>Object.entries(_R).map(([N,I])=>({label:N,videoUrl:I,type:""})),[]),b={letters:mB.map(N=>({...N,label:N.letter,type:""})),numbers:gB.map(N=>({...N,label:N.number,type:""})),words:x,apps:bB},v=N=>{s(N),g(!0),p(" !    "),i(I=>{const $=Math.min(I.total,I.current+2);return{...I,current:$}}),o(I=>I.map($=>$.id==="numbers"&&n==="numbers"&&r.current+2>=r.total?{...$,unlocked:!0}:$)),c(I=>{const $=Math.min(I.target,I.done+1),E=$>=I.target?"!   .":"  .";return{...I,done:$,status:E}}),setTimeout(()=>p(null),1800)},w=()=>{c({target:5,done:0,status:"  !"})};return q.jsxs("div",{className:"space-y-6",children:[q.jsxs("header",{className:"flex flex-col gap-3 rounded-3xl bg-white p-6 shadow-card md:flex-row md:items-center md:justify-between",children:[q.jsxs("div",{children:[q.jsx("p",{className:"text-sm font-semibold text-blue-600",children:"  "}),q.jsx("h1",{className:"text-2xl font-bold text-slate-900",children:"   "}),q.jsx("p",{className:"text-sm text-slate-600",children:"  +     ."})]}),q.jsx(wB,{progress:r})]}),q.jsx("div",{className:"grid gap-4 md:grid-cols-2 lg:grid-cols-4",children:xB.map(N=>q.jsxs("button",{onClick:()=>e(N.id),className:`relative overflow-hidden rounded-2xl border border-slate-200 bg-white p-5 text-right shadow-card transition hover:-translate-y-1 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-primary/40 ${n===N.id?"ring-2 ring-primary/50":""}`,children:[q.jsx("div",{className:`absolute inset-0 opacity-90 bg-gradient-to-br ${N.color}`}),q.jsxs("div",{className:"relative space-y-2 text-white drop-shadow-md",children:[q.jsx("span",{className:"text-sm font-semibold",children:" "}),q.jsx("h3",{className:"text-lg font-bold",children:N.title}),q.jsx("p",{className:"text-sm text-white/80",children:N.desc})]})]},N.id))}),q.jsxs("div",{className:"grid gap-4 lg:grid-cols-3",children:[q.jsx("div",{className:"lg:col-span-2 space-y-4",children:q.jsx(SB,{title:" ",description:"     .",items:b[n],onSelect:v})}),q.jsxs("div",{className:"space-y-4",children:[q.jsx(CB,{badges:a}),q.jsx(NB,{daily:u,onStart:w}),d?q.jsx(kB,{message:d}):null]})]}),m&&t?q.jsx($B,{onClose:()=>g(!1),children:q.jsxs("div",{className:"space-y-3",children:[q.jsxs("div",{className:"flex items-center justify-between",children:[q.jsxs("div",{children:[q.jsx("p",{className:"text-sm text-slate-500",children:" "}),q.jsxs("h3",{className:"text-xl font-bold text-slate-900",children:[t.label," ",q.jsxs("span",{className:"text-sm text-slate-500",children:["(",t.type,")"]})]})]}),q.jsx("span",{className:"rounded-full bg-blue-50 px-3 py-1 text-xs font-semibold text-blue-700",children:""})]}),q.jsx("video",{src:t.videoUrl,controls:!0,className:"aspect-video w-full overflow-hidden rounded-xl border border-slate-200 bg-black/5",children:"    "},t.videoUrl),q.jsx("p",{className:"text-sm text-slate-600",children:"    ."})]})}):null]})}function wB({progress:n}){const e=Math.round(n.current/n.total*100);return q.jsxs("div",{className:"w-full max-w-xs rounded-2xl border border-slate-200 bg-slate-50 p-4 shadow-inner",children:[q.jsxs("div",{className:"flex items-center justify-between text-sm font-semibold text-slate-700",children:[q.jsx("span",{children:""}),q.jsxs("span",{children:[n.current,"/",n.total," "]})]}),q.jsx("div",{className:"mt-3 h-3 overflow-hidden rounded-full bg-slate-200",children:q.jsx("div",{className:"h-full bg-gradient-to-r from-primary to-secondary",style:{width:`${e}%`}})}),q.jsx("p",{className:"mt-2 text-xs text-slate-500",children:"      ."})]})}function SB({title:n,description:e,items:t,onSelect:s}){return q.jsxs("section",{className:"rounded-3xl bg-white p-6 shadow-card",children:[q.jsxs("div",{className:"flex flex-wrap items-center justify-between gap-4",children:[q.jsxs("div",{children:[q.jsx("h3",{className:"text-xl font-bold text-slate-900",children:n}),q.jsx("p",{className:"text-sm text-slate-500",children:e})]}),q.jsxs("span",{className:"rounded-full bg-slate-100 px-3 py-1 text-xs font-semibold text-slate-600",children:[t.length," "]})]}),q.jsx("div",{className:"mt-5 grid gap-4 sm:grid-cols-2 md:grid-cols-3",children:t.map(r=>q.jsxs("button",{onClick:()=>s(r),className:"flex h-full flex-col gap-3 rounded-2xl border border-slate-200 bg-slate-50/70 p-4 text-right shadow-sm transition hover:-translate-y-0.5 hover:shadow-md focus:outline-none focus:ring-2 focus:ring-primary/40",children:[q.jsxs("div",{className:"flex items-center justify-between",children:[q.jsx("p",{className:"text-lg font-semibold text-slate-900",children:r.label}),q.jsx("span",{className:"rounded-full bg-white px-3 py-1 text-xs font-semibold text-slate-500 shadow-inner",children:r.type})]}),q.jsx("div",{className:"flex aspect-video items-center justify-center rounded-xl border border-dashed border-slate-300 bg-white text-xs text-slate-400",children:" "})]},r.label))})]})}function CB({badges:n}){return q.jsxs("div",{className:"rounded-3xl bg-white p-5 shadow-card",children:[q.jsxs("div",{className:"flex items-center justify-between",children:[q.jsx("h4",{className:"text-lg font-bold text-slate-900",children:" "}),q.jsx("span",{className:"text-xs text-slate-500",children:" "})]}),q.jsx("div",{className:"mt-4 grid grid-cols-2 gap-3",children:n.map(e=>q.jsxs("div",{className:`flex items-center gap-3 rounded-2xl border p-3 ${e.unlocked?"border-emerald-200 bg-emerald-50":"border-slate-200 bg-slate-50"}`,children:[q.jsx("div",{className:"flex h-10 w-10 items-center justify-center rounded-xl bg-white text-xl",children:e.icon}),q.jsxs("div",{children:[q.jsx("p",{className:"text-sm font-semibold text-slate-900",children:e.label}),q.jsx("p",{className:"text-xs text-slate-500",children:e.unlocked?" ":e.tip})]})]},e.id))})]})}function NB({daily:n,onStart:e}){const t=n.done>=n.target,s=Math.min(100,Math.round(n.done/n.target*100));return q.jsxs("div",{className:"rounded-3xl bg-white p-5 shadow-card",children:[q.jsxs("div",{className:"flex items-center justify-between",children:[q.jsx("h4",{className:"text-lg font-bold text-slate-900",children:" "}),q.jsx("span",{className:"text-xs text-slate-500",children:" "})]}),q.jsxs("p",{className:"mt-2 text-sm text-slate-600",children:["  ",n.target,"   ."]}),q.jsx("div",{className:"mt-3 h-2 overflow-hidden rounded-full bg-slate-200",children:q.jsx("div",{className:`h-full ${t?"bg-emerald-500":"bg-primary"}`,style:{width:`${s}%`}})}),q.jsxs("div",{className:"mt-2 flex items-center justify-between text-xs text-slate-600",children:[q.jsxs("span",{children:[n.done,"/",n.target," "]}),q.jsx("span",{children:n.status})]}),q.jsx("button",{onClick:e,className:"mt-3 w-full rounded-xl border border-slate-200 bg-slate-50 py-2 text-sm font-semibold text-slate-800 transition hover:bg-slate-100",children:" "})]})}function kB({message:n}){return q.jsx("div",{className:"rounded-2xl bg-gradient-to-r from-primary to-secondary px-4 py-3 text-sm font-semibold text-white shadow-card",children:n})}function $B({children:n,onClose:e}){return q.jsx("div",{className:"fixed inset-0 z-40 flex items-center justify-center bg-black/40 px-4",children:q.jsxs("div",{className:"relative w-full max-w-2xl rounded-3xl bg-white p-6 shadow-2xl",children:[q.jsx("button",{onClick:e,className:"absolute left-4 top-4 rounded-full bg-slate-100 px-3 py-1 text-xs font-semibold text-slate-700 hover:bg-slate-200",children:""}),n]})})}function IB(){return q.jsxs("div",{className:"space-y-6 rounded-3xl bg-white p-8 shadow-card",children:[q.jsx("p",{className:"text-sm font-semibold text-blue-600",children:" "}),q.jsx("h2",{className:"text-2xl font-bold text-slate-900",children:"     "}),q.jsx("p",{className:"text-slate-700 leading-relaxed",children:"       /          .      (Mock Data)           ."}),q.jsxs("ul",{className:"list-disc space-y-2 pr-5 text-slate-700",children:[q.jsx("li",{children:"         ."}),q.jsx("li",{children:"       ."}),q.jsx("li",{children:"         ."}),q.jsx("li",{children:" RTL  Tailwind CSS     ."})]}),q.jsx("div",{className:"rounded-2xl border border-slate-200 bg-slate-50/70 p-4 text-sm text-slate-600",children:":          (Mock URLs)          ."})]})}var Fy={exports:{}},TB=Fy.exports,_I;function EB(){return _I||(_I=1,(function(n,e){(function(s,r){n.exports=r(Ax())})(TB,function(t){return(function(s){var r={};function i(a){if(r[a])return r[a].exports;var o=r[a]={i:a,l:!1,exports:{}};return s[a].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=s,i.c=r,i.d=function(a,o,u){i.o(a,o)||Object.defineProperty(a,o,{enumerable:!0,get:u})},i.r=function(a){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},i.t=function(a,o){if(o&1&&(a=i(a)),o&8||o&4&&typeof a=="object"&&a&&a.__esModule)return a;var u=Object.create(null);if(i.r(u),Object.defineProperty(u,"default",{enumerable:!0,value:a}),o&2&&typeof a!="string")for(var c in a)i.d(u,c,(function(d){return a[d]}).bind(null,c));return u},i.n=function(a){var o=a&&a.__esModule?function(){return a.default}:function(){return a};return i.d(o,"a",o),o},i.o=function(a,o){return Object.prototype.hasOwnProperty.call(a,o)},i.p="",i(i.s="./src/react-webcam.tsx")})({"./src/react-webcam.tsx":(function(s,r,i){i.r(r);var a=i("react"),o=(function(){var m=function(g,x){return m=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,v){b.__proto__=v}||function(b,v){for(var w in v)v.hasOwnProperty(w)&&(b[w]=v[w])},m(g,x)};return function(g,x){m(g,x);function b(){this.constructor=g}g.prototype=x===null?Object.create(x):(b.prototype=x.prototype,new b)}})(),u=function(){return u=Object.assign||function(m){for(var g,x=1,b=arguments.length;x<b;x++){g=arguments[x];for(var v in g)Object.prototype.hasOwnProperty.call(g,v)&&(m[v]=g[v])}return m},u.apply(this,arguments)},c=function(m,g){var x={};for(var b in m)Object.prototype.hasOwnProperty.call(m,b)&&g.indexOf(b)<0&&(x[b]=m[b]);if(m!=null&&typeof Object.getOwnPropertySymbols=="function")for(var v=0,b=Object.getOwnPropertySymbols(m);v<b.length;v++)g.indexOf(b[v])<0&&Object.prototype.propertyIsEnumerable.call(m,b[v])&&(x[b[v]]=m[b[v]]);return x};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(g){var x=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return x?new Promise(function(b,v){x.call(navigator,g,b,v)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function d(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var p=(function(m){o(g,m);function g(x){var b=m.call(this,x)||this;return b.canvas=null,b.ctx=null,b.requestUserMediaId=0,b.unmounted=!1,b.state={hasUserMedia:!1},b}return g.prototype.componentDidMount=function(){var x=this,b=x.state,v=x.props;if(this.unmounted=!1,!d()){v.onUserMediaError("getUserMedia not supported");return}b.hasUserMedia||this.requestUserMedia(),v.children&&typeof v.children!="function"&&console.warn("children must be a function")},g.prototype.componentDidUpdate=function(x){var b=this.props;if(!d()){b.onUserMediaError("getUserMedia not supported");return}var v=JSON.stringify(x.audioConstraints)!==JSON.stringify(b.audioConstraints),w=JSON.stringify(x.videoConstraints)!==JSON.stringify(b.videoConstraints),N=x.minScreenshotWidth!==b.minScreenshotWidth,I=x.minScreenshotHeight!==b.minScreenshotHeight;(w||N||I)&&(this.canvas=null,this.ctx=null),(v||w)&&(this.stopAndCleanup(),this.requestUserMedia())},g.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},g.stopMediaStream=function(x){x&&(x.getVideoTracks&&x.getAudioTracks?(x.getVideoTracks().map(function(b){x.removeTrack(b),b.stop()}),x.getAudioTracks().map(function(b){x.removeTrack(b),b.stop()})):x.stop())},g.prototype.stopAndCleanup=function(){var x=this.state;x.hasUserMedia&&(g.stopMediaStream(this.stream),x.src&&window.URL.revokeObjectURL(x.src))},g.prototype.getScreenshot=function(x){var b=this,v=b.state,w=b.props;if(!v.hasUserMedia)return null;var N=this.getCanvas(x);return N&&N.toDataURL(w.screenshotFormat,w.screenshotQuality)},g.prototype.getCanvas=function(x){var b=this,v=b.state,w=b.props;if(!this.video||!v.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var N=this.video.videoWidth,I=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var $=N/I;N=w.minScreenshotWidth||this.video.clientWidth,I=N/$,w.minScreenshotHeight&&I<w.minScreenshotHeight&&(I=w.minScreenshotHeight,N=I*$)}this.canvas=document.createElement("canvas"),this.canvas.width=x?.width||N,this.canvas.height=x?.height||I,this.ctx=this.canvas.getContext("2d")}var E=this,D=E.ctx,F=E.canvas;return D&&F&&(F.width=x?.width||F.width,F.height=x?.height||F.height,w.mirrored&&(D.translate(F.width,0),D.scale(-1,1)),D.imageSmoothingEnabled=w.imageSmoothing,D.drawImage(this.video,0,0,x?.width||F.width,x?.height||F.height),w.mirrored&&(D.scale(-1,1),D.translate(-F.width,0))),F},g.prototype.requestUserMedia=function(){var x=this,b=this.props,v=function(I,$){var E={video:typeof $<"u"?$:!0};b.audio&&(E.audio=typeof I<"u"?I:!0),x.requestUserMediaId++;var D=x.requestUserMediaId;navigator.mediaDevices.getUserMedia(E).then(function(F){x.unmounted||D!==x.requestUserMediaId?g.stopMediaStream(F):x.handleUserMedia(null,F)}).catch(function(F){x.handleUserMedia(F)})};if("mediaDevices"in navigator)v(b.audioConstraints,b.videoConstraints);else{var w=function(I){return{optional:[{sourceId:I}]}},N=function(I){var $=I.deviceId;return typeof $=="string"?$:Array.isArray($)&&$.length>0?$[0]:typeof $=="object"&&$.ideal?$.ideal:null};MediaStreamTrack.getSources(function(I){var $=null,E=null;I.forEach(function(L){L.kind==="audio"?$=L.id:L.kind==="video"&&(E=L.id)});var D=N(b.audioConstraints);D&&($=D);var F=N(b.videoConstraints);F&&(E=F),v(w($),w(E))})}},g.prototype.handleUserMedia=function(x,b){var v=this.props;if(x||!b){this.setState({hasUserMedia:!1}),v.onUserMediaError(x);return}this.stream=b;try{this.video&&(this.video.srcObject=b),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(b)})}v.onUserMedia(b)},g.prototype.render=function(){var x=this,b=this,v=b.state,w=b.props,N=w.audio;w.forceScreenshotSourceSize;var I=w.disablePictureInPicture;w.onUserMedia,w.onUserMediaError,w.screenshotFormat,w.screenshotQuality,w.minScreenshotWidth,w.minScreenshotHeight,w.audioConstraints,w.videoConstraints,w.imageSmoothing;var $=w.mirrored,E=w.style,D=E===void 0?{}:E,F=w.children,L=c(w,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),z=$?u(u({},D),{transform:(D.transform||"")+" scaleX(-1)"}):D,M={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",u({autoPlay:!0,disablePictureInPicture:I,src:v.src,muted:!N,playsInline:!0,ref:function(O){x.video=O},style:z},L)),F&&F(M))},g.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},g})(a.Component);r.default=p}),react:(function(s,r){s.exports=t})}).default})})(Fy)),Fy.exports}var RB=EB();const OR=q2(RB);const AB=1e-7,DB=1e-4;class Q2{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Fx{refCount(e){return Sr("refCount")}incRef(e){return Sr("incRef")}timerAvailable(){return!0}time(e){return Sr("time")}read(e){return Sr("read")}readSync(e){return Sr("readSync")}readToGPU(e,t){return Sr("readToGPU")}numDataIds(){return Sr("numDataIds")}disposeData(e,t){return Sr("disposeData")}write(e,t,s){return Sr("write")}move(e,t,s,r,i){return Sr("move")}createTensorFromGPUData(e,t,s){return Sr("createTensorFromGPUData")}memory(){return Sr("memory")}floatPrecision(){return Sr("floatPrecision")}epsilon(){return this.floatPrecision()===32?AB:DB}dispose(){return Sr("dispose")}}function Sr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _B(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,eh(n,e,t)}function Su(n,e,t){return Math.max(n,Math.min(e,t))}function Z2(n){return n%2===0?n:n+1}function eh(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function FR(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function B(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function pr(n,e,t=""){B(xt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function $h(n){B(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ce(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function OI(n){return n.length===0}function OB(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function xt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function hh(n){return n%1===0}function jw(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function rh(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function FI(n,e=r=>0,t,s){return new Promise((r,i)=>{let a=0;const o=()=>{if(n()){r();return}a++;const u=e(a);if(t!=null&&a>=t){i();return}s!=null?s(o,u):setTimeout(o,u)};o()})}function J2(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function gt(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),B(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),B(n.every(s=>hh(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function vl(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:gt(e,n).sort();let a=0;for(let o=0;o<n.length;++o){if(i!=null){if(i[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(i[a]==null||i[a]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),i[a]<=o&&a++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function ss(n,e){return En(n,e)}function En(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function FB(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function zB(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function eS(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Qy(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function LB(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ih(n){return typeof n=="string"||n instanceof String}function MB(n){return typeof n=="boolean"}function qw(n){return typeof n=="number"}function Mu(n){return Array.isArray(n)?Mu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":qw(n)?"float32":Ih(n)?"string":MB(n)?"bool":"float32"}function Xw(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Kw(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Ze(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function zR(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let a=0;a<i;a++)r[a]=t[n+a]}else{const i=e[0],a=e.slice(1),o=a.reduce((u,c)=>u*c)*(s?2:1);for(let u=0;u<i;u++)r[u]=zR(n+u*o,a,t,s)}return r}function Si(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return zR(0,n,e,t)}function zy(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function tS(n,e){const t=Ns(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Ns(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function LR(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Si(n,new Float32Array(t));if(e==="int32")return Si(n,new Int32Array(t));if(e==="bool")return Si(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Yr(n){n.forEach(e=>{B(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ya(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Th(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Cu(n){return n&&n.then&&typeof n.then=="function"}const zI="tfjsflags";class PB{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=BB,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(fe().getBool("IS_TEST")||fe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];fe().getBool("IS_TEST")||fe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Cu(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);zI in e&&e[zI].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=UB(r,i)})}}function BB(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(VB(e,s[0],s[1]),s.join("="))),e}function VB(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function UB(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function fe(){return MR}let MR=null;function WB(n){MR=n}let uw;function PR(){if(uw==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");uw=n}return uw}function GB(){const n=PR();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function nS(n,e){const t=GB();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const If="Abs",Eh="Acos",Rh="Acosh",Pu="Add",Tf="AddN",zx="All",Lx="Any",Ef="ArgMax",Rf="ArgMin",Ah="Asin",Dh="Asinh",_h="Atan",Oh="Atanh",Fh="Atan2",Af="AvgPool",Mx="AvgPoolGrad",Df="AvgPool3D",Px="AvgPool3DGrad",_f="BatchMatMul",Of="BatchToSpaceND",Bx="Bincount",Vx="BitwiseAnd",HB="BroadcastTo",Ux="BroadcastArgs",zh="Cast",Lh="Ceil",Mh="ClipByValue",Wx="Complex",Ff="ComplexAbs",zf="Concat",Lf="Conv2D",Gx="Conv2DBackpropFilter",Mf="Conv2DBackpropInput",Pf="Conv3D",Hx="Conv3DBackpropFilterV2",jx="Conv3DBackpropInputV2",Ph="Cos",Bh="Cosh",qx="Cumprod",Bf="Cumsum",Xx="CropAndResize",Kx="DenseBincount",Yx="DepthToSpace",Vf="DepthwiseConv2dNative",Qx="DepthwiseConv2dNativeBackpropFilter",Zx="DepthwiseConv2dNativeBackpropInput",Jx="Diag",Uf="Dilation2D",Zy="Dilation2DBackpropInput",Jy="Dilation2DBackpropFilter",sS="Draw",Vh="RealDiv",e0="Einsum",Uh="Elu",t0="EluGrad",Wh="Erf",Wf="Equal",Gh="Exp",Gf="ExpandDims",Hh="Expm1",n0="FFT",s0="Fill",r0="FlipLeftRight",jh="Floor",qh="FloorDiv",Hf="FusedBatchNorm",jf="GatherV2",i0="GatherNd",qf="Greater",Xh="GreaterEqual",Kh="Identity",a0="IFFT",o0="Imag",Yh="IsFinite",Qh="IsInf",Zh="IsNan",Xf="LeakyRelu",Kf="Less",Yf="LessEqual",l0="LinSpace",Jh="Log",ed="Log1p",Qf="LogicalAnd",Zf="LogicalNot",Jf="LogicalOr",jB="LogSoftmax",em="LRN",u0="LRNGrad",tm="Max",td="Maximum",nm="MaxPool",c0="MaxPoolGrad",sm="MaxPool3D",h0="MaxPool3DGrad",d0="MaxPoolWithArgmax",rm="Mean",im="Min",nd="Minimum",am="MirrorPad",sd="Mod",p0="Multinomial",rd="Multiply",om="Neg",lm="NotEqual",f0="NonMaxSuppressionV3",rS="NonMaxSuppressionV4",m0="NonMaxSuppressionV5",um="OnesLike",cm="OneHot",hm="Pack",dm="PadV2",id="Pow",pm="Prelu",fm="Prod",iS="RaggedGather",aS="RaggedRange",oS="RaggedTensorToTensor",g0="Range",y0="Real",ad="Reciprocal",od="Relu",mm="Reshape",gm="ResizeNearestNeighbor",x0="ResizeNearestNeighborGrad",ym="ResizeBilinear",b0="ResizeBilinearGrad",ld="Relu6",xm="Reverse",ud="Round",cd="Rsqrt",v0="ScatterNd",w0="TensorScatterUpdate",S0="SearchSorted",bm="Select",hd="Selu",vm="Slice",dd="Sin",pd="Sinh",fd="Sign",md="Sigmoid",gd="Softplus",yd="Sqrt",wm="Sum",Sm="SpaceToBatchND",Cm="SplitV",Nm="Softmax",lS="SparseFillEmptyRows",uS="SparseReshape",C0="SparseSegmentMean",N0="SparseSegmentSum",k0="SparseToDense",xd="SquaredDifference",$0="Square",I0="StaticRegexReplace",T0="StridedSlice",E0="StringNGrams",cS="StringSplit",hS="StringToHashBucketFast",bd="Sub",vd="Tan",wd="Tanh",Sd="Tile",R0="TopK",A0="Transform",yu="Transpose",dS="Unique",km="Unpack",$m="UnsortedSegmentSum",Im="ZerosLike",Cd="Step",ex="FromPixels",D0="RotateWithOffset",rf="_FusedMatMul",af="FusedConv2D",of="FusedDepthwiseConv2D";function Hr(...n){fe().getBool("IS_TEST")||fe().getBool("PROD")||console.warn(...n)}function qB(...n){fe().getBool("IS_TEST")||fe().getBool("PROD")||console.log(...n)}const tx=nS("kernelRegistry",()=>new Map),Yw=nS("gradRegistry",()=>new Map);function nx(n,e){const t=BR(n,e);return tx.get(t)}function LI(n){return Yw.get(n)}function MI(n){const e=tx.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===n&&t.push(a)}return t}function pS(n){const{kernelName:e,backendName:t}=n,s=BR(e,t);tx.has(s)&&Hr(`The kernel '${e}' for backend '${t}' is already registered`),tx.set(s,n)}function XB(n){const{kernelName:e}=n;Yw.has(e)&&fe().getBool("DEBUG")&&Hr(`Overriding the gradient for '${e}'`),Yw.set(e,n)}function BR(n,e){return`${e}_${n}`}function VR(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var cw,PI;function KB(){if(PI)return cw;PI=1,cw=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(M,O,H){this.low=M|0,this.high=O|0,this.unsigned=!!H}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(M){return(M&&M.__isLong__)===!0}e.isLong=t;var s={},r={};function i(M,O){var H,X,te;return O?(M>>>=0,(te=0<=M&&M<256)&&(X=r[M],X)?X:(H=o(M,(M|0)<0?-1:0,!0),te&&(r[M]=H),H)):(M|=0,(te=-128<=M&&M<128)&&(X=s[M],X)?X:(H=o(M,M<0?-1:0,!1),te&&(s[M]=H),H))}e.fromInt=i;function a(M,O){if(isNaN(M))return O?N:w;if(O){if(M<0)return N;if(M>=x)return F}else{if(M<=-b)return L;if(M+1>=b)return D}return M<0?a(-M,O).neg():o(M%g|0,M/g|0,O)}e.fromNumber=a;function o(M,O,H){return new e(M,O,H)}e.fromBits=o;var u=Math.pow;function c(M,O,H){if(M.length===0)throw Error("empty string");if(M==="NaN"||M==="Infinity"||M==="+Infinity"||M==="-Infinity")return w;if(typeof O=="number"?(H=O,O=!1):O=!!O,H=H||10,H<2||36<H)throw RangeError("radix");var X;if((X=M.indexOf("-"))>0)throw Error("interior hyphen");if(X===0)return c(M.substring(1),O,H).neg();for(var te=a(u(H,8)),Z=w,W=0;W<M.length;W+=8){var ee=Math.min(8,M.length-W),ie=parseInt(M.substring(W,W+ee),H);if(ee<8){var de=a(u(H,ee));Z=Z.mul(de).add(a(ie))}else Z=Z.mul(te),Z=Z.add(a(ie))}return Z.unsigned=O,Z}e.fromString=c;function d(M,O){return typeof M=="number"?a(M,O):typeof M=="string"?c(M,O):o(M.low,M.high,typeof O=="boolean"?O:M.unsigned)}e.fromValue=d;var p=65536,m=1<<24,g=p*p,x=g*g,b=x/2,v=i(m),w=i(0);e.ZERO=w;var N=i(0,!0);e.UZERO=N;var I=i(1);e.ONE=I;var $=i(1,!0);e.UONE=$;var E=i(-1);e.NEG_ONE=E;var D=o(-1,2147483647,!1);e.MAX_VALUE=D;var F=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=F;var L=o(0,-2147483648,!1);e.MIN_VALUE=L;var z=e.prototype;return z.toInt=function(){return this.unsigned?this.low>>>0:this.low},z.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},z.toString=function(O){if(O=O||10,O<2||36<O)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(L)){var H=a(O),X=this.div(H),te=X.mul(H).sub(this);return X.toString(O)+te.toInt().toString(O)}else return"-"+this.neg().toString(O);for(var Z=a(u(O,6),this.unsigned),W=this,ee="";;){var ie=W.div(Z),de=W.sub(ie.mul(Z)).toInt()>>>0,ge=de.toString(O);if(W=ie,W.isZero())return ge+ee;for(;ge.length<6;)ge="0"+ge;ee=""+ge+ee}},z.getHighBits=function(){return this.high},z.getHighBitsUnsigned=function(){return this.high>>>0},z.getLowBits=function(){return this.low},z.getLowBitsUnsigned=function(){return this.low>>>0},z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(L)?64:this.neg().getNumBitsAbs();for(var O=this.high!=0?this.high:this.low,H=31;H>0&&(O&1<<H)==0;H--);return this.high!=0?H+33:H+1},z.isZero=function(){return this.high===0&&this.low===0},z.eqz=z.isZero,z.isNegative=function(){return!this.unsigned&&this.high<0},z.isPositive=function(){return this.unsigned||this.high>=0},z.isOdd=function(){return(this.low&1)===1},z.isEven=function(){return(this.low&1)===0},z.equals=function(O){return t(O)||(O=d(O)),this.unsigned!==O.unsigned&&this.high>>>31===1&&O.high>>>31===1?!1:this.high===O.high&&this.low===O.low},z.eq=z.equals,z.notEquals=function(O){return!this.eq(O)},z.neq=z.notEquals,z.ne=z.notEquals,z.lessThan=function(O){return this.comp(O)<0},z.lt=z.lessThan,z.lessThanOrEqual=function(O){return this.comp(O)<=0},z.lte=z.lessThanOrEqual,z.le=z.lessThanOrEqual,z.greaterThan=function(O){return this.comp(O)>0},z.gt=z.greaterThan,z.greaterThanOrEqual=function(O){return this.comp(O)>=0},z.gte=z.greaterThanOrEqual,z.ge=z.greaterThanOrEqual,z.compare=function(O){if(t(O)||(O=d(O)),this.eq(O))return 0;var H=this.isNegative(),X=O.isNegative();return H&&!X?-1:!H&&X?1:this.unsigned?O.high>>>0>this.high>>>0||O.high===this.high&&O.low>>>0>this.low>>>0?-1:1:this.sub(O).isNegative()?-1:1},z.comp=z.compare,z.negate=function(){return!this.unsigned&&this.eq(L)?L:this.not().add(I)},z.neg=z.negate,z.add=function(O){t(O)||(O=d(O));var H=this.high>>>16,X=this.high&65535,te=this.low>>>16,Z=this.low&65535,W=O.high>>>16,ee=O.high&65535,ie=O.low>>>16,de=O.low&65535,ge=0,G=0,re=0,pe=0;return pe+=Z+de,re+=pe>>>16,pe&=65535,re+=te+ie,G+=re>>>16,re&=65535,G+=X+ee,ge+=G>>>16,G&=65535,ge+=H+W,ge&=65535,o(re<<16|pe,ge<<16|G,this.unsigned)},z.subtract=function(O){return t(O)||(O=d(O)),this.add(O.neg())},z.sub=z.subtract,z.multiply=function(O){if(this.isZero())return w;if(t(O)||(O=d(O)),n){var H=n.mul(this.low,this.high,O.low,O.high);return o(H,n.get_high(),this.unsigned)}if(O.isZero())return w;if(this.eq(L))return O.isOdd()?L:w;if(O.eq(L))return this.isOdd()?L:w;if(this.isNegative())return O.isNegative()?this.neg().mul(O.neg()):this.neg().mul(O).neg();if(O.isNegative())return this.mul(O.neg()).neg();if(this.lt(v)&&O.lt(v))return a(this.toNumber()*O.toNumber(),this.unsigned);var X=this.high>>>16,te=this.high&65535,Z=this.low>>>16,W=this.low&65535,ee=O.high>>>16,ie=O.high&65535,de=O.low>>>16,ge=O.low&65535,G=0,re=0,pe=0,ve=0;return ve+=W*ge,pe+=ve>>>16,ve&=65535,pe+=Z*ge,re+=pe>>>16,pe&=65535,pe+=W*de,re+=pe>>>16,pe&=65535,re+=te*ge,G+=re>>>16,re&=65535,re+=Z*de,G+=re>>>16,re&=65535,re+=W*ie,G+=re>>>16,re&=65535,G+=X*ge+te*de+Z*ie+W*ee,G&=65535,o(pe<<16|ve,G<<16|re,this.unsigned)},z.mul=z.multiply,z.divide=function(O){if(t(O)||(O=d(O)),O.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&O.low===-1&&O.high===-1)return this;var H=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,O.low,O.high);return o(H,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?N:w;var X,te,Z;if(this.unsigned){if(O.unsigned||(O=O.toUnsigned()),O.gt(this))return N;if(O.gt(this.shru(1)))return $;Z=N}else{if(this.eq(L)){if(O.eq(I)||O.eq(E))return L;if(O.eq(L))return I;var W=this.shr(1);return X=W.div(O).shl(1),X.eq(w)?O.isNegative()?I:E:(te=this.sub(O.mul(X)),Z=X.add(te.div(O)),Z)}else if(O.eq(L))return this.unsigned?N:w;if(this.isNegative())return O.isNegative()?this.neg().div(O.neg()):this.neg().div(O).neg();if(O.isNegative())return this.div(O.neg()).neg();Z=w}for(te=this;te.gte(O);){X=Math.max(1,Math.floor(te.toNumber()/O.toNumber()));for(var ee=Math.ceil(Math.log(X)/Math.LN2),ie=ee<=48?1:u(2,ee-48),de=a(X),ge=de.mul(O);ge.isNegative()||ge.gt(te);)X-=ie,de=a(X,this.unsigned),ge=de.mul(O);de.isZero()&&(de=I),Z=Z.add(de),te=te.sub(ge)}return Z},z.div=z.divide,z.modulo=function(O){if(t(O)||(O=d(O)),n){var H=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,O.low,O.high);return o(H,n.get_high(),this.unsigned)}return this.sub(this.div(O).mul(O))},z.mod=z.modulo,z.rem=z.modulo,z.not=function(){return o(~this.low,~this.high,this.unsigned)},z.and=function(O){return t(O)||(O=d(O)),o(this.low&O.low,this.high&O.high,this.unsigned)},z.or=function(O){return t(O)||(O=d(O)),o(this.low|O.low,this.high|O.high,this.unsigned)},z.xor=function(O){return t(O)||(O=d(O)),o(this.low^O.low,this.high^O.high,this.unsigned)},z.shiftLeft=function(O){return t(O)&&(O=O.toInt()),(O&=63)===0?this:O<32?o(this.low<<O,this.high<<O|this.low>>>32-O,this.unsigned):o(0,this.low<<O-32,this.unsigned)},z.shl=z.shiftLeft,z.shiftRight=function(O){return t(O)&&(O=O.toInt()),(O&=63)===0?this:O<32?o(this.low>>>O|this.high<<32-O,this.high>>O,this.unsigned):o(this.high>>O-32,this.high>=0?0:-1,this.unsigned)},z.shr=z.shiftRight,z.shiftRightUnsigned=function(O){if(t(O)&&(O=O.toInt()),O&=63,O===0)return this;var H=this.high;if(O<32){var X=this.low;return o(X>>>O|H<<32-O,H>>>O,this.unsigned)}else return O===32?o(H,0,this.unsigned):o(H>>>O-32,0,this.unsigned)},z.shru=z.shiftRightUnsigned,z.shr_u=z.shiftRightUnsigned,z.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},z.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},z.toBytes=function(O){return O?this.toBytesLE():this.toBytesBE()},z.toBytesLE=function(){var O=this.high,H=this.low;return[H&255,H>>>8&255,H>>>16&255,H>>>24,O&255,O>>>8&255,O>>>16&255,O>>>24]},z.toBytesBE=function(){var O=this.high,H=this.low;return[O>>>24,O>>>16&255,O>>>8&255,O&255,H>>>24,H>>>16&255,H>>>8&255,H&255]},e.fromBytes=function(O,H,X){return X?e.fromBytesLE(O,H):e.fromBytesBE(O,H)},e.fromBytesLE=function(O,H){return new e(O[0]|O[1]<<8|O[2]<<16|O[3]<<24,O[4]|O[5]<<8|O[6]<<16|O[7]<<24,H)},e.fromBytesBE=function(O,H){return new e(O[4]<<24|O[5]<<16|O[6]<<8|O[7],O[0]<<24|O[1]<<16|O[2]<<8|O[3],H)},cw}var UR=KB();const WR=q2(UR),YB=vR({__proto__:null,default:WR},[UR]);const uu=WR||YB;function _0(n){return uu.fromString(n,!0,16)}const GR=_0("c3a5c85c97cb3127"),ou=_0("b492b66fbe98f273"),js=_0("9ae16a3b2f90404f");function Qw(n){return n.xor(n.shru(47))}function HR(n,e,t){const s=n.slice(e,e+t);return uu.fromBytes(Array.from(s),!0,!0)}function dn(n,e){return HR(n,e,8)}function BI(n,e){return HR(n,e,4)}function fs(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function il(n,e,t=_0("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function QB(n,e,t,s,r,i){r=r.add(n),i=fs(i.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),i=i.add(fs(r,44)),[r.add(s),i.add(a)]}function by(n,e,t,s){return QB(dn(n,e),dn(n,e+8),dn(n,e+16),dn(n,e+24),t,s)}function ZB(n,e=n.length){if(e>=8){const t=js.add(e*2),s=dn(n,0).add(js),r=dn(n,e-8),i=fs(r,37).mul(t).add(s),a=fs(s,25).add(r).mul(t);return il(i,a,t)}if(e>=4){const t=js.add(e*2),s=BI(n,0);return il(s.shl(3).add(e),BI(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),a=e+(r<<2);return Qw(js.mul(i).xor(GR.mul(a))).mul(js)}return js}function JB(n,e=n.length){const t=js.add(e*2),s=dn(n,0).mul(ou),r=dn(n,8),i=dn(n,e-8).mul(t),a=dn(n,e-16).mul(js);return il(fs(s.add(r),43).add(fs(i,30)).add(a),s.add(fs(r.add(js),18)).add(i),t)}function e4(n,e=n.length){const t=js.add(e*2),s=dn(n,0).mul(js),r=dn(n,8),i=dn(n,e-8).mul(t),a=dn(n,e-16).mul(js),o=fs(s.add(r),43).add(fs(i,30)).add(a),u=il(o,s.add(fs(r.add(js),18)).add(i),t),c=dn(n,16).mul(t),d=dn(n,24),p=o.add(dn(n,e-32)).mul(t),m=u.add(dn(n,e-24)).mul(t);return il(fs(c.add(d),43).add(fs(p,30)).add(m),c.add(fs(d.add(s),18)).add(p),t)}function t4(n,e=n.length){const t=uu.fromNumber(81,!0);if(e<=32)return e<=16?ZB(n,e):JB(n,e);if(e<=64)return e4(n,e);let s=t,r=t.mul(ou).add(113),i=Qw(r.mul(js).add(113)).mul(js),a=[uu.UZERO,uu.UZERO],o=[uu.UZERO,uu.UZERO];s=s.mul(js).add(dn(n,0));let u=0;const c=(e-1>>6)*64,d=c+(e-1&63)-63;do s=fs(s.add(r).add(a[0]).add(dn(n,u+8)),37).mul(ou),r=fs(r.add(a[1]).add(dn(n,u+48)),42).mul(ou),s=s.xor(o[1]),r=r.add(a[0]).add(dn(n,u+40)),i=fs(i.add(o[0]),33).mul(ou),a=by(n,u,a[1].mul(ou),s.add(o[0])),o=by(n,u+32,i.add(o[1]),r.add(dn(n,u+16))),[i,s]=[s,i],u+=64;while(u!==c);const p=ou.add(i.and(255).shl(1));return u=d,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=fs(s.add(r).add(a[0]).add(dn(n,u+8)),37).mul(p),r=fs(r.add(a[1]).add(dn(n,u+48)),42).mul(p),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add(dn(n,u+40))),i=fs(i.add(o[0]),33).mul(p),a=by(n,u,a[1].mul(p),s.add(o[0])),o=by(n,u+32,i.add(o[1]),r.add(dn(n,u+16))),[i,s]=[s,i],il(il(a[0],o[0],p).add(Qw(r).mul(GR)).add(i),il(a[1],o[1],p).add(s),p)}function wl(n,e){return e==="string"?ro(n):Bu([n],e)}function n4(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Bu(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=lo(n)),fe().getBool("DEBUG")&&FB(n,e),n4(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function ir(){return fe().platform.now()}function ro(n,e="utf-8"){return e=e||"utf-8",fe().platform.encode(n,e)}function Hi(n,e="utf-8"){return e=e||"utf-8",fe().platform.decode(n,e)}function ki(n){return fe().platform.isTypedArray!=null?fe().platform.isTypedArray(n):VR(n)}function lo(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Cu(n)||n==null||ki(n)&&t)e.push(n);else if(Array.isArray(n)||ki(n))for(let s=0;s<n.length;++s)lo(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)lo(n[r],e,t)}return e}class s4{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new i4)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let a;const o=ir();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();a=Promise.resolve({kernelMs:ir()-o})}if(fe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const d=r[c];d.data().then(p=>{r4(p,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:a}=e;s.forEach(o=>{Promise.all([o.data(),r,a]).then(u=>{this.logger.logKernelProfile(t,o,u[0],u[1],i,u[2])})})}}function r4(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class i4{logKernelProfile(e,t,s,r,i,a){const o=typeof r=="number"?rh(`${r}ms`,9):r.error,u=rh(e,25),c=t.rank,d=t.size,p=rh(t.shape.toString(),14);let m="";for(const g in i){const x=i[g];if(x!=null){const b=x.shape||t.shape,v=b.length;m+=`${g}: ${v}D ${v>0?b:""} `}}console.log(`%c${u}	%c${o}	%c${c}D ${p}	%c${d}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function a4(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const c=n[u],d=c.inputs;for(const p in d){const m=d[p];let g=!1;for(let x=0;x<e.length;x++)if(s[m.id]){c.outputs.forEach(b=>s[b.id]=!0),g=!0,r[c.id]=!0;break}if(g)break}}const i={};i[t.id]=!0;const a={};for(let u=n.length-1;u>=0;u--){const c=n[u],d=c.inputs;for(let p=0;p<c.outputs.length;p++)if(i[c.outputs[p].id]){for(const m in d)i[d[m].id]=!0,a[c.id]=!0;break}}const o=[];for(let u=0;u<n.length;u++){const c=n[u];if(r[c.id]&&a[c.id]){const d={};for(const m in c.inputs){const g=c.inputs[m];s[g.id]&&(d[m]=g)}const p=Object.assign({},c);p.inputs=d,p.outputs=c.outputs,o.push(p)}}return o}function o4(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(u=>{const c=n[u.id];c!=null?a.push(c):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const u in i.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);const c=t(()=>o[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const d=i.inputs[u];if(!xt(c.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=c;else{const p=n[d.id];n[d.id]=s(p,c),p.dispose()}}}}const VI=20,Up=3,hw=7;function l4(n,e,t,s){const r=Ze(e),i=u4(n,e,t,r),a=e.length,o=Ly(n,e,t,r,i),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(o.map(c=>"    "+c).join(`
`)),u.join(`
`)}function u4(n,e,t,s){const r=ce(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,u=t==="complex64"?Xp(n):n;if(o>1)for(let c=0;c<r/i;c++){const d=c*i;for(let p=0;p<i;p++)a[p]=Math.max(a[p],qp(u[d+p],0,t).length)}return a}function qp(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(hw))} + ${parseFloat(n[1].toFixed(hw))}j`:Ih(n)?s=`'${n}'`:t==="bool"?s=jR(n):s=parseFloat(n.toFixed(hw)).toString(),rh(s,e)}function jR(n){return n===0?"false":"true"}function Ly(n,e,t,s,r,i=!0){const a=t==="complex64"?2:1,o=e[0],u=e.length;if(u===0){if(t==="complex64"){const b=Xp(n);return[qp(b[0],0,t)]}return t==="bool"?[jR(n[0])]:[n[0].toString()]}if(u===1){if(o>VI){const v=Up*a;let w=Array.from(n.slice(0,v)),N=Array.from(n.slice((o-Up)*a,o*a));return t==="complex64"&&(w=Xp(w),N=Xp(N)),["["+w.map((I,$)=>qp(I,r[$],t)).join(", ")+", ..., "+N.map((I,$)=>qp(I,r[o-Up+$],t)).join(", ")+"]"]}return["["+(t==="complex64"?Xp(n):Array.from(n)).map((v,w)=>qp(v,r[w],t)).join(", ")+"]"]}const c=e.slice(1),d=s.slice(1),p=s[0]*a,m=[];if(o>VI){for(let b=0;b<Up;b++){const v=b*p,w=v+p;m.push(...Ly(n.slice(v,w),c,t,d,r,!1))}m.push("...");for(let b=o-Up;b<o;b++){const v=b*p,w=v+p;m.push(...Ly(n.slice(v,w),c,t,d,r,b===o-1))}}else for(let b=0;b<o;b++){const v=b*p,w=v+p;m.push(...Ly(n.slice(v,w),c,t,d,r,b===o-1))}const g=u===2?",":"";m[0]="["+(o>0?m[0]+g:"");for(let b=1;b<m.length-1;b++)m[b]=" "+m[b]+g;let x=`,
`;for(let b=2;b<u;b++)x+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":x),m}function Xp(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class es{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=ce(e),s!=null){const r=s.length;B(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||En(t,this.size),this.strides=Ze(e)}set(e,...t){t.length===0&&(t=[0]),B(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Vi().makeTensor(this.values,this.shape,this.dtype)}}let Vi=null,th=null;function c4(n){Vi=n}function h4(n){th=n}class Kt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ce(e),this.strides=Ze(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return th.buffer(this.shape,this.dtype,e)}bufferSync(){return th.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Si(this.shape,e,this.dtype==="complex64")}arraySync(){return Si(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Vi().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Hi(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Vi().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Vi().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Hi(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Vi().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Vi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return th.print(this,e)}clone(){return this.throwIfDisposed(),th.clone(this)}toString(e=!1){const t=this.dataSync();return l4(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),th.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Vi().makeVariable(this,e,t,s)}}Object.defineProperty(Kt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Ce(){return nS("Tensor",()=>Kt)}Ce();class sx extends Kt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!xt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Vi().disposeTensor(this),this.dataId=e.dataId,Vi().incRef(this,null)}dispose(){Vi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(sx,Symbol.hasInstance,{value:n=>n instanceof Kt&&n.assign!=null&&n.assign instanceof Function});var UI;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(UI||(UI={}));var Zw;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Zw||(Zw={}));var Jw;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Jw||(Jw={}));var e2;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(e2||(e2={}));var t2;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(t2||(t2={}));const d4={float32:e2,int32:Zw,bool:Jw,complex64:t2};function ys(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return d4[n][e]}function O0(n){return ys(n,"int32")}function qR(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function XR(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function An(n,e){if(n.dtype===e.dtype)return[n,e];const t=ys(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function p4(n,e){B(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function KR(n){const e=[];return YR(n,e,new Set),e}function YR(n,e,t){if(n==null)return;if(n instanceof Kt){e.push(n);return}if(!f4(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),YR(i,e,t))}}function f4(n){return Array.isArray(n)||typeof n=="object"}function dw(n){return n.kernelName!=null}class WI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class dh{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new WI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Hr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new s4(this.backendInstance),!0}setupRegisteredKernels(){MI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){MI(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Fx)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Hr(`Initialization of backend ${e} failed`),Hr(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Hr(`Initialization of backend ${e} failed`),Hr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return dh.nextTensorId++}nextVariableId(){return dh.nextVariableId++}clone(e){const t=se.runKernel(Kh,{x:e}),s={x:e},r=a=>({x:()=>{const o="float32",u={x:a},c={dtype:o};return se.runKernel(zh,u,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(nx(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(u=>{i+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-i-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u;const c=dw(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(dw(e)){const{kernelName:x,inputs:b,attrs:v}=e;this.backendName==null&&this.backend;const w=nx(x,this.backendName);B(w!=null,()=>`Cannot find registered kernel '${x}' for backend '${this.backendName}'`),o=()=>{const N=this.backend.numDataIds();u=w.kernelFunc({inputs:b,attrs:v,backend:this.backend});const I=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(x,N,I);const $=I.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(x,b,$);s=this.saveTensorsForBackwardMode(E)}return $}}else{const{forwardFunc:x}=e,b=v=>{r&&(s=v.map(w=>this.keep(this.clone(w))))};o=()=>{const v=this.backend.numDataIds();u=this.tidy(()=>x(this.backend,b));const w=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,v,w),w}}const{inputs:d,attrs:p}=e,m=dw(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(g=this.profiler.profileKernel(c,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),t=g.outputs)}),r&&this.addTapeNode(c,d,t,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(x=>d[x]!=null?d[x].shape:null),outputShapes:t.map(x=>x.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=LI(e);if(r!=null){const i=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(B(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(c=>t[c])):o=i.map(c=>t[c]);const u=s.filter((c,d)=>a[d]);return o.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&Ih(e[0])&&(i=e.map(u=>ro(u)));const a=r.write(i,t,s),o=new Kt(t,s,a,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const u=this.state.tensorInfo.get(a),c=LB(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return o}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,a=new Kt(r,i,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new sx(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Qy(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof sx||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Qy(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},u=LI(e);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=c=>(c=c.map((d,p)=>{if(d==null){const m=s[p],g=Ns(m.size,m.dtype);return this.makeTensor(g,m.shape,m.dtype)}return d}),r(c.length>1?c:c[0],i,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=KR(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(B(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));B(i instanceof Kt,()=>"The result y returned by f() must be a tensor.");const a=a4(this.state.activeTape,t,i);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[i.id]=s??m4(i.shape),o4(o,a,c=>this.tidy(c),g4);const u=t.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return B(Xw(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{B(t.every(o=>o instanceof Kt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((o,u)=>{r[u]=o});const i=(o,u)=>(s=e(...t,u),B(s.value instanceof Kt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),B(Xw(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,u)=>{const c=s.gradFunc(o,u),d=Array.isArray(c)?c:[c];B(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),B(d.every(m=>m instanceof Kt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,g)=>{p[g]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=ir(),s=await this.backend.time(e);return s.wallMs=ir()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new WI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}dh.nextTensorId=0;dh.nextVariableId=0;function m4(n){const e=tS(ce(n),"float32");return se.makeTensor(e,n,"float32")}function QR(){const n=PR();if(n._tfengine==null){const e=new PB(n);n._tfengine=new dh(e)}return WB(n._tfengine.ENV),c4(()=>n._tfengine),n._tfengine}const se=QR();function g4(n,e){const t={a:n,b:e};return se.runKernel(Pu,t)}function y4(){return typeof navigator<"u"&&navigator!=null}function ZR(n){if(n||y4()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function JR(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const cr=fe();cr.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});cr.registerFlag("IS_BROWSER",()=>JR());cr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");cr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));cr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));cr.registerFlag("PROD",()=>!1);cr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>cr.getBool("DEBUG"));cr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);cr.registerFlag("IS_TEST",()=>!1);cr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>cr.getBool("DEBUG"));cr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);cr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);cr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Sl(n,e){let t=n;if(ki(n))return e==="string"?[]:[n.length];if(qR(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(XR(n))return[n.buffer.size/(e==null?4:Qy(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||ki(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&fe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&e3(n,s,[]),s}function e3(n,e,t){if(t=t||[],!Array.isArray(n)&&!ki(n)){B(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}B(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),B(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)e3(n[r],s,t.concat(r))}function GI(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function U(n,e,t,s="numeric"){if(n instanceof Ce())return GI(s,n.dtype,e,t),n;let r=Mu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),GI(s,r,e,t),n==null||!ki(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const i=Sl(n,r);!ki(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?Bu(n,r):lo(n,[],!0);return se.makeTensor(o,i,r)}function rx(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,a)=>U(i,`${e}[${a}]`,t,s))}const t3="__op";function J(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+t3;const r=(...i)=>{se.startScope(t);try{const a=s(...i);return Cu(a)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(a),a}catch(a){throw se.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function x4(n,e){const t=U(n,"real","complex"),s=U(e,"imag","complex");pr(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return se.runKernel(Wx,r)}const ll=J({complex_:x4});function Cl(n,e,t,s){if(s==null)s=Mu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(XR(n)||qR(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return se.backend.createTensorFromGPUData(n,e||t,s)}if(!ki(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Yr(e);const r=ce(e),i=ce(t);B(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let a=0;a<t.length;++a){const o=t[a],u=a===t.length-1?o!==ce(e.slice(a)):!0;B(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!ki(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Bu(n,s):lo(n,[],!0),se.makeTensor(n,e,s)}function Wi(n,e,t){const s=Sl(n,t);return Cl(n,e,s,t)}const Nu={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ji{static join(e){return new Ji(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>ki(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),a=new Uint8Array(i);let o=0;for(let u=s;u<this.shards.length;u++){const c=this.shards[u],p=e+o-c.start,m=o,x=Math.min(t,c.end)-c.start,b=new Uint8Array(c.buffer,p,x-p);if(a.set(b,m),o+=b.length,t<c.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=b4(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function b4(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}function Gs(){return se}function HI(){return se.memory()}function he(n,e){return se.tidy(n,e)}function rt(n){KR(n).forEach(t=>t.dispose())}function ms(n){return se.keep(n)}function v4(){return se.ready()}function lf(){return se.backendName}function fS(n,e,t=1){return se.registerBackend(n,e,t)}function ku(){return se.backend}const ul=4;async function n2(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const o=r[a],u=Array.isArray(n)?n[a].tensor:n[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);const c={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const d=new Promise(async p=>{const m=await u.bytes(),g=m.reduce((v,w)=>v+w.length,0)+ul*m.length,x=new Uint8Array(g);let b=0;for(let v=0;v<m.length;v++){const w=m[v],N=new Uint8Array(new Uint32Array([w.length]).buffer);x.set(N,b),b+=ul,x.set(w,b),b+=w.length}p(x)});s.push(d)}else s.push(u.data());e!=null&&(c.group=e),t.push(c)}const i=await Promise.all(s);return{data:C4(i),specs:t}}function n3(n,e){const t=new Ji(n),s={};let r=0;for(const i of e){const a=w4(i,(o,u)=>t.slice(r+o,r+u));s[i.name]=s3(i,t.slice(r,r+a)),r+=a}return s}function w4(n,e){const t=ce(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Nu[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=ul+new Uint32Array(e(r,r+ul))[0];return r}else s=Nu[n.dtype];return t*s}async function S4(n,e){const t=ce(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Nu[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=ul+new Uint32Array(await e(r,r+ul))[0];return r}else s=Nu[n.dtype];return t*s}function s3(n,e){const t=n.name,s=n.dtype,r=n.shape,i=ce(r);let a,o=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=Nu[u.dtype],d=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){a=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];a[p]=m*u.scale+u.min}}else if(u.dtype==="float16")a=E4()(d);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);a=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];a[p]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*c}else if(s==="string"){const u=ce(n.shape);a=[];for(let c=0;c<u;c++){const d=new Uint32Array(e.slice(o,o+ul))[0];o+=ul;const p=new Uint8Array(e.slice(o,o+d));a.push(p),o+=d}}else{const u=Nu[s];if(s==="float32")a=new Float32Array(e);else if(s==="int32")a=new Int32Array(e);else if(s==="bool")a=new Uint8Array(e);else if(s==="complex64"){a=new Float32Array(e);const c=new Float32Array(a.length/2),d=new Float32Array(a.length/2);for(let x=0;x<c.length;x++)c[x]=a[x*2],d[x]=a[x*2+1];const p=Wi(c,r,"float32"),m=Wi(d,r,"float32"),g=ll(p,m);return p.dispose(),m.dispose(),g}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*u}return Wi(a,r,s)}async function jI(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:i}=await n.read();if(r&&i==null){const o=t-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(s.length+i.byteLength);a.set(s,0),a.set(new Uint8Array(i),s.length),s=a}return s.buffer}async function r3(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of e){const a=await S4(i,async(c,d)=>(r=await jI(s,r,d),r.slice(c,d)));r=await jI(s,r,a);const o=r.slice(0,a);r=r.slice(a);const u=s3(i,o);if(t[i.name]=u,lf()==="webgpu"){const c=ku();"uploadToGPU"in c&&ce(u.shape)>=fe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(u.dataId)}}return t}function C4(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const mS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function qI(n){return mS?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function N4(n){if(mS)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function k4(n){if(mS){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function i3(n){return Ji.join(n)}function XI(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function a3(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function o3(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function gS(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),o3(n,t,s)}function Tm(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:qI(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:qI(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Ji(n.weightData).byteLength}}function s2(n){const e=[];for(const t of n)e.push(...t.weights);return e}function $4(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function I4(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function T4(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function E4(){const n=$4(),e=I4(),t=T4();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const o=s[a],u=n[t[o>>10]+(o&1023)]+e[o>>10];i[a]=u}return new Float32Array(r)}}class Nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Nn.instance==null&&(Nn.instance=new Nn),Nn.instance}static registerSaveRouter(e){Nn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Nn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Nn.getHandlers(e,"save")}static getLoadHandlers(e,t){return Nn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?Nn.getInstance().loadRouters:Nn.getInstance().saveRouters).forEach(a=>{const o=a(e,s);o!==null&&r.push(o)}),r}}const R4=n=>Nn.registerSaveRouter(n),A4=n=>Nn.registerLoadRouter(n),l3=n=>Nn.getSaveHandlers(n),D4=(n,e)=>Nn.getLoadHandlers(n,e);const r2="tensorflowjs",i2=1,fu="models_store",el="model_info_store";function u3(){if(!fe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function a2(n){const e=n.result;e.createObjectStore(fu,{keyPath:"modelPath"}),e.createObjectStore(el,{keyPath:"modelPath"})}class $u{constructor(e){if(this.indexedDB=u3(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(r2,i2);i.onupgradeneeded=()=>a2(i),i.onsuccess=()=>{const a=i.result;if(t==null){const o=a.transaction(fu,"readonly"),c=o.objectStore(fu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),r(c.error)),o.oncomplete=()=>a.close()}else{t.weightData=Ji.join(t.weightData);const o=Tm(t),u=a.transaction(el,"readwrite");let c=u.objectStore(el),d;try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(m){return r(m)}let p;d.onsuccess=()=>{p=a.transaction(fu,"readwrite");const m=p.objectStore(fu);let g;try{g=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(x){return r(x)}g.onsuccess=()=>s({modelArtifactsInfo:o}),g.onerror=x=>{c=u.objectStore(el);const b=c.delete(this.modelPath);b.onsuccess=()=>(a.close(),r(g.error)),b.onerror=v=>(a.close(),r(g.error))}},d.onerror=m=>(a.close(),r(d.error)),u.oncomplete=()=>{p==null?a.close():p.oncomplete=()=>a.close()}}},i.onerror=a=>r(i.error)})}}$u.URL_SCHEME="indexeddb://";const c3=n=>fe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith($u.URL_SCHEME)?_4(n.slice($u.URL_SCHEME.length)):null;Nn.registerSaveRouter(c3);Nn.registerLoadRouter(c3);function _4(n){return new $u(n)}function O4(n){return n.startsWith($u.URL_SCHEME)?n.slice($u.URL_SCHEME.length):n}class F4{constructor(){this.indexedDB=u3()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(r2,i2);s.onupgradeneeded=()=>a2(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(el,"readonly"),o=i.objectStore(el).getAll();o.onsuccess=()=>{const u={};for(const c of o.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},o.onerror=u=>(r.close(),t(o.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=O4(e),new Promise((t,s)=>{const r=this.indexedDB.open(r2,i2);r.onupgradeneeded=()=>a2(r),r.onsuccess=()=>{const i=r.result,a=i.transaction(el,"readwrite"),o=a.objectStore(el),u=o.get(e);let c;u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=o.delete(e),p=()=>{c=i.transaction(fu,"readwrite");const g=c.objectStore(fu).delete(e);g.onsuccess=()=>t(u.result.modelArtifactsInfo),g.onerror=x=>s(u.error)};d.onsuccess=p,d.onerror=m=>(p(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const so="/",nh="tensorflowjs_models",h3="info",z4="model_topology",L4="weight_specs",M4="weight_data",P4="model_metadata";function d3(n){return{info:[nh,n,h3].join(so),topology:[nh,n,z4].join(so),weightSpecs:[nh,n,L4].join(so),weightData:[nh,n,M4].join(so),modelMetadata:[nh,n,P4].join(so)}}function p3(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function B4(n){const e=n.split(so);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(so)}function V4(n){return n.startsWith(Iu.URL_SCHEME)?n.slice(Iu.URL_SCHEME.length):n}class Iu{constructor(e){if(!fe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=d3(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Tm(e),i=Ji.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,N4(i));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw p3(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const o=JSON.parse(i);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=k4(a),t}}Iu.URL_SCHEME="localstorage://";const f3=n=>fe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Iu.URL_SCHEME)?U4(n.slice(Iu.URL_SCHEME.length)):null;Nn.registerSaveRouter(f3);Nn.registerLoadRouter(f3);function U4(n){return new Iu(n)}class W4{constructor(){B(fe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),B(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=nh+so,s=so+h3;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const a=B4(i);e[a]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=V4(e);const t=d3(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return p3(t),s}}const ih="://";class Hs{constructor(){this.managers={}}static getInstance(){return Hs.instance==null&&(Hs.instance=new Hs),Hs.instance}static registerManager(e,t){B(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ih)&&(e=e.slice(0,e.indexOf(ih))),B(e.length>0,()=>"scheme must not be an empty string.");const s=Hs.getInstance();B(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Hs.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Hs.getInstance().managers)}}function My(n){if(n.indexOf(ih)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Hs.getSchemes().join(",")}`);return{scheme:n.split(ih)[0],path:n.split(ih)[1]}}async function m3(n,e,t=!1){B(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=Nn.getLoadHandlers(n);B(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),B(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=Nn.getSaveHandlers(e);B(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),B(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=i[0],o=My(n).scheme,u=My(n).path,c=o===My(n).scheme,d=await r.load();t&&c&&await Hs.getManager(o).removeModel(u);const p=await a.save(d);return t&&!c&&await Hs.getManager(o).removeModel(u),p.modelArtifactsInfo}async function G4(){const n=Hs.getSchemes(),e={};for(const t of n){const s=await Hs.getManager(t).listModels();for(const r in s){const i=t+ih+r;e[i]=s[r]}}return e}async function H4(n){const e=My(n);return Hs.getManager(e.scheme).removeModel(e.path)}async function j4(n,e){return m3(n,e,!1)}async function q4(n,e){return m3(n,e,!0)}class X4{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!fe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return VR(e)}}if(fe().get("IS_BROWSER")){fe().setPlatform("browser",new X4);try{Hs.registerManager(Iu.URL_SCHEME,new W4)}catch{}try{Hs.registerManager($u.URL_SCHEME,new F4)}catch{}}const K4={importFetch:()=>require("node-fetch")};let pw;class Y4{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return fe().global.fetch!=null?fe().global.fetch(e,t):(pw==null&&(pw=K4.importFetch()),pw(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}fe().get("IS_NODE")&&!fe().get("IS_BROWSER")&&fe().setPlatform("node",new Y4);function ft(n,e="float32",t){return e=e||"float32",Yr(n),new es(n,e,t)}function Q4(n,e){const t=U(n,"x","cast");if(!zB(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return se.runKernel(zh,s,r)}const Fe=J({cast_:Q4});function Z4(n){const t={x:U(n,"x","clone","string_or_numeric")};return se.runKernel(Kh,t)}const io=J({clone_:Z4});function g3(n,e=!1){console.log(n.toString(e))}QR();const J4={buffer:ft,cast:Fe,clone:io,print:g3};h4(J4);function eV(n,e){let t=U(n,"a","add"),s=U(e,"b","add");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(Pu,r)}const $e=J({add_:eV});function tV(n,e){let t=U(n,"a","floorDiv"),s=U(e,"b","floorDiv");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(qh,r)}const yS=J({floorDiv_:tV});function nV(n,e){let t=U(n,"a","div"),s=U(e,"b","div");if([t,s]=An(t,s),t.dtype==="int32"&&s.dtype==="int32")return yS(t,s);const r={a:t,b:s},i={};return se.runKernel(Vh,r,i)}const Ve=J({div_:nV});function sV(n,e){let t=U(n,"a","mul"),s=U(e,"b","mul");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(rd,r)}const Q=J({mul_:sV});function rV(n){const e=U(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return se.runKernel(Ff,t)}else{const t={x:e};return se.runKernel(If,t)}}const Qn=J({abs_:rV});function iV(n){const t={x:U(n,"x","acos")};return se.runKernel(Eh,t)}const y3=J({acos_:iV});function aV(n){const t={x:U(n,"x","acosh")};return se.runKernel(Rh,t)}const x3=J({acosh_:aV});function oV(n){B(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),B(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>U(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!xt(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return se.runKernel(Tf,s)}const lV=J({addN_:oV});function uV(n,e=null,t=!1){const r={x:U(n,"x","all","bool")},i={axis:e,keepDims:t};return se.runKernel(zx,r,i)}const xS=J({all_:uV});function cV(n,e=null,t=!1){const r={x:U(n,"x","any","bool")},i={axis:e,keepDims:t};return se.runKernel(Lx,r,i)}const ix=J({any_:cV});function hV(n,e=0){const s={x:U(n,"x","argMax")},r={axis:e};return se.runKernel(Ef,s,r)}const Tu=J({argMax_:hV});function dV(n,e=0){const s={x:U(n,"x","argMin")},r={axis:e};return se.runKernel(Rf,s,r)}const b3=J({argMin_:dV});function pV(n){const t={x:U(n,"x","asin")};return se.runKernel(Ah,t)}const v3=J({asin_:pV});function fV(n){const t={x:U(n,"x","asinh")};return se.runKernel(Dh,t)}const w3=J({asinh_:fV});function mV(n){const t={x:U(n,"x","atan")};return se.runKernel(_h,t)}const S3=J({atan_:mV});function gV(n,e){let t=U(n,"a","atan2"),s=U(e,"b","atan2");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(Fh,r)}const C3=J({atan2_:gV});function yV(n){const t={x:U(n,"x","atanh")};return se.runKernel(Oh,t)}const N3=J({atanh_:yV});function Nl(n,e,t,s,r="NHWC",i){const a=n[3],o=[...e,a],u=Dr(r);return fn(n,o,t,i,s,null,null,u)}function zs(n,e,t,s,r,i,a="channelsLast"){const[o,u]=uf(e);let c;if(a==="channelsLast")c=[o,u,n[3],n[3]];else if(a==="channelsFirst")c=[o,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return fn(n,c,t,s,r,i,!1,a)}function Qr(n,e,t,s,r,i,a="NDHWC"){const[o,u,c]=o2(e);let d,p;if(a==="NDHWC")p="channelsLast",d=[o,u,c,n[4],n[4]];else if(a==="NCDHW")p="channelsFirst",d=[o,u,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return ea(n,d,t,s,r,!1,p,i)}function fn(n,e,t,s,r,i,a=!1,o="channelsLast"){let[u,c,d,p]=[-1,-1,-1,-1];if(o==="channelsLast")[u,c,d,p]=n;else if(o==="channelsFirst")[u,p,c,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,g,,x]=e,[b,v]=uf(t),[w,N]=uf(s),I=ah(m,w),$=ah(g,N),{padInfo:E,outHeight:D,outWidth:F}=vV(r,c,d,b,v,I,$,i,o),L=a?x*p:x;let z;return o==="channelsFirst"?z=[u,L,D,F]:o==="channelsLast"&&(z=[u,D,F,L]),{batchSize:u,dataFormat:o,inHeight:c,inWidth:d,inChannels:p,outHeight:D,outWidth:F,outChannels:L,padInfo:E,strideHeight:b,strideWidth:v,filterHeight:m,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:$,dilationHeight:w,dilationWidth:N,inShape:n,outShape:z,filterShape:e}}function ea(n,e,t,s,r,i=!1,a="channelsLast",o){let[u,c,d,p,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,c,d,p,m]=n;else if(a==="channelsFirst")[u,m,c,d,p]=n;else throw new Error(`Unknown dataFormat ${a}`);const[g,x,b,,v]=e,[w,N,I]=o2(t),[$,E,D]=o2(s),F=ah(g,$),L=ah(x,E),z=ah(b,D),{padInfo:M,outDepth:O,outHeight:H,outWidth:X}=wV(r,c,d,p,w,N,I,F,L,z,o),te=i?v*m:v;let Z;return a==="channelsFirst"?Z=[u,te,O,H,X]:a==="channelsLast"&&(Z=[u,O,H,X,te]),{batchSize:u,dataFormat:a,inDepth:c,inHeight:d,inWidth:p,inChannels:m,outDepth:O,outHeight:H,outWidth:X,outChannels:te,padInfo:M,strideDepth:w,strideHeight:N,strideWidth:I,filterDepth:g,filterHeight:x,filterWidth:b,effectiveFilterDepth:F,effectiveFilterHeight:L,effectiveFilterWidth:z,dilationDepth:$,dilationHeight:E,dilationWidth:D,inShape:n,outShape:Z,filterShape:e}}function xV(n,e,t,s,r){s==null&&(s=bS(n,e,t));const i=n[0],a=n[1],o=cf((i-e+2*s)/t+1,r),u=cf((a-e+2*s)/t+1,r);return[o,u]}function bV(n,e,t,s,r,i){r==null&&(r=bS(n,e[0],s[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*r>=e[o]&&(a[o]=cf((n[o]-e[o]+2*r)/s[o]+1,i));return a}function bS(n,e,t,s=1){const r=ah(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function uf(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function o2(n){return typeof n=="number"?[n,n,n]:n}function ah(n,e){return e<=1?n:n+(n-1)*(e-1)}function vV(n,e,t,s,r,i,a,o,u){let c,d,p;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const g=xV([e,t],i,s,n,o);d=g[0],p=g[1]}else if(n==="same"){d=Math.ceil(e/s),p=Math.ceil(t/r);const m=Math.max(0,(d-1)*s+i-e),g=Math.max(0,(p-1)*r+a-t),x=Math.floor(m/2),b=m-x,v=Math.floor(g/2),w=g-v;c={top:x,bottom:b,left:v,right:w,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-i+1)/s),p=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],g=u==="channelsLast"?n[1][1]:n[2][1],x=u==="channelsLast"?n[2][0]:n[3][0],b=u==="channelsLast"?n[2][1]:n[3][1];c={top:m,bottom:g,left:x,right:b,type:m===0&&g===0&&x===0&&b===0?"VALID":"EXPLICIT"},d=cf((e-i+m+g)/s+1,o),p=cf((t-a+x+b)/r+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:d,outWidth:p}}function wV(n,e,t,s,r,i,a,o,u,c,d){let p,m,g,x;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const v=bV([e,t,s,1],[o,u,c],1,[r,i,a],n,d);m=v[0],g=v[1],x=v[2]}else if(n==="same"){m=Math.ceil(e/r),g=Math.ceil(t/i),x=Math.ceil(s/a);const b=(m-1)*r+o-e,v=(g-1)*i+u-t,w=(x-1)*a+c-s,N=Math.floor(b/2),I=b-N,$=Math.floor(v/2),E=v-$,D=Math.floor(w/2),F=w-D;p={top:$,bottom:E,left:D,right:F,front:N,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:g,outWidth:x}}function cf(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function cl(n){const[e,t,s]=uf(n);return e===1&&t===1&&s===1}function is(n,e){return cl(n)||cl(e)}function Eu(n){return uf(n).every(e=>e>0)}function Dr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Qs(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")B(hh(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{B(hh(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function SV(n,e){const s={x:U(n,"x","reshape","string_or_numeric")},r={shape:e};return se.runKernel(mm,s,r)}const ae=J({reshape_:SV});function CV(n,e,t,s,r){const i=U(n,"x","avgPool","float32"),a=1;B(is(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=i,u=!1;i.rank===3&&(u=!0,o=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]])),B(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Qs("avgPool",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let p=se.runKernel(Af,c,d);return p=Fe(p,i.dtype),u?ae(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const F0=J({avgPool_:CV});function NV(n,e,t,s,r,i="NDHWC"){const a=U(n,"x","avgPool3d","float32");let o=a,u=!1;a.rank===4&&(u=!0,o=ae(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),B(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),B(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Qs("avgPool3d",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let p=se.runKernel(Df,c,d);return p=Fe(p,o.dtype),u?ae(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const k3=J({avgPool3d_:NV});function kV(n,e=0){B(n.length>=1,()=>"Pass at least one tensor to concat");const t=rx(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return io(t[0]);const s=t,r={axis:e};return se.runKernel(zf,s,r)}const $n=J({concat_:kV});function $V(n,e,t=!1,s=!1){let r=U(n,"a","matMul"),i=U(e,"b","matMul");[r,i]=An(r,i);const a={a:r,b:i},o={transposeA:t,transposeB:s};return se.runKernel(_f,a,o)}const kt=J({matMul_:$V});function IV(n){const t={x:U(n,"x","sigmoid","float32")};return se.runKernel(md,t)}const qr=J({sigmoid_:IV});function TV(n,e,t){const s=U(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return se.runKernel(vm,r,i)}const dt=J({slice_:TV});function EV(n){const t={x:U(n,"x","tanh","float32")};return se.runKernel(wd,t)}const Ru=J({tanh_:EV});function RV(n,e,t,s,r,i){const a=U(n,"forgetBias","basicLSTMCell"),o=U(e,"lstmKernel","basicLSTMCell"),u=U(t,"lstmBias","basicLSTMCell"),c=U(s,"data","basicLSTMCell"),d=U(r,"c","basicLSTMCell"),p=U(i,"h","basicLSTMCell"),m=$n([c,p],1),g=kt(m,o),x=$e(g,u),b=x.shape[0],v=x.shape[1]/4,w=[b,v],N=dt(x,[0,0],w),I=dt(x,[0,v],w),$=dt(x,[0,v*2],w),E=dt(x,[0,v*3],w),D=$e(Q(qr(N),Ru(I)),Q(d,qr($e(a,$)))),F=Q(Ru(D),qr(E));return[D,F]}const AV=J({basicLSTMCell_:RV});function DV(n,e,t){const s=U(n,"x","batchToSpaceND"),r=e.reduce((o,u)=>o*u);B(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),B(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),B(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},a={blockShape:e,crops:t};return se.runKernel(Of,i,a)}const z0=J({batchToSpaceND_:DV});function _V(n){let e;return n.rank===0||n.rank===1?e=ae(n,[1,1,1,n.size]):n.rank===2?e=ae(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ae(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function OV(n,e,t,s,r,i){i==null&&(i=.001);const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),u=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;s!=null&&(d=U(s,"offset","batchNorm")),B(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:_V(a),scale:c,offset:d,mean:o,variance:u},g={varianceEpsilon:i},x=se.runKernel(Hf,m,g);return ae(x,a.shape)}const Em=J({batchNorm_:OV});function FV(n,e,t,s,r,i){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),u=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),B(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),B(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),B(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&B(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),d!=null&&B(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),Em(a,o,u,d,c,i)}const $3=J({batchNorm2d_:FV});function zV(n,e,t,s,r,i){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),u=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),B(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),B(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),B(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&B(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),d!=null&&B(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),Em(a,o,u,d,c,i)}const I3=J({batchNorm3d_:zV});function LV(n,e,t,s,r,i){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),u=U(t,"variance","batchNorm");let c;r!=null&&(c=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),B(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),B(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),B(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&B(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),d!=null&&B(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),Em(a,o,u,d,c,i)}const T3=J({batchNorm4d_:LV});function MV(n,e,t){const s=U(n,"x","bincount"),r=U(e,"weights","bincount");B(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),B(t>=0,()=>`size must be non-negative, but got ${t}.`),B(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},a={size:t};return se.runKernel(Bx,i,a)}const E3=J({bincount_:MV});function PV(n,e){const t=U(n,"x","bitwiseAnd"),s=U(e,"y","bitwiseAnd");if(!xt(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return se.runKernel(Vx,r)}const BV=J({bitwiseAnd_:PV});function VV(n,e){const t=U(n,"s0","broadcastArgs","int32"),s=U(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return se.runKernel(Ux,r)}const UV=J({broadcastArgs_:VV});function WV(n,e){let t=U(n,"broadcastTo","x");const s=t.shape;if(Yr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ae(t,c)}const r=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return io(t);const o={x:t},u={reps:i};return se.runKernel(Sd,o,u)}const oh=J({broadcastTo_:WV});function GV(n){const t={x:U(n,"x","ceil","float32")};return se.runKernel(Lh,t)}const R3=J({ceil_:GV});function Nd(n,e,t){Yr(n),t=t||Mu(e);const s={shape:n,value:e,dtype:t};return se.runKernel(s0,{},s)}function HV(n,e,t){const s=U(n,"x","clipByValue");if(B(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Nd(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return se.runKernel(Mh,r,i)}const hr=J({clipByValue_:HV});function jV(n){return $n(n,0)}const A3=J({concat1d_:jV});function qV(n,e){return $n(n,e)}const D3=J({concat2d_:qV});function XV(n,e){return $n(n,e)}const _3=J({concat3d_:XV});function KV(n,e){return $n(n,e)}const O3=J({concat4d_:KV});function YV(n,e,t,s,r="NHWC",i=[1,1],a){const o=U(n,"x","conv2d","float32"),u=U(e,"filter","conv2d","float32");let c=o,d=!1;o.rank===3&&(d=!0,c=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),B(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),B(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Qs("conv2d",s,a);const p=r==="NHWC"?c.shape[3]:c.shape[1];B(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),B(is(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),B(Eu(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),B(Eu(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:c,filter:u},g={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},x=se.runKernel(Lf,m,g);return d?ae(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const hl=J({conv2d_:YV});function QV(n,e,t,s,r="NWC",i=1,a){const o=U(n,"x","conv1d"),u=U(e,"filter","conv1d");let c=o,d=!1;o.rank===2&&(d=!0,c=ae(o,[1,o.shape[0],o.shape[1]])),B(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),B(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Qs("conv1d",s,a),B(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),B(is(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),B(Eu(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),B(Eu(t),()=>"Error in conv1D: Stride should be larger than 0."),B(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=ae(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=ae(c,[c.shape[0],1,c.shape[1],c.shape[2]]),v=hl(m,p,[1,t],s,"NHWC",[1,i],a);return d?ae(v,[v.shape[2],v.shape[3]]):ae(v,[v.shape[0],v.shape[2],v.shape[3]])}const vS=J({conv1d_:QV});function ZV(n,e,t,s,r,i="NHWC",a){B(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,u=e,c=!1;e.rank===3&&(c=!0,u=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),B(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),B(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),B(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=i==="NHWC"?o[3]:o[1],p=i==="NHWC"?u.shape[3]:u.shape[1];B(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),B(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),Qs("conv2dDerInput",r,a);const m={dy:u,filter:t},g={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o},x=se.runKernel(Mf,m,g);return c?ae(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const wS=J({conv2DBackpropInput_:ZV});function JV(n,e,t,s,r,i){const a=U(n,"x","conv2dTranspose"),o=U(e,"filter","conv2dTranspose");return wS(t,a,o,s,r,"NHWC",i)}const SS=J({conv2dTranspose_:JV});function eU(n,e,t,s,r="NDHWC",i=[1,1,1]){const a=U(n,"x","conv3d"),o=U(e,"filter","conv3d");let u=a,c=!1;a.rank===4&&(c=!0,u=ae(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),B(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),B(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),B(is(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),B(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),B(Eu(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),B(Eu(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:u,filter:o},p={strides:t,pad:s,dataFormat:r,dilations:i},m=se.runKernel(Pf,d,p);return c?ae(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const F3=J({conv3d_:eU});function tU(n,e,t,s,r){B(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,a=e,o=!1;e.rank===4&&(o=!0,a=ae(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const u=i[4],c=a.shape[4];B(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),B(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),B(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),B(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),B(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const d={dy:a,filter:t},p={pad:r,strides:s,inputShape:i},m=se.runKernel(jx,d,p);return o?ae(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const z3=J({conv3DBackpropInput_:tU});function nU(n,e,t,s,r){const i=U(n,"x","conv3dTranspose"),a=U(e,"filter","conv3dTranspose");return z3(t,i,a,s,r)}const L3=J({conv3dTranspose_:nU});function sU(n){const t={x:U(n,"x","cos","float32")};return se.runKernel(Ph,t)}const L0=J({cos_:sU});function rU(n){const t={x:U(n,"x","cosh","float32")};return se.runKernel(Bh,t)}const CS=J({cosh_:rU});function iU(n,e=0,t=!1,s=!1){const i={x:U(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return se.runKernel(qx,i,a)}const ax=J({cumprod_:iU});function aU(n,e=0,t=!1,s=!1){const i={x:U(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return se.runKernel(Bf,i,a)}const NS=J({cumsum_:aU});function oU(n,e,t,s=!1){const r=U(n,"x","denseBincount"),i=U(e,"weights","denseBincount");B(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),B(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),B(t>=0,()=>`size must be non-negative, but got ${t}.`),B(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const a={x:r,weights:i},o={size:t,binaryOutput:s};return se.runKernel(Kx,a,o)}const l2=J({denseBincount_:oU});function lU(n,e,t="NHWC"){const s=U(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];B(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),B(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),B(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),B(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},u={blockSize:e,dataFormat:t};return se.runKernel(Yx,o,u)}const M3=J({depthToSpace_:lU});function uU(n,e,t,s,r="NHWC",i=[1,1],a){const o=U(n,"x","depthwiseConv2d","float32"),u=U(e,"filter","depthwiseConv2d","float32");let c=o,d=!1;o.rank===3&&(d=!0,c=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),B(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),B(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const p=r==="NHWC"?c.shape[3]:c.shape[1];B(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),Qs("depthwiseConv2d",s,a);const m={x:c,filter:u},g={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},x=se.runKernel(Vf,m,g);return d?ae(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const Rm=J({depthwiseConv2d_:uU});function cU(n){const t={x:U(n,"x","diag")};return se.runKernel(Jx,t)}const hU=J({diag_:cU});function dU(n,e,t,s,r=[1,1],i="NHWC"){const a=U(n,"x","dilation2d"),o=U(e,"filter","dilation2d");B(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),B(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),B(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=a,c=!1;a.rank===3&&(u=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0),B(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const d={x:u,filter:o},p={strides:t,pad:s,dilations:r},m=se.runKernel(Uf,d,p);return c?ae(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const P3=J({dilation2d_:dU});function dl(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,a=n[i]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(i)}return s}function rs(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,a=e[i];(r==null||r===1&&a>1)&&t.unshift(i)}return t}function it(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let a=e[e.length-r-1];if(a==null&&(a=1),i===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=i;else if(i!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else s[t-r-1]=i}return s}function pU(n,e){let t=U(n,"a","equal","string_or_numeric"),s=U(e,"b","equal","string_or_numeric");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Wf,r)}const ji=J({equal_:pU});function fU(n,e,t){const s=U(e,"a","where"),r=U(t,"b","where"),i=U(n,"condition","where","bool"),a=it(it(i.shape,s.shape),r.shape),o=oh(i,a),u=oh(s,a),c=oh(r,a),d={condition:o,t:u,e:c};return se.runKernel(bm,d)}const Fs=J({where_:fU});function mU(n){const t={x:U(n,"x","zerosLike")};return se.runKernel(Im,t)}const Ot=J({zerosLike_:mU});function gU(n,e){let t=U(n,"a","div"),s=U(e,"b","div");[t,s]=An(t,s);const r=Ve(t,s),i=Ot(r),a=ji(s,i);return Fs(a,i,r)}const B3=J({divNoNan_:gU});function yU(n,e){const t=U(n,"t1","dot"),s=U(e,"t2","dot");B((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(B(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const a=ae(t,[1,-1]),o=ae(s,[-1,1]),u=kt(a,o);return ae(u,[])}else if(t.rank===1&&s.rank===2){const a=ae(t,[1,-1]),o=ae(s,[s.shape[0],s.shape[1]]),u=kt(a,o);return ae(u,[u.size])}else if(t.rank===2&&s.rank===1){const a=ae(s,[-1,1]),o=kt(t,a);return ae(o,[o.size])}else{const a=ae(s,[s.shape[0],s.shape[1]]);return kt(t,a)}}const V3=J({dot_:yU});function xU(n,...e){const t=e.map((r,i)=>U(r,`tensors${i}`,"einsum")),s={equation:n};return se.runKernel(e0,t,s)}const sh=J({einsum_:xU});function bU(n){const t={x:U(n,"x","elu","float32")};return se.runKernel(Uh,t)}const Am=J({elu_:bU});function vU(n,e){const t=U(n,"x","ensureShape","string_or_numeric");if(!OB(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const wU=J({ensureShape_:vU});function SU(n){let e=U(n,"x","erf");B(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Fe(e,"float32"));const t={x:e};return se.runKernel(Wh,t)}const kS=J({erf_:SU});function $S(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function U3(n,e,t){const s=n.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?r.push(n[i++]):r.push(e[a++]);return r}function Mn(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function Dn(n,e){const t=e.map(s=>1);return U3(n,t,e)}function Hn(n,e,t){B($S(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function sn(n,e){if($S(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function $a(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function mn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function CU(n,e=null,t=!1){const r={x:U(n,"x","max")},i={reductionIndices:e,keepDims:t};return se.runKernel(tm,r,i)}const Ci=J({max_:CU});function NU(n,e=null,t=!1){const r={x:U(n,"x","min")},i={axis:e,keepDims:t};return se.runKernel(im,r,i)}const hf=J({min_:NU});function kU(n,e){let t=U(n,"base","pow"),s=U(e,"exp","pow");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(id,r)}const uo=J({pow_:kU});function Je(n,e){if((ki(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&ki(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Cl(n,[],[],e)}function $U(n){const t={x:U(n,"x","sqrt","float32")};return se.runKernel(yd,t)}const ks=J({sqrt_:$U});function IU(n){const e=U(n,"x","square"),t={};return se.runKernel("Square",{x:e},t)}const tn=J({square_:IU});function TU(n,e=null,t=!1){let s=U(n,"x","sum");s.dtype==="bool"&&(s=Fe(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return se.runKernel(wm,r,i)}const Ke=J({sum_:TU});function EU(n,e="euclidean",t=null,s=!1){n=U(n,"x","norm");const r=W3(n,e,t);let i=r.shape;if(s){const a=gt(t,n.shape);i=Dn(r.shape,a)}return ae(r,i)}function W3(n,e,t=null){if(n.rank===0)return Qn(n);if(n.rank!==1&&t===null)return W3(ae(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ke(Qn(n),t);if(e===1/0)return Ci(Qn(n),t);if(e===-1/0)return hf(Qn(n),t);if(e==="euclidean"||e===2)return ks(Ke(uo(Qn(n),Je(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Ci(Ke(Qn(n),t[0]),t[1]-1);if(e===1/0)return Ci(Ke(Qn(n),t[1]),t[0]);if(e===-1/0)return hf(Ke(Qn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return ks(Ke(tn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Dm=J({norm_:EU});function RU(n,e=null,t=!1){return Dm(n,"euclidean",e,t)}const G3=J({euclideanNorm_:RU});function AU(n){const t={x:U(n,"x","exp")};return se.runKernel(Gh,t)}const Ks=J({exp_:AU});function DU(n,e=0){const t=U(n,"x","expandDims","string_or_numeric");B(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return se.runKernel(Gf,s,r)}const Wn=J({expandDims_:DU});function _U(n){const t={x:U(n,"x","expm1")};return se.runKernel(Hh,t)}const H3=J({expm1_:_U});function OU(n,e){const t=U(n,"x","tile","string_or_numeric");B(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return se.runKernel(Sd,s,r)}const bi=J({tile_:OU});function FU(n,e,t,s="float32"){e==null&&(e=n);const r=ft([n,e],s),i=n<=e?n:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=ae(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return bi(Wn(a,0),[t[0],1,1]);if(t.length===2)return bi(Wn(Wn(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return bi(Wn(Wn(Wn(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const IS=J({eye_:FU});function zU(n){const t={x:U(n,"x","floor","float32")};return se.runKernel(jh,t)}const _m=J({floor_:zU});function LU(n,e,t=0,s=0){const r=U(n,"x","gather"),i=U(e,"indices","gather","int32"),a={x:r,indices:i},o={axis:t,batchDims:s};return se.runKernel(jf,a,o)}const Om=J({gather_:LU});function MU(n,e){let t=U(n,"a","greater","string_or_numeric"),s=U(e,"b","greater","string_or_numeric");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(qf,r)}const _r=J({greater_:MU});function PU(n,e){let t=U(n,"a","greaterEqual","string_or_numeric"),s=U(e,"b","greaterEqual","string_or_numeric");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Xh,r)}const kl=J({greaterEqual_:PU});function BU(n){const t={input:U(n,"input","imag")};return se.runKernel(o0,t)}const M0=J({imag_:BU});function VU(n){const t={x:U(n,"x","isFinite")};return se.runKernel(Yh,t)}const j3=J({isFinite_:VU});function UU(n){const t={x:U(n,"x","isInf")};return se.runKernel(Qh,t)}const q3=J({isInf_:UU});function WU(n){const t={x:U(n,"x","isNaN")};return se.runKernel(Zh,t)}const X3=J({isNaN_:WU});function GU(n,e=.2){const s={x:U(n,"x","leakyRelu")},r={alpha:e};return se.runKernel(Xf,s,r)}const P0=J({leakyRelu_:GU});function HU(n,e){let t=U(n,"a","less","string_or_numeric"),s=U(e,"b","less","string_or_numeric");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Kf,r)}const df=J({less_:HU});function jU(n,e){let t=U(n,"a","lessEqual","string_or_numeric"),s=U(e,"b","lessEqual","string_or_numeric");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Yf,r)}const Vu=J({lessEqual_:jU});function qU(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return se.runKernel(l0,{},s)}function XU(n,e=5,t=1,s=1,r=.5){const i=U(n,"x","localResponseNormalization");B(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),B(hh(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;i.rank===3&&(o=!0,a=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={x:a},c={depthRadius:e,bias:t,alpha:s,beta:r},d=se.runKernel(em,u,c);return o?ae(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const K3=J({localResponseNormalization_:XU});function KU(n){const t={x:U(n,"x","log","float32")};return se.runKernel(Jh,t)}const Xr=J({log_:KU});function YU(n){const t={x:U(n,"x","log1p")};return se.runKernel(ed,t)}const B0=J({log1p_:YU});function QU(n,e){B(Xw(n),()=>"The f passed in variableGrads(f) must be a function"),B(e==null||Array.isArray(e)&&e.every(c=>c instanceof sx),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in se.registeredVariables)e.push(se.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,r=e.length;e=e.filter(c=>c.trainable),B(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:a,grads:o}=se.gradients(n,e,null,i);B(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),B(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const u={};return e.forEach((c,d)=>{o[d]!=null&&(u[c.name]=o[d])}),s?.forEach(c=>u[c.name]=null),{value:a,grads:u}}function co(n){return se.customGrad(n)}function ZU(n){const t={x:U(n,"x","neg")};return se.runKernel(om,t)}const gn=J({neg_:ZU});function JU(n){const t={x:U(n,"x","softplus")};return se.runKernel(gd,t)}const kd=J({softplus_:JU});function eW(n){const e=U(n,"x","logSigmoid");return co(s=>({value:gn(kd(gn(s))),gradFunc:a=>Q(a,qr(gn(s)))}))(e)}const Y3=J({logSigmoid_:eW});function tW(n,e){let t=U(n,"a","sub"),s=U(e,"b","sub");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(bd,r)}const Ue=J({sub_:tW});function nW(n,e=-1){const t=U(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return co((r,i)=>{const o=Ci(r,e,!0),u=Ue(r,o),c=Ue(Fe(u,"float32"),Xr(Ke(Ks(u),e,!0)));return i([c]),{value:c,gradFunc:(p,m)=>{const[g]=m,x=!0,b=Ks(g);return Ue(p,Q(Ke(p,e,x),b))}}})(t)}const TS=J({logSoftmax_:nW});function sW(n,e=null,t=!1){const s=U(n,"x","logSumExp"),r=gt(e,s.shape),i=Ci(s,r,!0),a=Ue(s,i),o=Ks(a),u=Ke(o,r),c=Xr(u),d=$e(ae(i,c.shape),c);if(t){const p=Dn(d.shape,r);return ae(d,p)}return d}const V0=J({logSumExp_:sW});function rW(n,e){const t=U(n,"a","logicalAnd","bool"),s=U(e,"b","logicalAnd","bool");it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Qf,r)}const wa=J({logicalAnd_:rW});function iW(n){const t={x:U(n,"x","logicalNot","bool")};return se.runKernel(Zf,t)}const U0=J({logicalNot_:iW});function aW(n,e){const t=U(n,"a","logicalOr","bool"),s=U(e,"b","logicalOr","bool");it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Jf,r)}const ES=J({logicalOr_:aW});function oW(n,e){const t=U(n,"a","logicalXor","bool"),s=U(e,"b","logicalXor","bool");return it(t.shape,s.shape),wa(ES(n,e),U0(wa(n,e)))}const Q3=J({logicalXor_:oW});const vy=2147483648;function lW(n,e,t="left"){const s=U(n,"sortedSequence","searchSorted"),r=U(e,"values","searchSorted"),i=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],o=ae(s,[-1,i]),u=ae(r,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ce(u.shape)>=vy)throw new Error(`values tensor size must less than ${vy}`);if(o.shape[1]>=vy)throw new Error(`trailing dim_size must less than ${vy} for int32 output type, was ${o.shape[1]}`);const c={sortedSequence:o,values:u},d={side:t};return se.runKernel(S0,c,d)}const RS=J({searchSorted_:lW});function uW(n,e){return RS(n,e,"left")}function cW(n,e,t,s,r){const i=U(n,"x","maxPool"),a=1;let o=i,u=!1;i.rank===3&&(u=!0,o=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]])),B(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),B(is(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Qs("maxPool",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r},p=se.runKernel(nm,c,d);return u?ae(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const W0=J({maxPool_:cW});function hW(n,e=[1,1,1],t,s,r,i="NDHWC"){const a=U(n,"x","maxPool3d");let o=a,u=!1;a.rank===4&&(u=!0,o=ae(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),B(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Qs("maxPool3d",s,r);const c={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},p=se.runKernel(sm,c,d);return u?ae(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Z3=J({maxPool3d_:hW});function dW(n,e,t,s,r=!1){const a={x:U(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},u=se.runKernel(d0,a,o);return{result:u[0],indexes:u[1]}}const pW=J({maxPoolWithArgmax_:dW});function fW(n,e){let t=U(n,"a","maximum"),s=U(e,"b","maximum");[t,s]=An(t,s),t.dtype==="bool"&&(t=Fe(t,"int32"),s=Fe(s,"int32")),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(td,r)}const po=J({maximum_:fW});function mW(n,e=null,t=!1){const r={x:U(n,"x","mean")},i={axis:e,keepDims:t};return se.runKernel(rm,r,i)}const Tn=J({mean_:mW});function zn(n,e="float32"){if(Yr(n),e==="complex64"){const s=zn(n,"float32"),r=zn(n,"float32");return ll(s,r)}const t=Ns(ce(n),e);return se.makeTensor(t,n,e)}function $r(n,e="float32"){if(Yr(n),e==="complex64"){const s=$r(n,"float32"),r=zn(n,"float32");return ll(s,r)}const t=tS(ce(n),e);return se.makeTensor(t,n,e)}function gW(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=U(n,"x","meshgrid",n instanceof Kt?n.dtype:"float32");if(e===void 0)return[s];let r=U(e,"y","meshgrid",e instanceof Kt?e.dtype:"float32");const i=ce(s.shape),a=ce(r.shape);return t==="xy"?(s=ae(s,[1,-1]),r=ae(r,[-1,1]),[kt($r([a,1],s.dtype),s),kt(r,$r([1,i],r.dtype))]):(s=ae(s,[-1,1]),r=ae(r,[1,-1]),[kt(s,$r([1,a],s.dtype)),kt($r([i,1],r.dtype),r)])}function yW(n,e){let t=U(n,"a","minimum"),s=U(e,"b","minimum");[t,s]=An(t,s),t.dtype==="bool"&&(t=Fe(t,"int32"),s=Fe(s,"int32")),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(nd,r)}const pl=J({minimum_:yW});function xW(n,e,t){B(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=U(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");B(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)B(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),B(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},a={x:s};return se.runKernel(am,a,i)}const AS=J({mirrorPad_:xW});function bW(n,e){let t=U(n,"a","mod"),s=U(e,"b","mod");[t,s]=An(t,s);const r={a:t,b:s};return se.runKernel(sd,r)}const J3=J({mod_:bW});function vW(n,e=null,t=!1){n=U(n,"x","moments");const s=gt(e,n.shape),r=Tn(n,s,t);let i=r.shape;t||(i=Dn(r.shape,s));const a=tn(Ue(Fe(n,"float32"),ae(r,i))),o=Tn(a,s,t);return{mean:r,variance:o}}const G0=J({moments_:vW});function wW(n,e,t,s){const r=U(e,"data","multiRNNCell"),i=rx(t,"c","multiRNNCell"),a=rx(s,"h","multiRNNCell");let o=r;const u=[];for(let p=0;p<n.length;p++){const m=n[p](o,i[p],a[p]);u.push(m[0]),u.push(m[1]),o=m[1]}const c=[],d=[];for(let p=0;p<u.length;p+=2)c.push(u[p]),d.push(u[p+1]);return[c,d]}const SW=J({multiRNNCell_:wW});function CW(n,e,t,s=!1){const r=U(n,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const u={logits:a===1?ae(r,[1,-1]):r},c={numSamples:e,seed:t,normalized:s},d=se.runKernel(p0,u,c);return a===1?ae(d,[d.size]):d}const NW=J({multinomial_:CW});function kW(n,e){let t=U(n,"a","notEqual","string_or_numeric"),s=U(e,"b","notEqual","string_or_numeric");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(lm,r)}const ph=J({notEqual_:kW});function $W(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:U(n,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:t,offValue:s};return se.runKernel(cm,a,o)}const DS=J({oneHot_:$W});function IW(n){const t={x:U(n,"x","onesLike")};return se.runKernel(um,t)}const Kr=J({onesLike_:IW});function TW(n,e){const t=U(n,"v1","outerProduct"),s=U(e,"v2","outerProduct");B(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=ae(t,[-1,1]),i=ae(s,[1,-1]);return kt(r,i)}const EW=J({outerProduct_:TW});function RW(n,e,t=0){const s=U(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return se.runKernel(dm,i,r)}const qi=J({pad_:RW});function AW(n,e,t=0){return B(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),qi(n,[e],t)}const DW=J({pad1d_:AW});function _W(n,e,t=0){return B(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qi(n,e,t)}const OW=J({pad2d_:_W});function FW(n,e,t=0){return B(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qi(n,e,t)}const zW=J({pad3d_:FW});function LW(n,e,t=0){return B(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qi(n,e,t)}const MW=J({pad4d_:LW});function PW(n,e,t){const s=U(n,"x","spaceToBatchND");B(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),B(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),B(s.shape.reduce((a,o,u)=>u>0&&u<=e.length?a&&(o+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return se.runKernel(Sm,r,i)}const H0=J({spaceToBatchND_:PW});function BW(n,e,t,s,r,i,a){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const o=U(n,"x","maxPool");let u=o,c=!1;o.rank===3&&(c=!0,u=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),B(is(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=zs(u.shape,e,i,r,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=UW([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const g=p[0]===1&&p[1]===1,[x,b]=VW([d.inHeight,d.inWidth],p,m),v=g?s:"valid",w=g?u:H0(u,p,x),I=(t==="avg"?()=>F0(w,e,i,v,a):()=>W0(w,e,i,v,a))(),$=g?I:z0(I,p,b);return c?ae($,[$.shape[1],$.shape[2],$.shape[3]]):$}function VW(n,e,t){const s=t.map(d=>d[0]),r=t.map(d=>d[1]),i=n.concat(s,r),a=e.map((d,p)=>(d-i[p]%d)%d),o=r.map((d,p)=>d+a[p]),u=e.map((d,p)=>[s[p],o[p]]),c=e.map((d,p)=>[0,a[p]]);return[u,c]}function UW(n,e){const s=n.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),i=s.map((a,o)=>a-r[o]);return s.map((a,o)=>[r[o],i[o]])}const eA=J({pool_:BW});function WW(n,e){const t=U(n,"x","prelu"),s=U(e,"alpha","prelu"),r={x:t,alpha:s};return se.runKernel(pm,r)}const j0=J({prelu_:WW});function GW(n,e=null,t=!1){let s=U(n,"x","prod");s.dtype==="bool"&&(s=Fe(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return se.runKernel(fm,r,i)}const tA=J({prod_:GW});function HW(n,e,t,s){const r=n.map((d,p)=>U(d,`tensors${p}`,"raggedGather","int32")),i=U(e,"paramsDenseValues","raggedGather"),a=U(t,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:i,indices:a},u={outputRaggedRank:s},c=se.runKernel(iS,o,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const jW=J({raggedGather_:HW});function qW(n,e,t){const s=U(n,"starts","raggedRange"),r=U(e,"limits","raggedRange",s.dtype),i=U(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:i},o=se.runKernel(aS,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const XW=J({raggedRange_:qW});function KW(n,e,t,s,r){const i=U(n,"shape","raggedTensorToTensor","int32"),a=U(e,"values","raggedTensorToTensor"),o=U(t,"defaultValue","raggedTensorToTensor",a.dtype),u=s.map((p,m)=>U(p,`tensors${m}`,"raggedTensorToTensor","int32")),c={shape:i,values:a,defaultValue:o,rowPartitionTensors:u},d={rowPartitionTypes:r};return se.runKernel(oS,c,d)}const YW=J({raggedTensorToTensor_:KW});function QW(n,e,t){Yr(n);const s=ce(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<s;i++)r[i]=e();return se.makeTensor(r,n,t)}const ZW=J({rand_:QW});var Py={exports:{}},JW=Py.exports,KI;function eG(){return KI||(KI=1,(function(n){(function(e,t,s){function r(u){var c=this,d=o();c.next=function(){var p=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=p-(c.c=p|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(u),c.s0<0&&(c.s0+=1),c.s1-=d(u),c.s1<0&&(c.s1+=1),c.s2-=d(u),c.s2<0&&(c.s2+=1),d=null}function i(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function a(u,c){var d=new r(u),p=c&&c.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,d),m.state=function(){return i(d,{})}),m}function o(){var u=4022871197,c=function(d){d=String(d);for(var p=0;p<d.length;p++){u+=d.charCodeAt(p);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=a:this.alea=a})(JW,n)})(Py)),Py.exports}var By={exports:{}},tG=By.exports,YI;function nG(){return YI||(YI=1,(function(n){(function(e,t,s){function r(o){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var p=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^p^p>>>8},o===(o|0)?u.x=o:c+=o;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,u.next()}function i(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u}function a(o,u){var c=new r(o),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&i(d,c),p.state=function(){return i(c,{})}),p}t&&t.exports?t.exports=a:this.xor128=a})(tG,n)})(By)),By.exports}var Vy={exports:{}},sG=Vy.exports,QI;function rG(){return QI||(QI=1,(function(n){(function(e,t,s){function r(o){var u=this,c="";u.next=function(){var p=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(p^p<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,o===(o|0)?u.x=o:c+=o;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,d==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u.v=o.v,u.d=o.d,u}function a(o,u){var c=new r(o),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&i(d,c),p.state=function(){return i(c,{})}),p}t&&t.exports?t.exports=a:this.xorwow=a})(sG,n)})(Vy)),Vy.exports}var Uy={exports:{}},iG=Uy.exports,ZI;function aG(){return ZI||(ZI=1,(function(n){(function(e,t,s){function r(o){var u=this;u.next=function(){var d=u.x,p=u.i,m,g;return m=d[p],m^=m>>>7,g=m^m<<24,m=d[p+1&7],g^=m^m>>>10,m=d[p+3&7],g^=m^m>>>3,m=d[p+4&7],g^=m^m<<7,m=d[p+7&7],m=m^m<<13,g^=m^m<<9,d[p]=g,u.i=p+1&7,g};function c(d,p){var m,g=[];if(p===(p|0))g[0]=p;else for(p=""+p,m=0;m<p.length;++m)g[m&7]=g[m&7]<<15^p.charCodeAt(m)+g[m+1&7]<<13;for(;g.length<8;)g.push(0);for(m=0;m<8&&g[m]===0;++m);for(m==8?g[7]=-1:g[m],d.x=g,d.i=0,m=256;m>0;--m)d.next()}c(u,o)}function i(o,u){return u.x=o.x.slice(),u.i=o.i,u}function a(o,u){o==null&&(o=+new Date);var c=new r(o),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},p.int32=c.next,p.quick=p,d&&(d.x&&i(d,c),p.state=function(){return i(c,{})}),p}t&&t.exports?t.exports=a:this.xorshift7=a})(iG,n)})(Uy)),Uy.exports}var Wy={exports:{}},oG=Wy.exports,JI;function lG(){return JI||(JI=1,(function(n){(function(e,t,s){function r(o){var u=this;u.next=function(){var d=u.w,p=u.X,m=u.i,g,x;return u.w=d=d+1640531527|0,x=p[m+34&127],g=p[m=m+1&127],x^=x<<13,g^=g<<17,x^=x>>>15,g^=g>>>12,x=p[m]=x^g,u.i=m,x+(d^d>>>16)|0};function c(d,p){var m,g,x,b,v,w=[],N=128;for(p===(p|0)?(g=p,p=null):(p=p+"\0",g=0,N=Math.max(N,p.length)),x=0,b=-32;b<N;++b)p&&(g^=p.charCodeAt((b+32)%p.length)),b===0&&(v=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,b>=0&&(v=v+1640531527|0,m=w[b&127]^=g+v,x=m==0?x+1:0);for(x>=128&&(w[(p&&p.length||0)&127]=-1),x=127,b=512;b>0;--b)g=w[x+34&127],m=w[x=x+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,w[x]=g^m;d.w=v,d.X=w,d.i=x}c(u,o)}function i(o,u){return u.i=o.i,u.w=o.w,u.X=o.X.slice(),u}function a(o,u){o==null&&(o=+new Date);var c=new r(o),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},p.int32=c.next,p.quick=p,d&&(d.X&&i(d,c),p.state=function(){return i(c,{})}),p}t&&t.exports?t.exports=a:this.xor4096=a})(oG,n)})(Wy)),Wy.exports}var Gy={exports:{}},uG=Gy.exports,eT;function cG(){return eT||(eT=1,(function(n){(function(e,t,s){function r(o){var u=this,c="";u.next=function(){var p=u.b,m=u.c,g=u.d,x=u.a;return p=p<<25^p>>>7^m,m=m-g|0,g=g<<24^g>>>8^x,x=x-p|0,u.b=p=p<<20^p>>>12^m,u.c=m=m-g|0,u.d=g<<16^m>>>16^x,u.a=x-p|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,o===Math.floor(o)?(u.a=o/4294967296|0,u.b=o|0):c+=o;for(var d=0;d<c.length+20;d++)u.b^=c.charCodeAt(d)|0,u.next()}function i(o,u){return u.a=o.a,u.b=o.b,u.c=o.c,u.d=o.d,u}function a(o,u){var c=new r(o),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,x=(m+g)/(1<<21);while(x===0);return x},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&i(d,c),p.state=function(){return i(c,{})}),p}t&&t.exports?t.exports=a:this.tychei=a})(uG,n)})(Gy)),Gy.exports}var Hy={exports:{}};const hG={},dG=Object.freeze(Object.defineProperty({__proto__:null,default:hG},Symbol.toStringTag,{value:"Module"})),pG=ZM(dG);var fG=Hy.exports,tT;function mG(){return tT||(tT=1,(function(n){(function(e,t,s){var r=256,i=6,a=52,o="random",u=s.pow(r,i),c=s.pow(2,a),d=c*2,p=r-1,m;function g($,E,D){var F=[];E=E==!0?{entropy:!0}:E||{};var L=w(v(E.entropy?[$,I(t)]:$??N(),3),F),z=new x(F),M=function(){for(var O=z.g(i),H=u,X=0;O<c;)O=(O+X)*r,H*=r,X=z.g(1);for(;O>=d;)O/=2,H/=2,X>>>=1;return(O+X)/H};return M.int32=function(){return z.g(4)|0},M.quick=function(){return z.g(4)/4294967296},M.double=M,w(I(z.S),t),(E.pass||D||function(O,H,X,te){return te&&(te.S&&b(te,z),O.state=function(){return b(z,{})}),X?(s[o]=O,H):O})(M,L,"global"in E?E.global:this==s,E.state)}function x($){var E,D=$.length,F=this,L=0,z=F.i=F.j=0,M=F.S=[];for(D||($=[D++]);L<r;)M[L]=L++;for(L=0;L<r;L++)M[L]=M[z=p&z+$[L%D]+(E=M[L])],M[z]=E;(F.g=function(O){for(var H,X=0,te=F.i,Z=F.j,W=F.S;O--;)H=W[te=p&te+1],X=X*r+W[p&(W[te]=W[Z=p&Z+H])+(W[Z]=H)];return F.i=te,F.j=Z,X})(r)}function b($,E){return E.i=$.i,E.j=$.j,E.S=$.S.slice(),E}function v($,E){var D=[],F=typeof $,L;if(E&&F=="object")for(L in $)try{D.push(v($[L],E-1))}catch{}return D.length?D:F=="string"?$:$+"\0"}function w($,E){for(var D=$+"",F,L=0;L<D.length;)E[p&L]=p&(F^=E[p&L]*19)+D.charCodeAt(L++);return I(E)}function N(){try{var $;return m&&($=m.randomBytes)?$=$(r):($=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues($)),I($)}catch{var E=e.navigator,D=E&&E.plugins;return[+new Date,e,D,e.screen,I(t)]}}function I($){return String.fromCharCode.apply(0,$)}if(w(s.random(),t),n.exports){n.exports=g;try{m=pG}catch{}}else s["seed"+o]=g})(typeof self<"u"?self:fG,[],Math)})(Hy)),Hy.exports}var fw,nT;function gG(){if(nT)return fw;nT=1;var n=eG(),e=nG(),t=rG(),s=aG(),r=lG(),i=cG(),a=mG();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=i,fw=a,fw}var q0=gG();class _S{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=i||Math.random();this.random=q0.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,a;do r=2*this.random()-1,i=2*this.random()-1,a=r*r+i*i;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class yG{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const i=r||Math.random();this.randu=q0.alea(i.toString()),this.randn=new _S(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,i,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),i=this.randu(),i<t||Math.log(i)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class xG{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=q0.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function bG(n,e,t=1,s="float32",r){if(Yr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new yG(e,t,s,r),a=ft(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const vG=J({randomGamma_:bG});function wG(n,e=0,t=1,s,r){if(Yr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new _S(e,t,s,!1,r),a=ft(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const OS=J({randomNormal_:wG});function SG(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return OS(n,0,1,e,t)}const CG=J({randomStandardNormal_:SG});function NG(n,e=0,t=1,s="float32",r){Yr(n);const i=ft(n,s),a=new xG(e,t,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Uu=J({randomUniform_:NG});function kG(n,e,t,s){return Uu(n,e,t,"int32",s)}const $G=J({randomUniformInt_:kG});function fh(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return se.runKernel(g0,{},r)}function IG(n){const t={input:U(n,"input","real")};return se.runKernel(y0,t)}const pf=J({real_:IG});function TG(n){const t={x:U(n,"x","reciprocal")};return se.runKernel(ad,t)}const nA=J({reciprocal_:TG});function EG(n){const t={x:U(n,"x","relu")};return se.runKernel(od,t)}const Ia=J({relu_:EG});function RG(n){const t={x:U(n,"x","relu6")};return se.runKernel(ld,t)}const FS=J({relu6_:RG});function AG(n,e){const s={x:U(n,"x","reverse")},r={dims:e};return se.runKernel(xm,s,r)}const $i=J({reverse_:AG});function DG(n){const e=U(n,"x","reverse");return B(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),$i(e,0)}const _G=J({reverse1d_:DG});function OG(n,e){const t=U(n,"x","reverse");return B(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),$i(t,e)}const FG=J({reverse2d_:OG});function zG(n,e){const t=U(n,"x","reverse");return B(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),$i(t,e)}const LG=J({reverse3d_:zG});function MG(n,e){const t=U(n,"x","reverse");return B(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),$i(t,e)}const PG=J({reverse4d_:MG});function BG(n){const t={x:U(n,"x","round")};return se.runKernel(ud,t)}const zS=J({round_:BG});function VG(n){const t={x:U(n,"x","rsqrt","float32")};return se.runKernel(cd,t)}const LS=J({rsqrt_:VG});function UG(n){const t={x:U(n,"x","selu")};return se.runKernel(hd,t)}const MS=J({selu_:UG});function WG(n,e,t,s,r,i=[1,1],a="NHWC"){const o=U(n,"x","separableConv2d"),u=U(e,"depthwiseFilter","separableConv2d"),c=U(t,"pointwiseFilter","separableConv2d");let d=o,p=!1;if(o.rank===3&&(p=!0,d=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");B(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),B(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),B(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),B(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),B(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const m=u.shape[2],g=u.shape[3];B(c.shape[2]===m*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*g}, but got ${c.shape[2]}.`);const x=Rm(d,u,s,r,a,i),v=hl(x,c,1,"valid",a);return p?ae(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const PS=J({separableConv2d_:WG});async function GG(n,e){const t=U(n,"x","setdiff1d"),s=U(e,"y","setdiff1d");B(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),B(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),B(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),a=new Set(i);let o=0;for(let d=0;d<r.length;d++)a.has(r[d])||o++;const u=new es([o],t.dtype),c=new es([o],"int32");for(let d=0,p=0;d<r.length;d++)a.has(r[d])||(u.values[p]=r[d],c.values[p]=d,p++);return[u.toTensor(),c.toTensor()]}const HG=GG;function jG(n){const t={x:U(n,"x","sign")};return se.runKernel(fd,t)}const sA=J({sign_:jG});function qG(n){const t={x:U(n,"x","sin","float32")};return se.runKernel(dd,t)}const BS=J({sin_:qG});function XG(n){const t={x:U(n,"x","sinh")};return se.runKernel(pd,t)}const VS=J({sinh_:XG});function KG(n,e,t){const s=U(n,"x","slice1d");return B(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),dt(s,[e],[t])}const X0=J({slice1d_:KG});function YG(n,e,t){const s=U(n,"x","slice2d");return B(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),dt(s,e,t)}const US=J({slice2d_:YG});function QG(n,e,t){const s=U(n,"x","slice3d");return B(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),dt(s,e,t)}const K0=J({slice3d_:QG});function ZG(n,e,t){const s=U(n,"x","slice4d");return B(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),dt(s,e,t)}const ff=J({slice4d_:ZG});function JG(n,e=-1){const t=U(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return se.runKernel(Nm,s,r)}const Y0=J({softmax_:JG});function eH(n){B(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(n0,e)}const Q0=J({fft_:eH});function tH(n){B(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(a0,e)}const mf=J({ifft_:tH});function nH(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=ae(n,[t,e]);s=mf(r)}else{const r=[t,2*(e-1)],i=ae(pf(n),[t,e]),a=ae(M0(n),[t,e]),o=$i(dt(i,[0,1],[t,e-2]),1),u=Q($i(dt(a,[0,1],[t,e-2]),1),Je(-1)),c=$n([i,o],1),d=$n([a,u],1),p=ae(ll(c,d),[r[0],r[1]]);s=mf(p)}if(s=pf(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=ae(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const WS=J({irfft_:nH});function sH(n,e,t=0){const r={x:U(n,"x","split")},i={numOrSizeSplits:e,axis:t};return se.runKernel(Cm,r,i)}const Ir=J({split_:sH});function rH(n,e){B(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const x=n.shape.map(v=>0),b=n.shape.map(v=>v);b[n.shape.length-1]=e,r=dt(n,x,b),t=e}else if(e!=null&&e>t){const x=n.shape.map(b=>b);x[n.shape.length-1]=e-t,r=$n([n,zn(x)],n.shape.length-1),t=e}else r=n;const i=Ot(r),a=ae(ll(r,i),[s,t]),o=Q0(a),u=Math.floor(t/2)+1,c=pf(o),d=M0(o),p=Ir(c,[u,t-u],c.shape.length-1),m=Ir(d,[u,t-u],d.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=u,ae(ll(p[0],m[0]),g)}const Z0=J({rfft_:rH});function iH(n,e){let t=U(n,"a","squaredDifference"),s=U(e,"b","squaredDifference");[t,s]=An(t,s),it(t.shape,s.shape);const r={a:t,b:s},i={};return se.runKernel(xd,r,i)}const GS=J({squaredDifference_:iH});function aH(n,e){const t=U(n,"x","squeeze","string_or_numeric");return ae(t,vl(t.shape,e).newShape)}const Wt=J({squeeze_:aH});function oH(n,e=0){const t=rx(n,"tensors","stack","string_or_numeric");B(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&B(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return se.runKernel(hm,s,r)}const Tr=J({stack_:oH});function lH(n,e=0){const s={x:U(n,"x","step")},r={alpha:e};return se.runKernel(Cd,s,r)}const $d=J({step_:lH});function uH(n,e,t,s,r=0,i=0,a=0,o=0,u=0){const d={x:U(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};return se.runKernel(T0,d,p)}const rA=J({stridedSlice_:uH});function cH(n){const t={x:U(n,"x","tan","float32")};return se.runKernel(vd,t)}const iA=J({tan_:cH});function Gn(n,e){$h(n);const t=Sl(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Cl(n,null,t,e)}function Ni(n,e,t){if($h(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Sl(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Cl(n,e,s,t)}function aA(n,e,t){if($h(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Sl(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Cl(n,e,s,t)}function hH(n,e,t){if($h(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Sl(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Cl(n,e,s,t)}function dH(n,e,t){if($h(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Sl(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Cl(n,e,s,t)}function pH(n,e,t){if($h(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Sl(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Cl(n,e,s,t)}function oA(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(i+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function HS(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}oA(t,e,n)}function Ta(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let a=1;for(let p=r;p<i;++p)a*=t[p];const o=r<1?1:r,u=ce(e.shape)/o,c=[...Ze(t.slice(0,r)),1],d=ce(t);return{sliceRank:r,numUpdates:u,sliceSize:a,strides:c,outputSize:d}}function fH(n,e,t){const s=U(n,"tensor","tensorScatterupdate"),r=U(e,"indices","tensorScatterupdate","int32"),i=U(t,"updates","tensorScatterupdate");if(HS(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const a={tensor:s,indices:r,updates:i},o={};return se.runKernel(w0,a,o)}const mH=J({tensorScatterUpdate_:fH});function gH(n,e=1,t=!0){const s=U(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:t},[o,u]=se.runKernel(R0,i,a);return{values:o,indices:u}}const lA=J({topk_:gH});function yH(n,e=0,t=1,s,r){if(Yr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new _S(e,t,s,!0,r),a=ft(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const jS=J({truncatedNormal_:yH});function xH(n,e=0){const t=U(n,"x","unique","string_or_numeric");B(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,a]=se.runKernel(dS,s,r);return{values:i,indices:a}}const uA=J({unique_:xH});function bH(n,e,t){const s=U(n,"x","unsortedSegmentSum"),r=U(e,"segmentIds","unsortedSegmentSum","int32");B(hh(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},a={numSegments:t};return se.runKernel($m,i,a)}const qS=J({unsortedSegmentSum_:bH});function vH(n,e=0){const t=U(n,"x","unstack","string_or_numeric");B(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return se.runKernel(km,s,r)}const Ii=J({unstack_:vH});function wH(n,e){return RS(n,e,"right")}function cA(n,e=!0,t,s){return se.makeVariable(n,e,t,s)}function XS(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=ft(n,"int32"),r=ft([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const a=s.indexToLoc(t[i]),o=i*n.length;r.values.set(a,o)}return r.toTensor()}async function SH(n){const e=U(n,"condition","whereAsync","bool"),t=await e.data(),s=XS(e.shape,t);return n!==e&&e.dispose(),s}const hA=SH;async function CH(n,e,t){const s=U(n,"tensor","boolMask"),r=U(e,"mask","boolMask","bool"),i=t??0,a=r.rank,o=s.shape;B(a>0,()=>"mask cannot be scalar"),pr(o.slice(i,i+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let b=i;b<i+a;b++)u*=o[b];const c=o.slice(0,i).concat([u],o.slice(i+a)),d=ae(s,c),p=ae(r,[-1]),m=await hA(p),g=Wt(m,[1]),x=Om(d,g,i);return n!==s&&s.dispose(),e!==r&&r.dispose(),g.dispose(),d.dispose(),p.dispose(),m.dispose(),x}const NH=CH;function kH(n,e,t){const s=U(n,"x","transpose");if(e==null&&(e=s.shape.map((a,o)=>o).reverse()),B(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{B(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?he(()=>{let a=pf(s),o=M0(s);return a=se.runKernel(yu,{x:a},i),o=se.runKernel(yu,{x:o},i),t&&(o=gn(o)),ll(a,o)}):se.runKernel(yu,r,i)}const _t=J({transpose_:kH});function $H(n,e,t,s,r=!0){const i=U(n,"v","movingAverage"),a=U(e,"x","movingAverage"),o=U(t,"decay","movingAverage");p4(i,a),B(xt(i.shape,a.shape),()=>"Shape mismatch in v and x");const u=Je(1),c=Ue(u,o);let d=Q(Ue(a,i),c);if(r){B(s!=null,()=>"When using zeroDebias: true, step is required.");const p=U(s,"step","movingAverage");d=Ve(d,Ue(u,uo(o,p)))}return $e(i,d)}const IH=J({movingAverage_:$H});function TH(n,e,t){Yr(t);const s=U(n,"indices","scatterND","int32"),r=U(e,"updates","scatterND");HS(r,s,t);const i={indices:s,updates:r},a={shape:t};return se.runKernel(v0,i,a)}const EH=J({scatterND_:TH});function RH(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function AH(n,e,t,s=0){Yr(t);const r=U(n,"sparseIndices","sparseToDense","int32"),i=U(e,"sparseValues","sparseToDense","string_or_numeric"),a=U(s,"defaultValue","sparseToDense",i.dtype);RH(r,i,t,a);const o={sparseIndices:r,sparseValues:i,defaultValue:a},u={outputShape:t};return se.runKernel(k0,o,u)}const DH=J({sparseToDense_:AH});function _H(n,e){const t=U(e,"indices","gatherND","int32"),r={params:U(n,"x","gatherND","string_or_numeric"),indices:t};return se.runKernel(i0,r)}const OH=J({gatherND_:_H});function FH(n,e){if(e==null)return n.shape.slice();if(xt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function zH(n,e,t,s){const r=U(n,"x","dropout");if(B(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),B(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Kt?r.clone():r;const i=FH(r,t),a=1-e,o=Ve(_m($e(Uu(i,0,1,"float32",s),a)),a);return Q(r,o)}const dA=J({dropout_:zH});function pA(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function KS(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const a=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(a)}return Gn(r,"float32")}async function LH(n,e,t=1){const s=U(n,"predictions","inTopK"),r=U(e,"targets","inTopK");B(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),B(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),pr(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];B(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const a=await s.data(),o=await r.data(),[u,c]=[a.length/i,i],d=ss("bool",u);for(let p=0;p<u;p++){const m=p*c,g=a.subarray(m,m+c),x=[];for(let b=0;b<g.length;b++)x.push({value:g[b],index:b});x.sort((b,v)=>v.value-b.value),d[p]=0;for(let b=0;b<t;b++)if(x[b].index===o[p]){d[p]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Wi(d,r.shape,"bool")}const MH=LH;function PH(n,e,t,s,r,i="NHWC",a){let o=n;n.rank===3&&(o=ae(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]])),B(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),B(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),B(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?o.shape[3]:o.shape[1],d=i==="NHWC"?u.shape[3]:u.shape[1];B(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),B(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),Qs("conv2dDerFilter",r,a);const p={x:o,dy:u},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:t};return se.runKernel(Gx,p,m)}const YS=J({conv2DBackpropFilter_:PH});function J0(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Q(n,$d(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function eb(n,e){let t=e;const s=rs(n.shape,e.shape);return s.length>0&&(t=Ke(t,s)),ae(t,n.shape)}function tb(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Ia(n);if(e==="elu")return Am(n);if(e==="relu6")return FS(n);if(e==="prelu")return j0(n,t);if(e==="leakyrelu")return P0(n,s);if(e==="sigmoid")return qr(n);throw new Error(`Unknown fused activation ${e}.`)}const nb=(n,e)=>!(n>0)||e==="linear";function BH({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(u=u||"linear",nb(se.state.gradientDepth,u)===!1){B(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let D=hl(n,e,t,s,r,i,a);return o!=null&&(D=$e(D,o)),tb(D,u,c,d)}const p=U(n,"x","conv2d","float32"),m=U(e,"filter","conv2d","float32");let g=p,x=!1;p.rank===3&&(x=!0,g=ae(p,[1,p.shape[0],p.shape[1],p.shape[2]])),B(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),B(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Qs("fused conv2d",s,a);const b=r==="NHWC"?g.shape[3]:g.shape[1];B(m.shape[2]===b,()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${m.shape[2]}.`),B(is(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const v=fn(g.shape,m.shape,t,i,s,a);let w;o!=null&&(w=U(o,"bias","fused conv2d"),[w]=An(w,p),r==="NHWC"?it(v.outShape,w.shape):(B(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),B(w.shape.length===0||w.shape[0]===v.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${v.outChannels})`)));let N;if(c!=null){const D=c.shape;if(B(D.length<=1||D.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${D.length}.`),D.length===1)B(D[0]===1||D[0]===v.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the number of output channels (${v.outChannels}).`);else if(D.length===3)try{it(D,v.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(L)}N=U(c,"prelu weights","fused conv2d")}const I=(D,F)=>{B(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[L,z,M,O]=F,H=J0(D,M,u);B(cl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const X=wS(z.shape,H,L,t,s),te=YS(z,H,L.shape,t,s),Z=[X,te];if(O!=null){const W=eb(O,H);Z.push(W)}return Z},$={x:g,filter:m,bias:w,preluActivationWeights:N},E={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:d};return o==null?co((F,L,z)=>{let M=se.runKernel(af,$,E);return z([L,F,M]),x&&(M=ae(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:I}})(g,m):co((F,L,z,M)=>{let O=se.runKernel(af,$,E);return M([L,F,O,z]),x&&(O=ae(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:I}})(g,m,w)}const fA=J({fusedConv2d_:BH});function VH(n,e,t,s,r,i=[1,1],a){let o=n;n.rank===3&&(o=ae(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:o,dy:u},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:t};return se.runKernel(Qx,c,d)}const mA=J({depthwiseConv2dNativeBackpropFilter_:VH});function UH(n,e,t,s,r,i=[1,1],a){let o=e,u=!1;e.rank===3&&(u=!0,o=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:o,filter:t},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:n},p=se.runKernel(Zx,c,d);return u?ae(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const gA=J({depthwiseConv2dNativeBackpropInput_:UH});function WH({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(nb(se.state.gradientDepth,u)===!1){let E=Rm(n,e,t,s,r,i,a);return o!=null&&(E=$e(E,o)),tb(E,u,c,d)}const p=U(n,"x","depthwiseConv2d","float32"),m=U(e,"filter","depthwiseConv2d","float32");let g=p,x=!1;p.rank===3&&(x=!0,g=ae(p,[1,p.shape[0],p.shape[1],p.shape[2]])),B(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),B(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),B(g.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),i==null&&(i=[1,1]),B(is(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Qs("fused depthwiseConv2d",s,a);const b=fn(g.shape,m.shape,t,i,s,a,!0);let v;o!=null&&(v=U(o,"bias","fused conv2d"),[v]=An(v,p),it(b.outShape,v.shape));let w;c!=null&&(w=U(c,"prelu weights","fused depthwiseConv2d"));const N=(E,D)=>{B(cl(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[F,L,z,M]=D,O=J0(E,z,u),H=gA(L.shape,O,F,t,s,i,a),X=mA(L,O,F.shape,t,s,i,a);if(M!=null){const te=eb(v,O);return[H,X,te]}return[H,X]},I={x:g,filter:m,bias:v,preluActivationWeights:w},$={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:d};return o==null?co((D,F,L)=>{let z=se.runKernel(of,I,$);return L([F,D,z]),x&&(z=ae(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:N}})(g,m):co((D,F,L,z)=>{let M=se.runKernel(of,I,$);return z([F,D,M,L]),x&&(M=ae(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:N}})(g,m,v)}const GH=J({fusedDepthwiseConv2d_:WH});function HH({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(nb(se.state.gradientDepth,i)===!1){let O=kt(n,e,t,s);return r!=null&&(O=$e(O,r)),tb(O,i,a,o)}let u=U(n,"a","fused matMul"),c=U(e,"b","fused matMul");[u,c]=An(u,c);const d=t?u.shape[u.rank-2]:u.shape[u.rank-1],p=s?c.shape[c.rank-1]:c.shape[c.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],g=s?c.shape[c.rank-2]:c.shape[c.rank-1],x=u.shape.slice(0,-2),b=c.shape.slice(0,-2),v=ce(x),w=ce(b);B(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const I=it(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([m,g]),$=t?ae(u,[v,d,m]):ae(u,[v,m,d]),E=s?ae(c,[w,g,p]):ae(c,[w,p,g]);let D;r!=null&&(D=U(r,"bias","fused matMul"),[D]=An(D,u),it(I,D.shape));let F;a!=null&&(F=U(a,"prelu weights","fused matMul"));const L=(O,H)=>{const[X,te,Z,W]=H,ee=J0(ae(O,Z.shape),Z,i);let ie,de;if(!t&&!s?(ie=kt(ee,te,!1,!0),de=kt(X,ee,!0,!1)):!t&&s?(ie=kt(ee,te,!1,!1),de=kt(ee,X,!0,!1)):t&&!s?(ie=kt(te,ee,!1,!0),de=kt(X,ee,!1,!1)):(ie=kt(te,ee,!0,!0),de=kt(ee,X,!0,!0)),r!=null){const ge=eb(W,ee);return[ie,de,ge]}else return[ie,de]},z={a:$,b:E,bias:D,preluActivationWeights:F},M={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:o};return r==null?co((H,X,te)=>{const Z=se.runKernel(rf,z,M);return te([H,X,Z]),{value:ae(Z,I),gradFunc:L}})($,E):co((H,X,te,Z)=>{const W=se.runKernel(rf,z,M);return Z([H,X,W,te]),{value:ae(W,I),gradFunc:L}})($,E,D)}const u2=J({fusedMatMul_:HH});const jH=Object.freeze(Object.defineProperty({__proto__:null,conv2d:fA,depthwiseConv2d:GH,matMul:u2},Symbol.toStringTag,{value:"Module"}));function qH(n){return KS(n,.54,.46)}const XH=J({hammingWindow_:qH});function KH(n){return KS(n,.5,.5)}const yA=J({hannWindow_:KH});function YH(n,e,t,s=!1,r=0){let i=0;const a=[];for(;i+e<=n.size;)a.push(dt(n,i,e)),i+=t;if(s)for(;i<n.size;){const o=i+e-n.size,u=$n([dt(n,i,e-o),Nd([o],r)]);a.push(u),i+=t}return a.length===0?Ni([],[0,e]):ae($n(a),[a.length,e])}const xA=J({frame_:YH});function QH(n,e,t,s,r=yA){s==null&&(s=pA(e));const i=xA(n,e,t),a=Q(i,r(e));return Z0(a,s)}const ZH=J({stft_:QH});function JH(n,e,t,s,r="bilinear",i=0){const a=U(n,"image","cropAndResize"),o=U(e,"boxes","cropAndResize","float32"),u=U(t,"boxInd","cropAndResize","int32"),c=o.shape[0];B(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),B(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),B(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),B(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),B(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),B(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:a,boxes:o,boxInd:u},p={method:r,extrapolationValue:i,cropSize:s};return se.runKernel(Xx,d,p)}const ej=J({cropAndResize_:JH});function tj(n){const e=U(n,"image","flipLeftRight","float32");B(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return se.runKernel(r0,t,{})}const nj=J({flipLeftRight_:tj});function sj(n){const e=U(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];B(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),B(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,bi(e,r)}const rj=J({grayscaleToRGB_:sj});function ij(n){const e=U(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];B(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),B(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=Fe(e,"float32"),a=Gn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=sh("ij,j->i",i,a);break;case 3:o=sh("ijk,k->ij",i,a);break;case 4:o=sh("ijkl,l->ijk",i,a);break;case 5:o=sh("ijklm,m->ijkl",i,a);break;case 6:o=sh("ijklmn,n->ijklm",i,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Wn(o,-1),Fe(o,r)}const aj=J({rgbToGrayscale_:ij});function oj(n,e,t=0,s=.5){const r=U(n,"image","rotateWithOffset","float32");B(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},a={radians:e,fillValue:t,center:s};return se.runKernel(D0,i,a)}const lj=J({rotateWithOffset_:oj});function Id(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const a=n.shape[0];return t=Math.min(t,a),B(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),B(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),B(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),B(e.rank===1,()=>"scores must be a 1D tensor"),B(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),B(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function uj(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppression","float32"),a=U(e,"scores","nonMaxSuppression","float32"),o=Id(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return se.runKernel(f0,{boxes:i,scores:a},u)}const cj=J({nonMaxSuppression_:uj});function hj(n,e,t){const s=dj(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function dj(n,e,t){return fj(n,e,t||pj)}function pj(n,e){return n>e?1:n<e?-1:0}function fj(n,e,t){let s=0,r=n.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=t(e,n[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}function sb(n,e,t,s,r){return ZS(n,e,t,s,r,0)}function QS(n,e,t,s,r,i){return ZS(n,e,t,s,r,0,!1,i,!0)}function rb(n,e,t,s,r,i){return ZS(n,e,t,s,r,i,!0)}function ZS(n,e,t,s,r,i,a=!1,o=!1,u=!1){const c=[];for(let v=0;v<e.length;v++)e[v]>r&&c.push({score:e[v],boxIndex:v,suppressBeginIndex:0});c.sort(sT);const d=i>0?-.5/i:0,p=[],m=[];for(;p.length<t&&c.length>0;){const v=c.pop(),{score:w,boxIndex:N,suppressBeginIndex:I}=v;if(w<r)break;let $=!1;for(let E=p.length-1;E>=I;--E){const D=mj(n,N,p[E]);if(D>=s){$=!0;break}if(v.score=v.score*gj(s,d,D),v.score<=r)break}v.suppressBeginIndex=p.length,$||(v.score===w?(p.push(N),m.push(v.score)):v.score>r&&hj(c,v,sT))}const g=p.length,x=t-g;o&&x>0&&(p.push(...new Array(x).fill(0)),m.push(...new Array(x).fill(0)));const b={selectedIndices:p};return a&&(b.selectedScores=m),u&&(b.validOutputs=g),b}function mj(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),g=(o-i)*(u-a),x=(p-c)*(m-d);if(g<=0||x<=0)return 0;const b=Math.max(i,c),v=Math.max(a,d),w=Math.min(o,p),N=Math.min(u,m),I=Math.max(w-b,0)*Math.max(N-v,0);return I/(g+x-I)}function gj(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function sT(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function yj(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppressionAsync"),a=U(e,"scores","nonMaxSuppressionAsync"),o=Id(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u=await Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:p}=sb(c,d,t,s,r);return i!==n&&i.dispose(),a!==e&&a.dispose(),Gn(p,"int32")}const xj=yj;function bj(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=U(n,"boxes","nonMaxSuppression"),o=U(e,"scores","nonMaxSuppression"),u=Id(a,o,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const c={boxes:a,scores:o},d={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},p=se.runKernel(m0,c,d);return{selectedIndices:p[0],selectedScores:p[1]}}const vj=J({nonMaxSuppressionWithScore_:bj});async function wj(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),u=Id(a,o,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const c=await Promise.all([a.data(),o.data()]),d=c[0],p=c[1],{selectedIndices:m,selectedScores:g}=rb(d,p,t,s,r,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Gn(m,"int32"),selectedScores:Gn(g)}}const Sj=wj;function Cj(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=U(n,"boxes","nonMaxSuppression"),o=U(e,"scores","nonMaxSuppression"),u=Id(a,o,t,s,r,null),c=u.maxOutputSize,d=u.iouThreshold,p=u.scoreThreshold,m={boxes:a,scores:o},g={maxOutputSize:c,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:i},x=se.runKernel(rS,m,g);return{selectedIndices:x[0],validOutputs:x[1]}}const Nj=J({nonMaxSuppressionPadded_:Cj});async function kj(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),u=Id(a,o,t,s,r,null),c=u.maxOutputSize,d=u.iouThreshold,p=u.scoreThreshold,[m,g]=await Promise.all([a.data(),o.data()]),{selectedIndices:x,validOutputs:b}=QS(m,g,c,d,p,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Gn(x,"int32"),validOutputs:Je(b,"int32")}}const $j=kj;function Ij(n,e,t=!1,s=!1){const r=U(n,"images","resizeBilinear");B(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),B(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),B(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=ae(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},c=se.runKernel(ym,o,u);return a?ae(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const bA=J({resizeBilinear_:Ij});function Tj(n,e,t=!1,s=!1){const r=U(n,"images","resizeNearestNeighbor");B(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),B(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),B(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),B(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=ae(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},c=se.runKernel(gm,o,u);return a?ae(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const vA=J({resizeNearestNeighbor_:Tj});function Ej(n,e="binary",t=!1,s=.5){const r=U(n,"image","threshold"),i=.2989,a=.587,o=.114,u=r.shape[0]*r.shape[1];let c=Q(Gn([s]),255),d,p,m,g;if(B(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),B(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),B(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),B(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,p,m]=Ir(r,[1,1,1],-1);const v=Q(d,i),w=Q(p,a),N=Q(m,o);g=$e($e(v,w),N)}else g=n;if(e==="otsu"){const v=E3(Fe(zS(g),"int32"),Wi([]),256);c=Rj(v,u)}const x=t?Vu(g,c):_r(g,c);return Fe(Q(x,255),"int32")}function Rj(n,e){let t=Gn([-1]),s=Gn([0]),r=Gn([0]),i,a,o,u,c,d;for(let p=0;p<n.size-1;p++){i=dt(n,0,p+1),a=dt(n,p+1),c=Ve(Ke(i),e),d=Ve(Ke(a),e);const m=Ke(Q(i,fh(0,i.size)));o=Ve(m,Ke(i));const g=Nd(a.shape,i.size),x=$e(fh(0,a.size),g),b=Q(a,x);u=Ve(Ke(b),Ke(a));const v=Ue(o,u),w=Ue(o,u),N=Q(c,d);r=Q(Q(N,v),w);const I=_r(r,s);s=Fs(I,r,s),t=Fs(I,Gn([p]),t)}return t}const Aj=J({threshold_:Ej});function Dj(n,e,t="nearest",s="constant",r=0,i){const a=U(n,"image","transform","float32"),o=U(e,"transforms","transform","float32");B(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),B(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),B(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const u={image:a,transforms:o},c={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return se.runKernel(A0,u,c)}const _j=J({transform_:Dj});function Oj(n,e,t){const s=U(n,"a","bandPart");B(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);let o,u;typeof e=="number"?(B(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),B(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),o=U(e<0?i:e,"numLower","bandPart")):(B(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Fs(df(e,0),i,pl(e,i))),typeof t=="number"?(B(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),B(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),u=U(t<0?a:t,"numUpper","bandPart")):(B(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Fs(df(t,0),a,pl(t,a)));const c=ae(fh(0,i,1,"int32"),[-1,1]),d=fh(0,a,1,"int32"),p=Ue(c,d),m=wa(Vu(p,o),kl(p,gn(u))),g=zn([i,a],s.dtype);return ae(Tr(Ii(ae(s,[-1,i,a])).map(x=>Fs(m,x,g))),r)}const Fj=J({bandPart_:Oj});function zj(n){let e;if(Array.isArray(n)){e=!1,B(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)B(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=Ir(n,n.shape[0],0).map(r=>Wt(r,[0]));B(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(se.tidy(()=>{let i=s[r];if(r>0)for(let a=0;a<r;++a){const o=Q(Ke(Q(t[a],i)),t[a]);i=Ue(i,o)}return Ve(i,Dm(i,"euclidean"))}));return e?Tr(t,0):t}const Lj=J({gramSchmidt_:zj});function Mj(n,e=!1){if(B(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return rT(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,c)=>u*c),s=Ii(ae(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(u=>{const[c,d]=rT(u,e);r.push(c),i.push(d)});const a=ae(Tr(r,0),n.shape),o=ae(Tr(i,0),n.shape);return[a,o]}}function rT(n,e=!1){return se.tidy(()=>{B(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=IS(t),i=io(n);const a=Ni([[1]],[1,1]);let o=io(a);const u=t>=s?s:t;for(let c=0;c<u;++c){const d=i,p=o,m=r;[o,i,r]=se.tidy(()=>{const g=dt(i,[c,c],[t-c,1]),x=Dm(g),b=dt(i,[c,c],[1,1]),v=Fs(_r(b,0),Ni([[-1]]),Ni([[1]])),w=Ue(b,Q(v,x)),N=Ve(g,w);N.shape[0]===1?o=io(a):o=$n([a,dt(N,[1,0],[N.shape[0]-1,N.shape[1]])],0);const I=gn(Ve(kt(v,w),x)),$=dt(i,[c,0],[t-c,s]),E=Q(I,o),D=_t(o);if(c===0)i=Ue($,kt(E,kt(D,$)));else{const z=Ue($,kt(E,kt(D,$)));i=$n([dt(i,[0,0],[c,s]),z],0)}const F=_t(E),L=dt(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=Ue(L,kt(kt(L,o),F));else{const z=Ue(L,kt(kt(L,o),F));r=$n([dt(r,[0,0],[t,c]),z],1)}return[o,i,r]}),rt([d,p,m])}return!e&&t>s&&(r=dt(r,[0,0],[t,s]),i=dt(i,[0,0],[s,s])),[r,i]})}const Pj=J({qr_:Mj});var or;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(or||(or={}));function Bj(n,e,t=or.SUM_BY_NONZERO_WEIGHTS){const s=U(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=U(e,"weights","computeWeightedLoss"));const i=r==null?s:Q(s,r);if(t===or.NONE)return i;if(t===or.SUM)return Ke(i);if(t===or.MEAN){if(r==null)return Tn(i);{const a=s.size/r.size,o=Ve(Ke(i),Ke(r));return a>1?Ve(o,Je(a)):o}}if(t===or.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Ve(Ke(i),Je(s.size));{const a=Q(r,$r(s.shape)),o=Fe(Ke(ph(a,Je(0))),"float32");return Ve(Ke(i),o)}}throw Error(`Unknown reduction: ${t}`)}const fo=J({computeWeightedLoss_:Bj});function Vj(n,e,t,s=or.SUM_BY_NONZERO_WEIGHTS){const r=U(n,"labels","absoluteDifference"),i=U(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=U(t,"weights","absoluteDifference")),pr(r.shape,i.shape,"Error in absoluteDifference: ");const o=Qn(Ue(r,i));return fo(o,a,s)}const Uj=J({absoluteDifference_:Vj});function Wj(n,e,t,s,r=or.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"labels","cosineDistance"),a=U(e,"predictions","cosineDistance");let o=null;s!=null&&(o=U(s,"weights","cosineDistance")),pr(i.shape,a.shape,"Error in cosineDistance: ");const u=Je(1),c=Ue(u,Ke(Q(i,a),t,!0));return fo(c,o,r)}const Gj=J({cosineDistance_:Wj});function Hj(n,e,t,s=or.SUM_BY_NONZERO_WEIGHTS){let r=U(n,"labels","hingeLoss");const i=U(e,"predictions","hingeLoss");let a=null;t!=null&&(a=U(t,"weights","hingeLoss")),pr(r.shape,i.shape,"Error in hingeLoss: ");const o=Je(1);r=Ue(Q(Je(2),r),o);const u=Ia(Ue(o,Q(r,i)));return fo(u,a,s)}const jj=J({hingeLoss_:Hj});function qj(n,e,t,s=1,r=or.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"labels","huberLoss"),a=U(e,"predictions","huberLoss");let o=null;t!=null&&(o=U(t,"weights","huberLoss")),pr(i.shape,a.shape,"Error in huberLoss: ");const u=Je(s),c=Qn(Ue(a,i)),d=pl(c,u),p=Ue(c,d),m=$e(Q(Je(.5),tn(d)),Q(u,p));return fo(m,o,r)}const Xj=J({huberLoss_:qj});function Kj(n,e,t,s=1e-7,r=or.SUM_BY_NONZERO_WEIGHTS){const i=U(n,"labels","logLoss"),a=U(e,"predictions","logLoss");let o=null;t!=null&&(o=U(t,"weights","logLoss")),pr(i.shape,a.shape,"Error in logLoss: ");const u=Je(1),c=Je(s),d=gn(Q(i,Xr($e(a,c)))),p=Q(Ue(u,i),Xr($e(Ue(u,a),c))),m=Ue(d,p);return fo(m,o,r)}const Yj=J({logLoss_:Kj});function Qj(n,e,t,s=or.SUM_BY_NONZERO_WEIGHTS){const r=U(n,"labels","meanSquaredError"),i=U(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=U(t,"weights","meanSquaredError")),pr(r.shape,i.shape,"Error in meanSquaredError: ");const o=GS(r,i);return fo(o,a,s)}const Zj=J({meanSquaredError_:Qj});function Jj(n,e){const t=U(n,"labels","sigmoidCrossEntropyWithLogits"),s=U(e,"logits","sigmoidCrossEntropyWithLogits");pr(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Ia(s),i=Q(s,t),a=B0(Ks(gn(Qn(s))));return $e(Ue(r,i),a)}function e6(n,e,t,s=0,r=or.SUM_BY_NONZERO_WEIGHTS){let i=U(n,"multiClassLabels","sigmoidCrossEntropy");const a=U(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=U(t,"weights","sigmoidCrossEntropy")),pr(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=Je(s),d=Je(1),p=Je(.5);i=$e(Q(i,Ue(d,c)),Q(p,c))}const u=Jj(i,a);return fo(u,o,r)}const t6=J({sigmoidCrossEntropy_:e6});function n6(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return co((r,i,a)=>{const u=V0(i,[t],!0),c=Ue(Fe(i,"float32"),u);a([r,c]);const d=gn(Q(c,r));return{value:Ke(d,[t]),gradFunc:(g,x)=>{const[b,v]=x,w=Dn(g.shape,[t]);return[Q(ae(g,w),Ue(Fe(b,"float32"),Ks(v))),Q(ae(g,w),Ue(Ks(v),Fe(b,"float32")))]}}})(n,e)}function s6(n,e,t,s=0,r=or.SUM_BY_NONZERO_WEIGHTS){let i=U(n,"onehotLabels","softmaxCrossEntropy");const a=U(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=U(t,"weights","softmaxCrossEntropy")),pr(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const c=Je(s),d=Je(1),p=Je(i.shape[1]);i=$e(Q(i,Ue(d,c)),Ve(c,p))}const u=n6(i,a);return fo(u,o,r)}const r6=J({softmaxCrossEntropy_:s6});function i6(n,e,t,s){const r=U(n,"indices","sparseFillEmptyRows","int32"),i=U(e,"values","sparseFillEmptyRows"),a=U(t,"denseShape","sparseFillEmptyRows","int32"),o=U(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:r,values:i,denseShape:a,defaultValue:o},c=se.runKernel(lS,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const a6=J({sparseFillEmptyRows_:i6});function o6(n,e,t){const s=U(n,"inputIndices","sparseReshape","int32"),r=U(e,"inputShape","sparseReshape","int32"),i=U(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:s,inputShape:r,newShape:i},o=se.runKernel(uS,a);return{outputIndices:o[0],outputShape:o[1]}}const l6=J({sparseReshape_:o6});function u6(n,e,t){const s=U(n,"data","sparseSegmentMean"),r=U(e,"indices","sparseSegmentMean","int32"),i=U(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return se.runKernel(C0,a)}const c6=J({sparseSegmentMean_:u6});function h6(n,e,t){const s=U(n,"data","sparseSegmentSum"),r=U(e,"indices","sparseSegmentSum","int32"),i=U(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return se.runKernel(N0,a)}const d6=J({sparseSegmentSum_:h6});function p6(n,e,t,s,r,i,a,o){const u=U(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=U(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:a,preserveShortSequences:o},p={data:u,dataSplits:c},m=se.runKernel(E0,p,d);return{nGrams:m[0],nGramsSplits:m[1]}}const f6=J({stringNGrams_:p6});function m6(n,e,t=!0){const s=U(n,"input","stringSplit","string"),r=U(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},a={input:s,delimiter:r},o=se.runKernel(cS,a,i);return{indices:o[0],values:o[1],shape:o[2]}}const g6=J({stringSplit_:m6});function y6(n,e){const t=U(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return se.runKernel(hS,r,s)}const x6=J({stringToHashBucketFast_:y6});function b6(n,e,t,s=!0){const r=U(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:s};return se.runKernel(I0,{x:r},i)}const v6=J({staticRegexReplace_:b6});const w6={fft:Q0,ifft:mf,rfft:Z0,irfft:WS},S6={hammingWindow:XH,hannWindow:yA,frame:xA,stft:ZH},Xs={flipLeftRight:nj,grayscaleToRGB:rj,resizeNearestNeighbor:vA,resizeBilinear:bA,rgbToGrayscale:aj,rotateWithOffset:lj,cropAndResize:ej,nonMaxSuppression:cj,nonMaxSuppressionAsync:xj,nonMaxSuppressionWithScore:vj,nonMaxSuppressionWithScoreAsync:Sj,nonMaxSuppressionPadded:Nj,nonMaxSuppressionPaddedAsync:$j,threshold:Aj,transform:_j},wA={bandPart:Fj,gramSchmidt:Lj,qr:Pj},C6={absoluteDifference:Uj,computeWeightedLoss:fo,cosineDistance:Gj,hingeLoss:jj,huberLoss:Xj,logLoss:Yj,meanSquaredError:Zj,sigmoidCrossEntropy:t6,softmaxCrossEntropy:r6},N6={sparseFillEmptyRows:a6,sparseReshape:l6,sparseSegmentMean:c6,sparseSegmentSum:d6},k6={stringNGrams:f6,stringSplit:g6,stringToHashBucketFast:x6,staticRegexReplace:v6};const $6=new Map,I6=new Map;class Td{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class xi{constructor(){this.classNameMap={}}static getMap(){return xi.instance==null&&(xi.instance=new xi),xi.instance}static register(e){xi.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Ae(n,e,t){B(n.className!=null,()=>"Class being registered does not have the static className property defined."),B(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),B(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return xi.register(n),$6.set(r,n),I6.set(n,r),n}class $l extends Td{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:i[o.name]}));this.applyGradients(a)}else this.applyGradients(i);return rt(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return QU(e,t)}dispose(){this.iterations_!=null&&rt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Je(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty($l,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class SA extends $l{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:he(()=>Ot(i).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:he(()=>Ot(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const u=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;he(()=>{const d=$e(Q(u,this.rho),Q(tn(o),1-this.rho)),p=Q(Ve(ks($e(c,this.epsilon)),ks($e(u,this.epsilon))),o),m=$e(Q(c,this.rho),Q(tn(p),1-this.rho));u.assign(d),c.assign(m);const g=$e(Q(p,-this.learningRate),i);i.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(rt(this.accumulatedGrads.map(e=>e.variable)),rt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class CA extends $l{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:he(()=>Nd(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const o=this.accumulatedGrads[r].variable;he(()=>{const u=$e(o,tn(a));o.assign(u);const c=$e(Q(Ve(a,ks($e(u,se.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&rt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class NA extends $l{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],he(()=>{this.accBeta1=Je(t).variable(),this.accBeta2=Je(s).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);he(()=>{const s=Ue(1,this.accBeta1),r=Ue(1,this.accBeta2);t.forEach((i,a)=>{const o=se.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:he(()=>Ot(o).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:he(()=>Ot(o).variable(u))});const c=Array.isArray(e)?e[a].tensor:e[i];if(c==null)return;const d=this.accumulatedFirstMoment[a].variable,p=this.accumulatedSecondMoment[a].variable,m=$e(Q(d,this.beta1),Q(c,1-this.beta1)),g=$e(Q(p,this.beta2),Q(tn(c),1-this.beta2)),x=Ve(m,s),b=Ve(g,r);d.assign(m),p.assign(g);const v=$e(Q(Ve(x,$e(ks(b),this.epsilon)),-this.learningRate),o);o.assign(v)}),this.accBeta1.assign(Q(this.accBeta1,this.beta1)),this.accBeta2.assign(Q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&rt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&rt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),he(()=>{this.accBeta1.assign(uo(this.beta1,this.iterations_+1)),this.accBeta2.assign(uo(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class kA extends $l{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],he(()=>{this.iteration=Je(0).variable(),this.accBeta1=Je(t).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);he(()=>{const s=Ue(1,this.accBeta1),r=Ve(-this.learningRate,$e(Q(this.iteration,this.decay),1));t.forEach((i,a)=>{const o=se.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:Ot(o).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:Ot(o).variable(u)});const c=Array.isArray(e)?e[a].tensor:e[i];if(c==null)return;const d=this.accumulatedFirstMoment[a].variable,p=this.accumulatedWeightedInfNorm[a].variable,m=$e(Q(d,this.beta1),Q(c,1-this.beta1)),g=Q(p,this.beta2),x=Qn(c),b=po(g,x);d.assign(m),p.assign(b);const v=$e(Q(Ve(r,s),Ve(m,$e(b,this.epsilon))),o);o.assign(v)}),this.iteration.assign($e(this.iteration,1)),this.accBeta1.assign(Q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&rt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&rt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class JS extends $l{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=se.registeredVariables[s];he(()=>{const o=$e(Q(this.c,i),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=ms(Je(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class $A extends JS{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Je(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:he(()=>Ot(i).variable(!1))});const a=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&he(()=>{let u;const c=$e(Q(this.m,a),o);this.useNesterov?u=$e(Q(this.c,$e(o,Q(c,this.m))),i):u=$e(Q(this.c,c),i),a.assign(c),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&rt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class IA extends $l{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=se.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:he(()=>Ot(i).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:he(()=>Ot(i).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:he(()=>Ot(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const u=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;he(()=>{const d=$e(Q(u,this.decay),Q(tn(o),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,m=$e(Q(p,this.decay),Q(o,1-this.decay)),g=Ve(Q(o,this.learningRate),ks(Ue(d,$e(tn(m),this.epsilon)))),x=$e(Q(c,this.momentum),g);u.assign(d),p.assign(m),c.assign(x);const b=Ue(i,x);i.assign(b)}else{const p=$e(Q(u,this.decay),Q(tn(o),1-this.decay)),m=$e(Q(c,this.momentum),Ve(Q(o,this.learningRate),ks($e(p,this.epsilon))));u.assign(p),c.assign(m);const g=Ue(i,m);i.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&rt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&rt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&rt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const T6=[SA,CA,NA,kA,$A,IA,JS];function E6(){for(const n of T6)Ae(n)}const R6="model",A6=".json",D6=".weights.bin";function iT(n){return new Promise(e=>setTimeout(e)).then(n)}class Au{constructor(e){if(!fe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Au.URL_SCHEME)&&(e=e.slice(Au.URL_SCHEME.length)),(e==null||e.length===0)&&(e=R6),this.modelJsonFileName=e+A6,this.weightDataFileName=e+D6}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ji.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=a3(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await iT(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await iT(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Tm(e)}}}}Au.URL_SCHEME="downloads://";class _6{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const u=gS(i,c=>this.loadWeights(c));e(u)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),i=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(i).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const i=new FileReader;i.onload=a=>{const o=a.target.result;s(o)},i.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(i=>XI(i.name)),r={};for(const i of e)i.paths.forEach(a=>{const o=XI(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const O6=n=>fe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Au.URL_SCHEME)?F6(n.slice(Au.URL_SCHEME.length)):null;Nn.registerSaveRouter(O6);function F6(n="model"){return new Au(n)}function z6(n){return new _6(n)}function aT(n,e,t,s){a(n),t=t??0,s=s??1,o(t,s);let r=0;const i=u=>(u.then(c=>{const d=t+ ++r/n.length*(s-t);return e(d),c}),u);function a(u){B(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,c){B(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),B(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),B(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(n.map(i))}async function TA(n,e){e==null&&(e={});const t=e.fetchFunc==null?fe().platform.fetch:e.fetchFunc,s=n.map(p=>t(p,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await aT(s,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(o):await aT(o,e.onProgress,.5,1)}function L6(n,e){var t;const s=e.fetchFunc==null?fe().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var o;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=await i.read();if(u){r++,i=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/n.length);continue}a.enqueue(c);return}a.close()}})}async function M6(n,e="",t,s){return EA(a=>TA(a,{requestInit:s}))(n,e,t)}function EA(n){return async(e,t="",s)=>{const r=e.map(()=>!1),i={},a=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((g,x)=>{let b=0;g.weights.forEach(v=>{const w="quantization"in v?v.quantization.dtype:v.dtype,N=Nu[w]*ce(v.shape),I=()=>{r[x]=!0,i[x]==null&&(i[x]=[]),i[x].push({manifestEntry:v,groupOffset:b,sizeBytes:N})};s!=null?s.forEach(($,E)=>{$===v.name&&(I(),a[E]=!0)}):I(),o.push(v.name),b+=N})}),!a.every(g=>g)){const g=s.filter((x,b)=>!a[b]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const u=r.reduce((g,x,b)=>(x&&g.push(b),g),[]),c=[];u.forEach(g=>{e[g].paths.forEach(x=>{const b=t+(t.endsWith("/")?"":"/")+x;c.push(b)})});const d=await n(c),p={};let m=0;return u.forEach(g=>{const x=e[g].paths.length,b=new Ji(d.slice(m,m+x));i[g].forEach(w=>{const N=b.slice(w.groupOffset,w.groupOffset+w.sizeBytes),I=n3(N,[w.manifestEntry]);for(const $ in I)p[$]=I[$]}),m+=x}),p}}const P6="application/octet-stream",B6="application/json";class eC{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(B(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=fe().platform.fetch,B(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&B(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=a3(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:B6}),"model.json"),e.weightData!=null){const a=Ji.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:P6}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:Tm(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return gS(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=s2(e.weightsManifest),r=()=>L6(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=V6(t),i=this.weightPathPrefix||s,a=[],o=[];for(const u of e)for(const c of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(c)):a.push(i+c+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){const t=await this.getWeightUrls(e),s=s2(e),r=await TA(t,this.loadOptions);return[s,r]}}eC.URL_SCHEME_REGEX=/^https?:\/\//;function V6(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function c2(n){return n.match(eC.URL_SCHEME_REGEX)!=null}const RA=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>c2(s)):t=c2(n),t)return tC(n,e)}return null};Nn.registerSaveRouter(RA);Nn.registerLoadRouter(RA);function tC(n,e){return new eC(n,e)}function U6(n,e){return tC(n,e)}class mw{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class AA{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class W6{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function G6(n,e,t,s){const r=arguments;return new W6(DA(...r))}function DA(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new mw(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mw({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mw({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function H6(n){return new AA(n)}function j6(n){return new AA(n)}const _A=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Ji,browserFiles:z6,browserHTTPRequest:U6,concatenateArrayBuffers:i3,copyModel:j4,decodeWeights:n3,decodeWeightsStream:r3,encodeWeights:n2,fromMemory:G6,fromMemorySync:DA,getLoadHandlers:D4,getModelArtifactsForJSON:gS,getModelArtifactsForJSONSync:o3,getModelArtifactsInfoForJSON:Tm,getSaveHandlers:l3,getWeightSpecs:s2,http:tC,isHTTPScheme:c2,listModels:G4,loadWeights:M6,moveModel:q4,registerLoadRouter:A4,registerSaveRouter:R4,removeModel:H4,weightsLoaderFactory:EA,withSaveHandler:H6,withSaveHandlerSync:j6},Symbol.toStringTag,{value:"Module"}));let ru,oT=!1;function q6(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(nx(ex,se.backendName)!=null){const x={pixels:n},b={numChannels:e};return se.runKernel(ex,x,b)}const[c,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let p;if(a)p=n.getContext("2d").getImageData(0,0,c,d).data;else if(s||t)p=n.data;else if(i||r||o){if(ru==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ru=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ru=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ru.canvas.width=c,ru.canvas.height=d,ru.drawImage(n,0,0,c,d),p=ru.getImageData(0,0,c,d).data}let m;if(e===4)m=new Int32Array(p);else{const x=c*d;m=new Int32Array(x*e);for(let b=0;b<x;b++)for(let v=0;v<e;++v)m[b*e+v]=p[b*4+v]}return aA(m,[d,c,e],"int32")}function X6(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}async function nC(n,e){let t=U(n,"img","toPixels");if(!(n instanceof Kt)){const c=t;t=Fe(c,"int32"),c.dispose()}X6(t);const[s,r]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],a=await t.data(),o=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let c=0;c<s*r;++c){const d=[0,0,0,255];for(let m=0;m<i;m++){const g=a[c*i+m];if(t.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(t.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);i===1?(d[0]=g*o,d[1]=g*o,d[2]=g*o):d[m]=g*o}const p=c*4;u[p+0]=Math.round(d[0]),u[p+1]=Math.round(d[1]),u[p+2]=Math.round(d[2]),u[p+3]=Math.round(d[3])}if(e!=null){oT||nx(sS,se.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),oT=!0),e.width=r,e.height=s;const c=e.getContext("2d"),d=new ImageData(u,r,s);c.putImageData(d,0,0)}return t!==n&&t.dispose(),u}const OA=J({fromPixels_:q6});function ib(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(ce(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let p=0;p<r.length-1;++p)a*=r[p];const o=n.shape,u=r.slice();u.pop();let c=1;for(let p=i;p<t;++p)c*=o[p],u.push(o[p]);const d=[...Ze(n.shape).map(p=>p/c),1].slice(0,i);return[u,a,c,d]}const h2=-2,K6=-1;function ab(n,e,t){const s=n.shape.length;B(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),B(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)B(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Y6(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function ob(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function FA(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function zA(n,e,t){return t<=n?t:t-(e-1)}function LA(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function Q6(n,e,t,s,r,i,a,o,u){const c=n.length;let d=new Array(c),p=new Array(c),m=new Array(c);if(e.length&&t>0){const g=e[0],x=t+1;d=MA(a,g,x,s,n),p=PA(o,g,x,r,n),m=FA(i,g,x,n)}else for(let g=0;g<c;g++)d[g]=VA(a,s,i,n,g,u),p[g]=UA(o,r,i,n,g,u),m[g]=BA(i,g,u);return{begin:d,end:p,strides:m}}function MA(n,e,t,s,r){const i=[...r],a=LA(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const u=zA(e,t,o);let c=s[u];n&1<<u&&(c=0),i[o]=c}return i}function PA(n,e,t,s,r){const i=[...r],a=LA(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const u=zA(e,t,o);let c=s[u];n&1<<u&&(c=Number.MAX_SAFE_INTEGER),i[o]=c}for(let o=0;o<i.length;o++){const u=r[o];i[o]<0&&(i[o]+=u),i[o]=Su(0,i[o],r[o])}return i}function BA(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function VA(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),a=Su(0,a,u-1),a}function UA(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),o>0?a=Su(0,a,u):a=Su(-1,a,u-1),a}function sC(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function rC(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function Fm(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{B(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((a,o)=>a>=0?a:(B(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,i]}function lb(n,e,t,s,r,i,a,o,u){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};for(let I=0;I<p.dims;I++)d&&(1<<I&o)!==0&&p.numAddAxisAfterEllipsis++,1<<I&a&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Z6(p,m);let g=!0,x=!0,b=!0;const v=[],w=[];for(let I=0;I<n.length;++I){if(m.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const $=!!(m.shrinkAxisMask&1<<I),E=n[I];if(E===-1){v.push($?1:-1);continue}const D=[m.beginMask&1<<I,m.endMask&1<<I],F=[m.strides[I]>0?0:-1,m.strides[I]>0?E:E-1];if($&&m.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&m.strides[I]===1;const L=!!(m.beginMask&1<<I&&m.endMask&1<<I);if(m.beginValid&&m.endValid){if($){const H=m.begin[I]<0?E+m.begin[I]:m.begin[I];if(m.begin[I]=H,m.end[I]=m.begin[I]+1,H<0||H>=E)throw Error(`slice index ${m.begin[I]} of dimension ${I} out of bounds.`)}else m.begin[I]=lT(m.begin[I],0,m.strides[I],E,D,F),m.end[I]=lT(m.end[I],1,m.strides[I],E,D,F);const O=m.strides[I]===1&&m.begin[I]===0&&m.end[I]===E;g=g&&O,x=x&&(I===0&&m.strides[I]===1||O)}else g=g&&m.strides[I]===1&&L,x=x&&(I===0&&m.strides[I]===1||L);let z,M=!1;if(m.beginValid&&m.endValid?(z=m.end[I]-m.begin[I],M=!0):$?(z=1,M=!0):L&&E>=0&&(m.strides[I]<0?z=-E:z=E,M=!0),M){let O;z===0||z<0!=m.strides[I]<0?O=0:O=Math.trunc(z/m.strides[I])+(z%m.strides[I]!==0?1:0),v.push(O)}else v.push(-1)}for(let I=0;I<m.finalShapeGatherIndices.length;++I){const $=m.finalShapeGatherIndices[I];$>=0?w.push(v[$]):$===h2&&w.push(1)}return{finalShapeSparse:w.filter((I,$)=>m.finalShapeGatherIndices[$]!==h2),finalShape:w,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:m.begin,end:m.end,strides:m.strides}}function Z6(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(h2),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(K6),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function lT(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const a=n<0?s+n:n;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const J6=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ab,computeFlatOffset:rC,computeOutShape:ob,getNormalizedAxes:Q6,isSliceContinous:sC,maskToAxes:Y6,parseSliceParams:Fm,sliceInfo:lb,startForAxis:VA,startIndicesWithElidedDims:MA,stopForAxis:UA,stopIndicesWithElidedDims:PA,stridesForAxis:BA,stridesWithElidedDims:FA},Symbol.toStringTag,{value:"Module"}));class e5{static sgd(e){return new JS(e)}static momentum(e,t,s=!1){return new $A(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new IA(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new NA(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new SA(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new kA(e,t,s,r,i)}static adagrad(e,t=.1){return new CA(e,t)}}const jc=e5;const t5=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function WA(){return new Promise(n=>t5(()=>n()))}function ub(n,e){const t=n[0].length;n.forEach((r,i)=>{B(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),B(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let a=0;a<t;a++)B(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function lr(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var Ui;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Ui||(Ui={}));function GA(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],a=s[s.length-t.length+r],o=s[a];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${o}`)}else s[a]=i}return s}function HA(n){const e={FIRST_DIM_SIZE:Ui.FIRST_DIM_SIZE,VALUE_ROWIDS:Ui.VALUE_ROWIDS,ROW_LENGTHS:Ui.ROW_LENGTHS,ROW_SPLITS:Ui.ROW_SPLITS,ROW_LIMITS:Ui.ROW_LIMITS,ROW_STARTS:Ui.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function jA(n){return n.length===0?0:n[0]===Ui.FIRST_DIM_SIZE?n.length-1:n.length}function qA(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],a=e[r+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}const iC=30;function cb(n){return n<=iC?n:Kw(n,Math.floor(Math.sqrt(n)))}function hb(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function Wu(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let a=0;a<i;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(i+1))}return r}function Gu(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?i.push(a):r.push(a);s.push(...r),s.push(0),s.push(...i)}return s}function Hu(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function db(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function pb(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const zm=1.7580993408473768,Lm=1.0507009873554805;const fb=.3275911,mb=.254829592,gb=-.284496736,yb=1.421413741,xb=-1.453152027,bb=1.061405429;function Xi(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function XA(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function KA(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function YA(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function aC(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function QA(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function ZA(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function JA(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const gw="->",n5=/->/g,uT=",",cT="...";function vb(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(n5,"").length)/gw.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${gw}").`);const[s,r]=n.split(gw);B(s.indexOf(cT)===-1,()=>`The ellipsis notation ("${cT}") is not supported yet.`);const i=s.split(uT),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let m=0;m<r.length;++m){const g=r[m];if(!i.some(x=>x.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let m=0;m<s.length;++m){const g=s[m];o.indexOf(g)===-1&&g!==uT&&o.push(g)}const u=new Array(i.length);for(let m=0;m<a;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let g=0;g<i[m].length;++g)u[m].push(o.indexOf(i[m][g]))}const c=o.length,d=r.length,p=[];for(let m=d;m<c;++m)p.push(m);return{allDims:o,summedDims:p,idDims:u}}function wb(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Sb(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=i[a]:B(s[e[r][a]]===i[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function Cb(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<t.length;++a){const o=t[a],u=s5(e,o);for(const c of u)i.indexOf(c)===-1&&(s[a].push(c),i.push(c))}return{path:t,steps:s}}function Nb(n){return n.every((e,t)=>e===t)}function s5(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function kb(n,e,t=0){let s=[];if(typeof e=="number")B(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);B(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((o,u)=>u>0?o+u:o);e[i]=n.shape[t]-a}B(n.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function eD(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function tD(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function nD(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function sD(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function rD(n,e){return`size ${n} must be non-negative, not ${e}`}function iD(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function aD(n,e){const t=ce(n),s=ce(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function oD(n,e){const t=ce(n),s=ce(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function d2(){return"segment ids must be >= 0"}function lD(){return"segment ids are not increasing"}function uD(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function cD(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function hD(n,e){let t=!1,s;for(n<=iC?(s=n,t=!0):s=Kw(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=Kw(n,s+1);return s}function oC(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function $b(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let p=0;p<s;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const a=n.shape[t],o=[];let u=1,c=1,d=1;for(let p=0;p<s;++p)o.push(n.shape[p]),u*=n.shape[p];for(let p=s;p<t;p++)o.push(n.shape[p]),c*=n.shape[p];for(let p=s;p<r;p++)o.push(e.shape[p]);for(let p=t+1;p<i;p++)o.push(n.shape[p]),d*=n.shape[p];return{batchSize:u,sliceSize:d,outerSize:c,dimSize:a,outputShape:o}}const r5=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:$b,computeOutShape:oC,segOpComputeOptimalWindowSize:hD},Symbol.toStringTag,{value:"Module"}));function Ki(n){try{return n.map(e=>Hi(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function dD(n){return n.map(e=>ro(e))}const i5=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:mb,ERF_A2:gb,ERF_A3:yb,ERF_A4:xb,ERF_A5:bb,ERF_P:fb,PARALLELIZE_THRESHOLD:iC,get RowPartitionType(){return Ui},SELU_SCALE:Lm,SELU_SCALEALPHA:zm,applyActivation:tb,assertAndGetBroadcastShape:it,assertAxesAreInnerMostDims:Hn,assertParamsConsistent:ub,assignToTypedArray:QA,axesAreInnerMostDims:$S,calculateShapes:Ta,checkEinsumDimSizes:Sb,checkPadOnDimRoundingMode:Qs,combineLocations:U3,combineRaggedTensorToTensorShapes:GA,complexWithEvenIndex:KA,complexWithOddIndex:YA,computeConv2DInfo:fn,computeConv3DInfo:ea,computeDefaultPad:bS,computeDilation2DInfo:Nl,computeOptimalWindowSize:cb,computeOutAndReduceShapes:Mn,computeOutShape:lr,computePool2DInfo:zs,computePool3DInfo:Qr,convertConv2DDataFormat:Dr,decodeEinsumEquation:vb,eitherStridesOrDilationsAreOne:is,expandShapeToKeepDim:Dn,exponent:JA,exponents:ZA,fromStringArrayToUint8:dD,fromUint8ToStringArray:Ki,getAxesPermutation:sn,getBroadcastDims:dl,getComplexWithIndex:aC,getEinsumComputePath:Cb,getEinsumPermutation:wb,getFusedBiasGradient:eb,getFusedDyActivation:J0,getImageCenter:hb,getInnerMostAxes:mn,getPermuted:Gu,getRaggedRank:jA,getReductionAxes:rs,getReshaped:Wu,getReshapedPermuted:Hu,getRowPartitionTypesHelper:HA,getSliceBeginCoords:db,getSliceSize:pb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:eD,getSparseFillEmptyRowsNegativeIndexErrorMessage:tD,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:nD,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:iD,getSparseReshapeInputOutputMismatchErrorMessage:oD,getSparseReshapeInputOutputMultipleErrorMessage:aD,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:sD,getSparseReshapeNegativeOutputDimErrorMessage:rD,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:cD,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:d2,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:lD,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:uD,getUndoAxesPermutation:$a,isIdentityPermutation:Nb,log:qB,mergeRealAndImagArrays:Xi,prepareAndValidate:ib,prepareSplitSize:kb,segment_util:r5,shouldFuse:nb,slice_util:J6,splitRealAndImagArrays:XA,stridesOrDilationsArePositive:Eu,tupleValuesAreOne:cl,upcastType:ys,validateDefaultValueShape:qA,validateInput:HS,validateUpdateShape:oA,warn:Hr},Symbol.toStringTag,{value:"Module"}));E6();const pD={kernelName:If,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,$d(Fe(t,"float32"),-1))}}};const a5={kernelName:Eh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=tn(Fe(t,"float32")),r=ks(Ue(Je(1),s));return gn(Ve(n,r))}}}};const o5={kernelName:Rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=ks(Ue(tn(Fe(t,"float32")),1));return Ve(n,s)}}}};const l5={kernelName:Pu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{let o=n;const u=rs(t.shape,r);return u.length>0&&(o=Ke(o,u)),ae(o,t.shape)},b:()=>{let o=n;const u=rs(s.shape,r);return u.length>0&&(o=Ke(o,u)),ae(o,s.shape)}}}};const u5={kernelName:Tf,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const c5={kernelName:Ef,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ot(t)}}};const h5={kernelName:Rf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ot(t)}}};const d5={kernelName:Ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,ks(Ue(Je(1),tn(Fe(t,"float32")))))}}};const p5={kernelName:Dh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=ks($e(Je(1),tn(Fe(t,"float32"))));return Ve(n,s)}}}};const f5={kernelName:Fh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{const o=$e(tn(t),tn(s));let u=Q(n,Ve(s,o));const c=rs(t.shape,r);return c.length>0&&(u=Ke(u,c)),ae(u,t.shape)},b:()=>{const o=$e(tn(t),tn(s));let u=gn(Q(n,Ve(t,o)));const c=rs(s.shape,r);return c.length>0&&(u=Ke(u,c)),ae(u,s.shape)}}}};const m5={kernelName:_h,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,$e(tn(Fe(t,"float32")),1))}}};const g5={kernelName:Oh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,Ue(Je(1),tn(Fe(t,"float32"))))}}};function y5(n,e,t,s,r,i){const a=U(n,"dy","avgPool3dGrad"),o=U(e,"input","avgPool3dGrad");let u=a,c=o,d=!1;o.rank===4&&(d=!0,u=ae(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),B(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),B(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Qs("avgPool3dGrad",r,i);const p={dy:u,input:c},m={filterSize:t,strides:s,pad:r,dimRoundingMode:i},g=se.runKernel(Px,p,m);return d?ae(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const x5=J({avgPool3dGrad_:y5});const b5={kernelName:Df,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=t;return{x:()=>x5(n,s,r,i,a,o)}}};function v5(n,e,t,s,r){const i=U(n,"dy","avgPoolGrad"),a=U(e,"input","avgPoolGrad");B(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,u=i,c=!1;a.rank===3&&(c=!0,o=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]])),B(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),B(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const d={dy:u,input:o},p={filterSize:t,strides:s,pad:r},m=se.runKernel(Mx,d,p);return c?ae(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const w5=J({avgPoolGrad_:v5});const S5={kernelName:Af,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=t;return{x:()=>w5(n,s,r,i,a)}}};const C5={kernelName:_f,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:a}=t;return!i&&!a?{a:()=>kt(n,r,!1,!0),b:()=>kt(s,n,!0,!1)}:!i&&a?{a:()=>kt(n,r,!1,!1),b:()=>kt(n,s,!0,!1)}:i&&!a?{a:()=>kt(r,n,!1,!0),b:()=>kt(s,n,!1,!1)}:{a:()=>kt(r,n,!0,!0),b:()=>kt(n,s,!0,!0)}}};const N5={kernelName:Of,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>H0(n,s,r)}}};const k5={kernelName:HB,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,a=Array.from(i);for(let u=r.length-1;u>=0;u--)if(r[u]===i[u])a[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const o=[];for(let u=0;u<a.length;u++)a[u]>1&&o.push(u);return{x:()=>Ke(n,o,!0)}}};const $5={kernelName:zh,gradFunc:n=>({x:()=>n.clone()})};const I5={kernelName:Lh,gradFunc:n=>({x:()=>Ot(n)})};const T5={kernelName:Mh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>Fs(wa(kl(s,r),Vu(s,i)),n,Ot(n))}}};const E5={kernelName:Ff,inputsToSave:["x"],gradFunc:pD.gradFunc};const R5={kernelName:zf,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(u=>u.shape),{axis:r}=t,i=gt(r,e[0].shape)[0],a=s.map(u=>u[i]);return Ir(n,a,i).map(u=>()=>u)}};const A5={kernelName:Lf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:u}=t;return B(cl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>wS(s.shape,n,r,a,o,u),filter:()=>YS(s,n,r.shape,a,o,u)}}};const D5={kernelName:Mf,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:u}=t;return{dy:()=>hl(n,r,i,a,o,1,u),filter:()=>YS(n,s,r.shape,i,a,o,u)}}};function _5(n,e,t,s,r){let i=n;n.rank===4&&(i=ae(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=ae(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),B(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),B(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),B(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),B(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),B(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:i,dy:a},u={strides:s,pad:r,filterShape:t};return se.runKernel(Hx,o,u)}const O5=J({conv3DBackpropFilter_:_5});const F5={kernelName:Pf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;B(cl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>z3(a.shape,n,o,r,i),filter:()=>O5(a,n,o.shape,r,i)}}};const z5={kernelName:Ph,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(gn(BS(Fe(t,"float32"))),n)}}};const L5={kernelName:Bh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(VS(Fe(t,"float32")),n)}}};const M5={kernelName:Bf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=t;return{x:()=>{const o=sn([r],s.rank);let u=NS(n,r,i,!a);return o!=null&&(u=_t(u,o)),u}}}};const P5={kernelName:Vf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=t,o=s??[1,1];B(cl(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,c]=e;return B(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),B(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),B(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),B(is(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Qs("depthwiseConv2d",i,a),{x:()=>gA(u.shape,n,c,r,i,o,a),filter:()=>mA(u,n,c.shape,r,i,o,a)}}};const B5={kernelName:Uf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>se.runKernel(Zy,i,t),filter:()=>se.runKernel(Jy,a,t)}}};const V5={kernelName:Uh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>se.runKernel(t0,s)}}};const U5={kernelName:Wh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=Q(Ks(gn(tn(t))),2/Math.sqrt(Math.PI));return{x:()=>Q(n,s)}}};const W5={kernelName:Gh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,t)}}};const G5={kernelName:Gf,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ae(n,t.shape)}}};const H5={kernelName:Hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Ks(t))}}};const j5={kernelName:jh,gradFunc:n=>({x:()=>Ot(n)})};const q5={kernelName:qh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{const o=Ve(n,Fe(s,"float32")),u=rs(t.shape,r);return u.length>0?ae(Ke(o,u),t.shape):o},b:()=>{let o=Q(n,Fe(t,"float32"));const u=rs(s.shape,r);u.length>0&&(o=ae(Ke(o,u),s.shape));const c=tn(s);return gn(Ve(o,Fe(c,"float32")))}}}};const X5={kernelName:Hf,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,a,o]=e,u=o??Je(1),c=rs(i.shape,r.shape),d=[];if(i.rank===1){for(let $=0;$<r.shape.length-1;++$)d.push(r.shape[$]);d.push(1)}const p=Ue(r,i),m=Q(n,u),g=LS($e(a,Je(s))),x=Q(Q(Q(g,g),g),Je(-.5));return{x:()=>i.rank===1?ae(Q(Q(n,bi(ae(g,[1,1,1,i.shape[0]]),d)),u),r.shape):ae(Q(Q(n,g),u),r.shape),mean:()=>{let $=Q(Q(g,Je(-1)),m);return i.rank===1&&($=Ke($,c)),ae($,i.shape)},variance:()=>{let $=Q(Q(x,p),m);return i.rank===1&&($=Ke($,c)),ae($,i.shape)},scale:()=>{const $=Q(p,g);let E=Q(n,$);return i.rank===1&&(E=Ke(E,c)),ae(E,i.shape)},offset:()=>{let $=n;return i.rank===1&&($=Ke($,c)),ae($,i.shape)}}}};const K5={kernelName:jf,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:a}=t,o=gt(i,s.shape)[0],u=(c,d,p)=>()=>{const m=c.shape,g=d.size,x=m.slice(0,o),b=x.length,v=m.slice(i,m.length).slice(1),w=v.length,N=hT(0,b),I=hT(b+1,b+1+w),$=dT([x,[g],v]),E=ae(p,$),D=ae(d,[g]),F=dT([[b],N,I]),L=_t(E,F);let z=qS(L,D,c.shape[o]);const M=$a(F);return z=_t(z,M),z};if(a===1){const c=s.shape[0],d=s.split(c,0);return{x:()=>Tr(d.map((g,x)=>u(g,r.slice(x,1),n.slice(x,1))())).reshape(s.shape),indices:()=>r}}else return{x:u(s,r,n),indices:()=>r}}};function hT(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function dT(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const Y5={kernelName:Xh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Ot(t),b:()=>Ot(s)}}};const Q5={kernelName:Kh,gradFunc:n=>({x:()=>Fe(n,"float32")})};const Z5={kernelName:Yh,gradFunc:n=>({x:()=>Ot(n)})};const J5={kernelName:Qh,gradFunc:n=>({x:()=>Ot(n)})};const eq={kernelName:Zh,gradFunc:n=>({x:()=>Ot(n)})};const tq={kernelName:Xf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=_r(s,0);return{x:()=>Fs(i,n,Q(n,r))}}};const nq={kernelName:ed,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,$e(t,1))}}};const sq={kernelName:Jh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,Fe(t,"float32"))}}};const rq={kernelName:jB,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const a=Ks(s);return Ue(n,Q(Ke(n,r,!0),a))}}}};function iq(n,e,t,s=5,r=1,i=1,a=.5){const o={x:n,y:e,dy:t},u={depthRadius:s,bias:r,alpha:i,beta:a};return se.runKernel(u0,o,u)}const aq=J({localResponseNormalizationBackprop_:iq});const oq={kernelName:em,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:u}=t;return{x:()=>aq(s,r,n,i,a,o,u)}}};function fD(n,e,t,s){return e.rank<t.rank&&(e=ae(e,Dn(e.shape,s))),n.rank<t.rank&&(n=ae(n,Dn(n.shape,s))),{x:()=>Q(n,Fe(ji(t,e),n.dtype))}}const pT={kernelName:tm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],a=e[1],o=gt(r,i.shape),u=fD(n,a,i,o);return{x:()=>u.x()}}};const lq={kernelName:td,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Q(n,Fe(kl(t,s),"float32")),b:()=>Q(n,Fe(df(t,s),"float32"))}}};function uq(n,e,t,s,r,i,a){const o=U(n,"dy","maxPool3dGrad"),u=U(e,"input","maxPool3dGrad"),c=U(t,"output","maxPool3dGrad");let d=o,p=u,m=c,g=!1;u.rank===4&&(g=!0,d=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=ae(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=ae(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),B(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),B(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),B(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Qs("maxPool3dGrad",i,a);const x={dy:d,input:p,output:m},b={filterSize:s,strides:r,pad:i,dimRoundingMode:a},v=se.runKernel(h0,x,b);return g?ae(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}const cq=J({maxPool3dGrad_:uq});const hq={kernelName:sm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=t;return{x:()=>cq(n,s,r,i,a,o,u)}}};function dq(n,e,t,s,r,i,a){const o=U(n,"dy","maxPoolGrad"),u=U(e,"input","maxPoolGrad"),c=U(t,"output","maxPoolGrad");B(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),B(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),B(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Qs("maxPoolGrad",i,a);const d={dy:o,input:u,output:c},p={filterSize:s,strides:r,pad:i,dimRoundingMode:a};return se.runKernel(c0,d,p)}const pq=J({maxPoolGrad_:dq});const fq={kernelName:nm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=t;return{x:()=>pq(n,s,r,i,a,o)}}};const mq={kernelName:rm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=gt(r,s.shape),o=Mn(s.shape,i)[1],u=ce(o);return{x:()=>{const d=s.shape.slice();i.forEach(g=>{d[g]=1});const p=ae(n,d);return Ve(Q(p,$r(s.shape,"float32")),u)}}}};const gq={kernelName:im,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,a]=e,o=gt(r,i.shape),u=fD(n,a,i,o);return{x:()=>u.x()}}};const yq={kernelName:nd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Q(n,Fe(Vu(t,s),"float32")),b:()=>Q(n,Fe(_r(t,s),"float32"))}}};const xq={kernelName:am,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>dt(n,i,s.shape)}}};const bq={kernelName:sd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{const o=rs(t.shape,r);return o.length>0?ae(Ke(n,o),t.shape):n},b:()=>{const o=Q(n,gn(_m(Ve(t,s)))),u=rs(s.shape,r);return u.length>0?ae(Ke(o,u),s.shape):o}}}};const vq={kernelName:rd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{const o=Q(n,Fe(s,"float32")),u=rs(t.shape,r);return u.length>0?ae(Ke(o,u),t.shape):o},b:()=>{const o=Q(n,Fe(t,"float32")),u=rs(s.shape,r);return u.length>0?ae(Ke(o,u),s.shape):o}}}};const wq={kernelName:om,gradFunc:n=>({x:()=>gn(n)})};const Sq={kernelName:cm,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>zn(t.shape,"float32")}}};const Cq={kernelName:um,gradFunc:n=>({x:()=>Ot(n)})};const Nq={kernelName:hm,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Ii(n,s).map(i=>()=>i)}};const fT={kernelName:dm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>dt(n,i,s.shape)}}};const kq={kernelName:id,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,a=s,o=it(i.shape,a.shape);return{a:()=>{const d=Fe(a,"float32");let p=Q(n,Q(d,uo(i,Ue(d,Je(1)))));const m=rs(i.shape,o);return m.length>0&&(p=Ke(p,m)),ae(p,i.shape)},b:()=>{const d=_r(i,0),p=Fs(d,Xr(i),Ot(i));let m=Q(n,Q(r,p));const g=rs(a.shape,o);return g.length>0&&(m=Ke(m,g)),ae(m,a.shape)}}}};const $q={kernelName:pm,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=_r(t,0);return{x:()=>Fs(r,n,Q(n,s)),alpha:()=>{let i=Fs(r,Ot(n),Q(n,t));const a=rs(s.shape,n.shape);return a.length>0&&(i=Ke(i,a)),ae(i,s.shape)}}}};function Iq(n,e,t){const s=n.shape.slice();s[t]=1;const r=ae(e,s),i=ax(n,t,!0,!1),a=ax(n,t,!0,!0),o=Q(i,a);return Q(r,o)}function Tq(n,e,t){const s=n.shape.length,r=s-t.length,i=sn(t,s);let a=n;i!=null&&(a=_t(n,i));const o=a.shape.slice(),c=o.splice(s-t.length,t.length).reduce((m,g)=>m*g,1);o.push(c);const d=a.reshape(o);let p=Iq(d,e,r);if(p=p.reshape(a.shape),i!=null){const m=$a(i);p=_t(p,m)}return p}const Eq={kernelName:fm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((a,o)=>o):typeof r=="number"?i=[r]:i=r,{x:()=>Tq(s,n,i)}}};const Rq={kernelName:Vh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{const o=Ve(n,Fe(s,"float32")),u=rs(t.shape,r);return u.length>0?ae(Ke(o,u),t.shape):o},b:()=>{let o=Q(n,Fe(t,"float32"));const u=rs(s.shape,r);u.length>0&&(o=ae(Ke(o,u),s.shape));const c=tn(s);return gn(Ve(o,Fe(c,"float32")))}}}};const Aq={kernelName:ad,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,gn(tn(t)))}}};const Dq={kernelName:ld,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=Q(Vu(t,6),$d(t));return{x:()=>Q(n,Fe(s,"float32"))}}};const _q={kernelName:od,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Fe($d(t),"float32"))}}};const Oq={kernelName:mm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,t.shape)}}};const Fq={kernelName:ym,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>se.runKernel(b0,r,t)}}};const zq={kernelName:gm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>se.runKernel(x0,r,t)}}};const Lq={kernelName:xm,gradFunc:(n,e,t)=>{const{dims:s}=t,r=gt(s,n.shape);return{x:()=>$i(n,r)}}};const Mq={kernelName:ud,gradFunc:n=>({x:()=>Ot(n)})};const Pq={kernelName:cd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>gn(Ve(n,Q(uo(t,1.5),2)))}}};const Bq={kernelName:bm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Fe(Ot(t),"float32"),t:()=>Q(n,Fe(t,n.dtype)),e:()=>Q(n,Fe(U0(t),n.dtype))}}};const Vq={kernelName:hd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=_r(t,Je(0)),r=Je(zm),i=Je(Lm),a=Q(n,i),o=Q(Q(n,r),Ks(Fe(t,"float32")));return Fs(s,a,o)}}}};const Uq={kernelName:md,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Q(t,Ue(Je(1),t)))}}};const Wq={kernelName:fd,gradFunc:n=>({x:()=>Ot(n)})};const Gq={kernelName:dd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(L0(Fe(t,"float32")),n)}}};const Hq={kernelName:pd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(CS(Fe(t,"float32")),n)}}};const jq={kernelName:vm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,a=s.shape,[o,u]=Fm(s,r,i),c=[];for(let d=0;d<n.rank;d++)c.push([o[d],a[d]-o[d]-u[d]]);return{x:()=>qi(n,c)}}};const qq={kernelName:Nm,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,a=Q(n,s);return{logits:()=>Ue(a,Q(Ke(a,[r],i),s))}}};const Xq={kernelName:gd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,qr(t))}}};const mT={kernelName:Sm,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>z0(n,s,r)}}};const gT={kernelName:Cm,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>$n(n,s)}}};const Kq={kernelName:yd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,Q(ks(Fe(t,"float32")),2))}}};const Yq={kernelName:$0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(n,Q(Fe(t,"float32"),2))}}};const Qq={kernelName:xd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Je(2);return{a:()=>Q(n,Q(r,Ue(t,s))),b:()=>Q(n,Q(r,Ue(s,t)))}}};const Zq={kernelName:Cd,gradFunc:n=>({x:()=>Ot(n)})};const Jq={kernelName:bd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=it(t.shape,s.shape);return{a:()=>{let o=n;const u=rs(t.shape,r);return u.length>0&&(o=Ke(o,u)),ae(o,t.shape)},b:()=>{let o=n;const u=rs(s.shape,r);return u.length>0&&(o=Ke(o,u)),ae(gn(o),s.shape)}}}};const e8={kernelName:wm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;gt(i,s.shape).forEach(c=>{r[c]=1});const o=ae(n,r),u=Q(o,$r(s.shape,"float32"));return{x:()=>u}}};const t8={kernelName:vd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ve(n,tn(L0(t)))}}};const n8={kernelName:wd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Q(Ue(Je(1),tn(t)),n)}}};const s8={kernelName:Sd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let a=Ot(s);if(s.rank===1)for(let o=0;o<r[0];++o)a=$e(a,dt(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)a=$e(a,dt(n,[o*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let c=0;c<r[2];++c)a=$e(a,dt(n,[o*s.shape[0],u*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let c=0;c<r[2];++c)for(let d=0;d<r[3];++d)a=$e(a,dt(n,[o*s.shape[0],u*s.shape[1],c*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};const r8={kernelName:yu,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=$a(r);return{x:()=>_t(n,i)}}};const i8={kernelName:km,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>Tr(n,r)}}};const a8={kernelName:$m,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o8(n,t)}}};function o8(n,e){const t=po(e,Ot(e)),s=Om(n,t);let r=kl(e,Je(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=Wn(r,o+1);r=wa(r,$r(s.shape,"bool"));const a=Ot(s);return Fs(r,s,a)}const l8={kernelName:Im,gradFunc:n=>({x:()=>Ot(n)})};const u8=[pD,a5,o5,l5,u5,c5,h5,d5,p5,f5,m5,g5,b5,S5,C5,N5,k5,$5,I5,T5,E5,R5,D5,A5,F5,z5,L5,M5,P5,B5,Rq,V5,U5,W5,G5,H5,q5,j5,X5,K5,Y5,Q5,Z5,J5,eq,tq,nq,sq,rq,oq,pT,pT,lq,hq,fq,mq,gq,yq,xq,bq,vq,wq,Sq,Cq,Nq,fT,fT,kq,$q,Eq,Aq,Dq,_q,Oq,Fq,zq,Lq,Mq,Pq,Bq,Vq,Uq,Wq,Gq,Hq,jq,qq,Xq,mT,mT,gT,gT,Kq,Qq,Yq,Zq,Jq,e8,t8,n8,s8,r8,i8,a8,l8];for(const n of u8)XB(n);Ce().prototype.abs=function(){return this.throwIfDisposed(),Qn(this)};Ce().prototype.acos=function(){return this.throwIfDisposed(),y3(this)};Ce().prototype.acosh=function(){return this.throwIfDisposed(),x3(this)};Ce().prototype.add=function(n){return this.throwIfDisposed(),$e(this,n)};Ce().prototype.all=function(n,e){return this.throwIfDisposed(),xS(this,n,e)};Ce().prototype.any=function(n,e){return this.throwIfDisposed(),ix(this,n,e)};Ce().prototype.argMax=function(n){return this.throwIfDisposed(),Tu(this,n)};Ce().prototype.argMin=function(n){return this.throwIfDisposed(),b3(this,n)};Ce().prototype.asScalar=function(){return this.throwIfDisposed(),B(this.size===1,()=>"The array must have only 1 element."),ae(this,[])};Ce().prototype.asType=function(n){return this.throwIfDisposed(),Fe(this,n)};Ce().prototype.as1D=function(){return this.throwIfDisposed(),ae(this,[this.size])};Ce().prototype.as2D=function(n,e){return this.throwIfDisposed(),ae(this,[n,e])};Ce().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),ae(this,[n,e,t])};Ce().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),ae(this,[n,e,t,s])};Ce().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),ae(this,[n,e,t,s,r])};Ce().prototype.asin=function(){return this.throwIfDisposed(),v3(this)};Ce().prototype.asinh=function(){return this.throwIfDisposed(),w3(this)};Ce().prototype.atan=function(){return this.throwIfDisposed(),S3(this)};Ce().prototype.atan2=function(n){return this.throwIfDisposed(),C3(this,n)};Ce().prototype.atanh=function(){return this.throwIfDisposed(),N3(this)};Ce().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),F0(this,n,e,t,s)};Ce().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),z0(this,n,e)};Ce().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Em(this,n,e,t,s,r)};Ce().prototype.broadcastTo=function(n){return this.throwIfDisposed(),oh(this,n)};Ce().prototype.cast=function(n){return this.throwIfDisposed(),Fe(this,n)};Ce().prototype.ceil=function(){return this.throwIfDisposed(),R3(this)};Ce().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),hr(this,n,e)};Ce().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Kt&&(n=[n]),$n([this,...n],e)};Ce().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),vS(this,n,e,t,s,r,i)};Ce().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),SS(this,n,e,t,s,r)};Ce().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),hl(this,n,e,t,s,r,i)};Ce().prototype.cos=function(){return this.throwIfDisposed(),L0(this)};Ce().prototype.cosh=function(){return this.throwIfDisposed(),CS(this)};Ce().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),ax(this,n,e,t)};Ce().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),NS(this,n,e,t)};Ce().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),M3(this,n,e)};Ce().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Rm(this,n,e,t,s,r,i)};Ce().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),P3(this,n,e,t,s,r)};Ce().prototype.divNoNan=function(n){return this.throwIfDisposed(),B3(this,n)};Ce().prototype.div=function(n){return this.throwIfDisposed(),Ve(this,n)};Ce().prototype.dot=function(n){return this.throwIfDisposed(),V3(this,n)};Ce().prototype.elu=function(){return this.throwIfDisposed(),Am(this)};Ce().prototype.equal=function(n){return this.throwIfDisposed(),ji(this,n)};Ce().prototype.erf=function(){return this.throwIfDisposed(),kS(this)};Ce().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),G3(this,n,e)};Ce().prototype.exp=function(){return this.throwIfDisposed(),Ks(this)};Ce().prototype.expandDims=function(n){return this.throwIfDisposed(),Wn(this,n)};Ce().prototype.expm1=function(){return this.throwIfDisposed(),H3(this)};Ce().prototype.fft=function(){return this.throwIfDisposed(),Q0(this)};Ce().prototype.flatten=function(){return this.throwIfDisposed(),ae(this,[this.size])};Ce().prototype.floor=function(){return this.throwIfDisposed(),_m(this)};Ce().prototype.floorDiv=function(n){return this.throwIfDisposed(),yS(this,n)};Ce().prototype.gather=function(n,e,t){return this.throwIfDisposed(),Om(this,n,e,t)};Ce().prototype.greaterEqual=function(n){return this.throwIfDisposed(),kl(this,n)};Ce().prototype.greater=function(n){return this.throwIfDisposed(),_r(this,n)};Ce().prototype.ifft=function(){return this.throwIfDisposed(),mf(this)};Ce().prototype.irfft=function(){return this.throwIfDisposed(),WS(this)};Ce().prototype.isFinite=function(){return this.throwIfDisposed(),j3(this)};Ce().prototype.isInf=function(){return this.throwIfDisposed(),q3(this)};Ce().prototype.isNaN=function(){return this.throwIfDisposed(),X3(this)};Ce().prototype.leakyRelu=function(n){return this.throwIfDisposed(),P0(this,n)};Ce().prototype.lessEqual=function(n){return this.throwIfDisposed(),Vu(this,n)};Ce().prototype.less=function(n){return this.throwIfDisposed(),df(this,n)};Ce().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),K3(this,n,e,t,s)};Ce().prototype.logSigmoid=function(){return this.throwIfDisposed(),Y3(this)};Ce().prototype.logSoftmax=function(n){return this.throwIfDisposed(),TS(this,n)};Ce().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),V0(this,n,e)};Ce().prototype.log=function(){return this.throwIfDisposed(),Xr(this)};Ce().prototype.log1p=function(){return this.throwIfDisposed(),B0(this)};Ce().prototype.logicalAnd=function(n){return this.throwIfDisposed(),wa(this,n)};Ce().prototype.logicalNot=function(){return this.throwIfDisposed(),U0(this)};Ce().prototype.logicalOr=function(n){return this.throwIfDisposed(),ES(this,n)};Ce().prototype.logicalXor=function(n){return this.throwIfDisposed(),Q3(this,n)};Ce().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),kt(this,n,e,t)};Ce().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),W0(this,n,e,t,s)};Ce().prototype.max=function(n,e){return this.throwIfDisposed(),Ci(this,n,e)};Ce().prototype.maximum=function(n){return this.throwIfDisposed(),po(this,n)};Ce().prototype.mean=function(n,e){return this.throwIfDisposed(),Tn(this,n,e)};Ce().prototype.min=function(n,e){return this.throwIfDisposed(),hf(this,n,e)};Ce().prototype.minimum=function(n){return this.throwIfDisposed(),pl(this,n)};Ce().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),AS(this,n,e)};Ce().prototype.mod=function(n){return this.throwIfDisposed(),J3(this,n)};Ce().prototype.mul=function(n){return this.throwIfDisposed(),Q(this,n)};Ce().prototype.neg=function(){return this.throwIfDisposed(),gn(this)};Ce().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Dm(this,n,e,t)};Ce().prototype.notEqual=function(n){return this.throwIfDisposed(),ph(this,n)};Ce().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),DS(this,n,e,t)};Ce().prototype.onesLike=function(){return this.throwIfDisposed(),Kr(this)};Ce().prototype.pad=function(n,e){return this.throwIfDisposed(),qi(this,n,e)};Ce().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),eA(this,n,e,t,s,r,i)};Ce().prototype.pow=function(n){return this.throwIfDisposed(),uo(this,n)};Ce().prototype.prelu=function(n){return this.throwIfDisposed(),j0(this,n)};Ce().prototype.prod=function(n,e){return this.throwIfDisposed(),tA(this,n,e)};Ce().prototype.reciprocal=function(){return this.throwIfDisposed(),nA(this)};Ce().prototype.relu=function(){return this.throwIfDisposed(),Ia(this)};Ce().prototype.relu6=function(){return this.throwIfDisposed(),FS(this)};Ce().prototype.reshapeAs=function(n){return this.throwIfDisposed(),ae(this,n.shape)};Ce().prototype.reshape=function(n){return this.throwIfDisposed(),ae(this,n)};Ce().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),bA(this,n,e,t)};Ce().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),vA(this,n,e,t)};Ce().prototype.reverse=function(n){return this.throwIfDisposed(),$i(this,n)};Ce().prototype.rfft=function(){return this.throwIfDisposed(),Z0(this)};Ce().prototype.round=function(){return this.throwIfDisposed(),zS(this)};Ce().prototype.rsqrt=function(){return this.throwIfDisposed(),LS(this)};Ce().prototype.selu=function(){return this.throwIfDisposed(),MS(this)};Ce().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),PS(this,n,e,t,s,r,i)};Ce().prototype.sigmoid=function(){return this.throwIfDisposed(),qr(this)};Ce().prototype.sign=function(){return this.throwIfDisposed(),sA(this)};Ce().prototype.sin=function(){return this.throwIfDisposed(),BS(this)};Ce().prototype.sinh=function(){return this.throwIfDisposed(),VS(this)};Ce().prototype.slice=function(n,e){return this.throwIfDisposed(),dt(this,n,e)};Ce().prototype.softmax=function(n){return this.throwIfDisposed(),Y0(this,n)};Ce().prototype.softplus=function(){return this.throwIfDisposed(),kd(this)};Ce().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),H0(this,n,e)};Ce().prototype.split=function(n,e){return this.throwIfDisposed(),Ir(this,n,e)};Ce().prototype.sqrt=function(){return this.throwIfDisposed(),ks(this)};Ce().prototype.square=function(){return this.throwIfDisposed(),tn(this)};Ce().prototype.squaredDifference=function(n){return this.throwIfDisposed(),GS(this,n)};Ce().prototype.squeeze=function(n){return this.throwIfDisposed(),Wt(this,n)};Ce().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Kt?[this,n]:[this,...n];return Tr(t,e)};Ce().prototype.step=function(n){return this.throwIfDisposed(),$d(this,n)};Ce().prototype.stridedSlice=function(n,e,t,s,r,i,a,o){return this.throwIfDisposed(),rA(this,n,e,t,s,r,i,a,o)};Ce().prototype.sub=function(n){return this.throwIfDisposed(),Ue(this,n)};Ce().prototype.sum=function(n,e){return this.throwIfDisposed(),Ke(this,n,e)};Ce().prototype.tan=function(){return this.throwIfDisposed(),iA(this)};Ce().prototype.tanh=function(){return this.throwIfDisposed(),Ru(this)};Ce().prototype.tile=function(n){return this.throwIfDisposed(),bi(this,n)};Ce().prototype.toBool=function(){return this.throwIfDisposed(),Fe(this,"bool")};Ce().prototype.toFloat=function(){return this.throwIfDisposed(),Fe(this,"float32")};Ce().prototype.toInt=function(){return this.throwIfDisposed(),Fe(this,"int32")};Ce().prototype.topk=function(n,e){return this.throwIfDisposed(),lA(this,n,e)};Ce().prototype.transpose=function(n){return this.throwIfDisposed(),_t(this,n)};Ce().prototype.unique=function(n){return this.throwIfDisposed(),uA(this,n)};Ce().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),qS(this,n,e)};Ce().prototype.unstack=function(n){return this.throwIfDisposed(),Ii(this,n)};Ce().prototype.where=function(n,e){return this.throwIfDisposed(),Fs(n,this,e)};Ce().prototype.zerosLike=function(){return this.throwIfDisposed(),Ot(this)};class pa extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pa.prototype)}}class vi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vi.prototype)}}class oe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,oe.prototype)}}class St extends Error{constructor(e){super(e),Object.setPrototypeOf(this,St.prototype)}}class lC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lC.prototype)}}class mD{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function Du(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function fa(n,e){if(!n)throw new lC(e)}function yT(n,e){let t=0;for(const s of n)s===e&&t++;return t}function ar(n){return n.length===1?n[0]:n}function Yt(n){return Array.isArray(n)?n:[n]}function eo(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function cu(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let fi={};function uC(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function p2(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>p2(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:p2(s))}}}function Mm(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let a;if(i in t)a=t[i];else if(i in fi)a=fi[i];else if(a=e[i],a==null)throw new oe(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const i=n;if(i.className==null||i.config==null)throw new oe(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const a=i.className;let o,u;if(a in t?[o,u]=t[a]:a in fi?[o,u]=fi.className:a in e&&([o,u]=e[a]),o==null)throw new oe(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const c={};for(const g of Object.keys(fi))c[g]=fi[g];for(const g of Object.keys(t))c[g]=t[g];const d=i.config;d.customObjects=c;const p=Object.assign({},fi);for(const g of Object.keys(t))fi[g]=t[g];p2(i.config);const m=u(o,i.config,t,r);return fi=Object.assign({},p),m}else{const c=Object.assign({},fi);for(const p of Object.keys(t))fi[p]=t[p];const d=new o(i.config);return fi=Object.assign({},c),d}}}function c8(n,e){return n<e?-1:n>e?1:0}function wy(n,e){return-1*c8(n,e)}function al(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function h8(n){if(n==null)throw new oe(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function ju(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new oe(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function cC(n,e,t=0,s=1/0){return fa(t>=0),fa(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function gs(n,e){Array.isArray(n)?(B(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>gs(t,`element ${s+1} of ${e}`))):B(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${gD(n)}.`)}function gD(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>gD(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function d8(n,e,t){let s=t!=null?t():ir(),r;return(...a)=>{const o=t!=null?t():ir();return o-s<e||(s=o,r=n(...a)),r}}function yD(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let p8=0;function xD(){return p8++}const Sy={};function Ib(n=""){return n in Sy||(Sy[n]=0),Sy[n]+=1,n+Sy[n].toString()}const f8=["channelsFirst","channelsLast"],m8=["nearest","bilinear"],g8=["valid","same","causal"],y8=["max","avg"],x8=["sum","mul","concat","ave"];const qc=new Map;function Pn(n){ju(f8,"DataFormat",n)}function b8(n){ju(m8,"InterpolationFormat",n)}function Zr(n){ju(g8,"PaddingMode",n)}function bD(n){ju(y8,"PoolMode",n)}const ef=[],xT="/";function xu(n,e){ef.push(n);try{const t=e();return ef.pop(),t}catch(t){throw ef.pop(),t}}function v8(){return ef.length===0?"":ef.join(xT)+xT}function vD(n){if(!SD(n))throw new Error("Not a valid tensor name: '"+n+"'");return v8()+n}function wD(n){if(!SD(n))throw new Error("Not a valid tensor name: '"+n+"'");qc.has(n)||qc.set(n,0);const e=qc.get(n);if(qc.set(n,qc.get(n)+1),e>0){const t=`${n}_${e}`;return qc.set(t,1),t}else return n}const w8=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function SD(n){return!!n.match(w8)}function S8(n){return n===parseInt(n.toString(),10)}function ol(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function mh(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function fl(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Yi(n,e){if(e<n)throw new oe(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let yw;function Zn(){return yw==null&&(yw=ku().epsilon()),yw}function Qi(){return"channelsLast"}function xa(n,e){return Fe(n,e)}function Pm(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ae(n,t)}function C8(n,e){return he(()=>{if(n.shape.length!==2)throw new oe(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Pm(n,1);return f2(t,[1,e,1])})}function N8(n){const e=[ol(n.shape)];return ae(n,e)}function k8(n){if(n.rank<=1)throw new oe(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],ol(n.shape,1)];return ae(n,e)}function bu(n,e,t){return he(()=>{switch(n.rank){case 1:return X0(n,e,t);case 2:return US(n,[e,0],[t,n.shape[1]]);case 3:return K0(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return ff(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return dt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return dt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new oe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function xw(n,e,t){return he(()=>{switch(n.rank){case 1:return X0(n,e,t);case 2:return US(n,[0,e],[n.shape[0],t]);case 3:return K0(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return ff(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new oe(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Cy(n,e,t,s){return he(()=>{switch(n.rank){case 1:return X0(n,e,t);case 2:switch(s){case 1:return bu(n,e,t);case 2:return xw(n,e,t);default:throw new oe(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return bu(n,e,t);case 2:return K0(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return xw(n,e,t);default:throw new oe(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return bu(n,e,t);case 2:return ff(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return ff(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return xw(n,e,t);default:throw new oe(`The axis is not within the rank of the tensor ${s}`)}default:throw new oe(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function hC(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),$n(n,e)}function bT(n,e){switch(n.rank){case 1:return A3([n,e]);case 2:return D3([n,e],0);case 3:return _3([n,e],0);case 4:return O3([n,e],0);default:throw new oe(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function f2(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new oe(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return bi(n,e)}function Tb(n,e=0,t=1,s,r){return OS(n,e,t,s,r)}function ba(n,e,t,s){if(n.rank<2||e.rank<2)throw new St(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new St(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return u2({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?m2(n.rank,s,Qi()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=ae(n,[-1,i]);const a=e.shape.slice(),o=a.pop(),u=a.pop(),c=[...a,o],d=Array.from({length:e.rank},(x,b)=>b===0?e.rank-2:b<=e.rank-2?b-1:b);e=ae(_t(e,d),[u,-1]);const p=[...r,...c];return ae(u2({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?m2(n.rank,s,Qi()):null,activation:t}),p)}}function CD(n,e,t){return he(()=>(Array.isArray(e)?e=Gn(e,"int32"):e=Fe(e,"int32"),Om(n,e,t)))}function Bm(n){return Q(n,n)}function m2(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new oe(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?ae(e,[1,s[0],1,1,1]):ae(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?ae(e,[1,1,1,1,s[0]]):ae(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?ae(e,[1,s[0],1,1]):ae(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?ae(e,[1,1,1,s[0]]):ae(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?ae(e,[1,s[0],1]):ae(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?ae(e,[1,1,s[0]]):ae(e,[1].concat(s))}else if(n<3)return e;throw new oe(`Unsupported input rank by biasAdd: ${e.rank}`)}function ta(n,e,t){return he(()=>(t==null&&(t=Qi()),Pn(t),$e(n,m2(n.rank,e,t))))}function $8(n,e=1){if(e!==1)throw new St(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Am(n)}function I8(n){return he(()=>Ve(n,$e(Qn(n),1)))}function ND(n,e,t,s){return he(()=>dA(n,e,t,s))}function T8(n){return he(()=>{const e=$e(.5,Q(.2,n));return hr(e,0,1)})}function Vm(n,e,t=!1){return t?n():e()}const E8=["fanIn","fanOut","fanAvg"],R8=["normal","uniform","truncatedNormal"];function A8(n){ju(E8,"FanMode",n)}function D8(n){ju(R8,"Distribution",n)}class Ti extends Td{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class kD extends Ti{apply(e,t){return zn(e,t)}}kD.className="Zeros";Ae(kD);class dC extends Ti{apply(e,t){return $r(e,t)}}dC.className="Ones";Ae(dC);class $D extends Ti{constructor(e){if(super(),typeof e!="object")throw new oe(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new oe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return he(()=>Q(Je(this.value),$r(e,t)))}getConfig(){return{value:this.value}}}$D.className="Constant";Ae($D);class ID extends Ti{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Uu(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ID.className="RandomUniform";Ae(ID);class TD extends Ti{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new St(`randomNormal does not support dType ${t}.`);return Tb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}TD.className="RandomNormal";Ae(TD);class ED extends Ti{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new St(`truncatedNormal does not support dType ${t}.`);return jS(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ED.className="TruncatedNormal";Ae(ED);class RD extends Ti{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return he(()=>{if(e.length!==2||e[0]!==e[1])throw new oe("Identity matrix initializer can only be used for 2D square matrices.");return Q(this.gain,IS(e[0]))})}getConfig(){return{gain:this.gain}}}RD.className="Identity";Ae(RD);function _8(n,e="channelsLast"){let t,s;if(Pn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=ol(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=ol(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=ol(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Er extends Ti{constructor(e){if(super(),e.scale<0)throw new oe(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,A8(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,D8(this.distribution),this.seed=e.seed}apply(e,t){const s=_8(e),r=s[0],i=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new St(`${this.getClassName()} does not support dType ${t}.`);return jS(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Uu(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Er.className="VarianceScaling";Ae(Er);class pC extends Er{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Er.className}}pC.className="GlorotUniform";Ae(pC);class fC extends Er{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Er.className}}fC.className="GlorotNormal";Ae(fC);class mC extends Er{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Er.className}}mC.className="HeNormal";Ae(mC);class gC extends Er{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Er.className}}gC.className="HeUniform";Ae(gC);class yC extends Er{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Er.className}}yC.className="LeCunNormal";Ae(yC);class xC extends Er{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Er.className}}xC.className="LeCunUniform";Ae(xC);class AD extends Ti{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return he(()=>{if(e.length<2)throw new St("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=ce(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const a=[Math.max(r,s),Math.min(r,s)],o=Tb(a,0,1,t,this.seed),u=wA.qr(o,!1);let c=u[0];const p=u[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return c=Q(c,p.sign()),s<r&&(c=c.transpose()),Q(Je(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}AD.className="Orthogonal";Ae(AD);const vT={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function wT(n,e={}){return Mm(n,xi.getMap().classNameMap,e,"initializer")}function kn(n){return uC(n)}function vn(n){if(typeof n=="string"){const e=n in vT?vT[n]:n;if(e==="GlorotNormal")return new fC;if(e==="GlorotUniform")return new pC;if(e==="HeNormal")return new mC;if(e==="HeUniform")return new gC;if(e==="LeCunNormal")return new yC;if(e==="LeCunUniform")return new xC;{const t={};return t.className=e,t.config={},wT(t)}}else return n instanceof Ti?n:wT(n)}function g2(n){return Array.isArray(n)&&Array.isArray(n[0])}function ox(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function pt(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new oe(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Vt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new oe(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function lx(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const ST="Variable";class O8{constructor(e,t="float32",s=ST,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=xD(),s=s??ST,this.originalName=vD(s),this.name=wD(this.originalName),this.trainable_=r,this.constraint=i,this.val=cA(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),F8(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function F8(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function y2(n){return n.map(e=>e.read())}function bC(n){n.forEach(e=>{e[0].write(e[1])})}class Jn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Sa{constructor(e,t,s,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=xD(),a!=null&&(this.originalName=vD(a),this.name=wD(this.originalName)),this.rank=t.length}}let z8=0;class Eb{constructor(e,t){this.callArgs=t,this.id=z8++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let L8=0;class Nt extends Td{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=L8++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=eo(s)+"_"+Ib(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new vi(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new oe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ar(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ar(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new pa(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new pa(`Layer ${this.name} is not connected, no input to return.`);return ar(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new pa(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new pa(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ar(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Yt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Yt(this.inputSpec);if(t.length!==s.length)throw new oe(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],a=s[r];if(a==null)continue;const o=i.rank;if(a.ndim!=null&&o!==a.ndim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&i.dtype!==a.dtype)throw new oe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${i.dtype}.`);if(a.axes){const u=i.shape;for(const c in a.axes){const d=Number(c),p=a.axes[c],m=d>=0?u[d]:u[u.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${u}.`)}}if(a.shape!=null)for(let u=0;u<a.shape.length;++u){const c=a.shape[u],d=i.shape[u];if(c!=null&&d!=null&&c!==d)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Yt(e),r=B8(e),i=V8(e);if(r===i)throw new oe("Arguments to apply() must be all SymbolicTensors or all Tensors");return xu(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of Yt(e))a.push(o.shape);this.build(ar(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const o=Yt(a),u=[];for(let c of o)s.indexOf(c)!==-1&&(c=c.clone()),u.push(c);if(a=ar(u),this.activityRegularizer!=null)throw new St("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=M8(e),o=this.computeOutputShape(a);let u;const c=P8(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?u=o.map((d,p)=>new Sa(c,d,this,Yt(e),t,this.name,p)):u=new Sa(c,o,this,Yt(e),t,this.name),this.addInboundNode(e,u,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new St("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new pa(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new pa(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new vi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return lx(this.weights)}build(e){this.built=!0}getWeights(e=!1){return y2(e?this.trainableWeights:this.weights)}setWeights(e){he(()=>{const t=this.weights;if(t.length!==e.length)throw new oe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=y2(t);for(let i=0;i<r.length;++i){const a=r[i],o=t[i],u=e[i];if(!xt(a.shape,u.shape))throw new oe(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);s.push([o,u])}bC(s)})}addWeight(e,t,s,r,i,a,o,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new oe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():vn("zeros"));const c=r.apply(t,s),d=new O8(c,s,e,a,o);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),a==null&&(a=!0),a?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Yt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=Yt(t),a=Yt(r);if(i.length!==a.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let o=0;o<i.length;o++)i[o].kerasMask=a[o]}addInboundNode(e,t,s,r,i,a,o=null){const u=Yt(e);t=Yt(t),s=Yt(s),r=Yt(r),i=ox(i),a=ox(a);const c=[],d=[],p=[];for(const m of u)c.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new Eb({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:p,inputTensors:u,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:a},o);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function M8(n){n=Yt(n);const e=[];for(const t of n)e.push(t.shape);return ar(e)}function P8(n){return"float32"}function DD(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const a=s.inputTensors[i],o=s.inboundLayers[i],u=s.nodeIndices[i],c=DD(a,o,u);for(const d of c)r.indexOf(d)===-1&&r.push(d)}return r}}}function B8(n){let e=!0;for(const t of Yt(n))if(!(t instanceof Sa)){e=!1;break}return e}function V8(n){let e=!0;for(const t of Yt(n))if(t instanceof Sa){e=!1;break}return e}class Um extends Nt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Ib("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new oe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new oe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new oe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new Sa(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Eb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new oe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Um.className="InputLayer";Ae(Um);function U8(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new oe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Um({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function W8(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Fe(e,n.dtype)}catch{throw new oe(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class tl{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof tl)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=W8(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new oe(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Sa){if(this.id2Value[e.id]==null)throw new oe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new oe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Sa){if(this.id2Value[e.id]==null)throw new oe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new oe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&rt(this.id2Mask)}}const ux=new mD,cx=new mD;function G8(n){ux?.setMaxEntries(n),cx?.setMaxEntries(n)}function Kp(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),a=i?n:[n],o=a.map(x=>x.name),u=[],c=e.names();for(const x of o)c.indexOf(x)!==-1?u.push(e.getValue(x)):u.push(null);const d=o.join(",")+"|"+e.names().sort().join(",");let p=ux.get(d),m;if(p==null){const x=H8(a,e);p=x.sorted,m=x.recipientCounts,ux.put(d,p),cx.put(d,m)}m={},r||Object.assign(m,cx.get(d));const g=new tl(e);for(let x=0;x<p.length;++x){const b=p[x],v=b.sourceLayer;if(v instanceof Um)continue;const w=[],N=[],I=[];let $=!1;for(const z of b.inputs){const M=g.getValue(z),O=g.getMask(z);w.push(M),N.push(O),O!=null&&($=!0),r||(m[z.name]--,m[z.name]===0&&!e.hasKey(z)&&o.indexOf(z.name)===-1&&!M.isDisposed&&z.sourceLayer.stateful!==!0&&I.push(M))}$&&(t=t||{},t.mask=N[0]);const E=Yt(v.apply(w,t));let D=null;v.supportsMasking&&(D=v.computeMask(w,N));const F=q8(b),L=Array.isArray(F)?F:[F];for(let z=0;z<L.length;++z){g.hasKey(L[z])||g.add(L[z],E[z],Array.isArray(D)?D[0]:D);const M=o.indexOf(L[z].name);M!==-1&&(u[M]=E[z])}r||rt(I)}return g.disposeMasks(),i?u:u[0]}function H8(n,e){B(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=CT(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:a,recipientMap:o}=CT(i,e);for(const u of a)r.has(u.name)||(t.push(u),r.add(u.name));for(const u in o)s[u]==null&&(s[u]=new Set),o[u].forEach(c=>s[u].add(c))}}return{sorted:t,recipientCounts:j8(s)}}function j8(n){const e={};for(const t in n)e[t]=n[t].size;return e}function CT(n,e){const t=new Set,s=[],r={};for(const o of e.names())t.add(o);const i=[],a=[];for(i.push(n);i.length>0;){const o=i[i.length-1];if(t.has(o.name)){i.pop();continue}const u=a[a.length-1]===i.length-1;if(o.inputs.length===0||u)i.pop(),s.push(o),t.add(o.name),u&&a.pop();else{a.push(i.length-1);for(const c of o.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(o.name),!t.has(c.name)&&i.push(c)}}return{sorted:s,recipientMap:r}}function q8(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const X8=fe();X8.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,G8);function vC(n,e){return he(()=>ks(Ke(Q(n,n),e,!0)))}class Wm extends Td{getConfig(){return{}}}class _D extends Wm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return he(()=>{const t=vC(e,this.axis),s=hr(t,0,this.maxValue);return Q(e,Ve(s,$e(Zn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}_D.className="MaxNorm";Ae(_D);class OD extends Wm{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return he(()=>Ve(e,$e(Zn(),vC(e,this.axis))))}getConfig(){return{axis:this.axis}}}OD.className="UnitNorm";Ae(OD);class FD extends Wm{apply(e){return Ia(e)}}FD.className="NonNeg";Ae(FD);class zD extends Wm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return he(()=>{const t=vC(e,this.axis),s=$e(Q(this.rate,hr(t,this.minValue,this.maxValue)),Q(1-this.rate,t));return Q(e,Ve(s,$e(Zn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}zD.className="MinMaxNorm";Ae(zD);const NT={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ts(n){return uC(n)}function kT(n,e={}){return Mm(n,xi.getMap().classNameMap,e,"constraint")}function ns(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in NT?NT[n]:n,config:{}};return kT(t)}else return n instanceof Wm?n:kT(n)}async function iu(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const a=i;e.push(a.data()),t.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];rt(s)}}function LD(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var $T;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})($T||($T={}));const K8=125;class gf{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Y8{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Q8 extends gf{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const o=he(()=>$e(this.totals[r],Q(i,s)));this.totals[r]=o,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:he(()=>{const r=Q(Ve(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),ms(t[s])}))}}class Z8 extends gf{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const a=this.history[i];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const u=a[o];e.push(u.data()),t.push(i),s.push(o)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class J8 extends gf{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||WA,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=K8),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");qw(this.yieldEvery)&&(this.maybeWait=d8(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await iu(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await iu(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await iu(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await iu(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await iu(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):qw(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await iu(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await iu(e),await this.trainEnd(e))}}function MD(n,e){return n==null&&(n={}),n instanceof gf?[n]:Array.isArray(n)&&n[0]instanceof gf?n:Yt(n).map(s=>new J8(s,e))}class gi{constructor(){}static registerCallbackConstructor(e,t){B(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),gi.checkForDuplicate(t),gi.constructors[e]==null&&(gi.constructors[e]=[]),gi.constructors[e].push(t)}static checkForDuplicate(e){for(const t in gi.constructors)gi.constructors[+t].forEach(r=>{if(r===e)throw new oe("Duplicate callback constructor.")})}static clear(){gi.constructors={}}static createCallbacks(e){const t=[];for(const s in gi.constructors){const r=+s;e>=r&&t.push(...gi.constructors[r])}return t.map(s=>new s)}}gi.constructors={};function PD(n,e,t,s,r,i,a,o,u){const c=new Z8,d=[new Q8,...gi.createCallbacks(e)];n!=null&&d.push(...n),d.push(c);const p=new Y8(d);return p.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:u}),{callbackList:p,history:c}}function ao(n,e={},t=!1){return Mm(n,xi.getMap().classNameMap,e,"layer",t)}function hx(n,e){return he(()=>{n.dtype!=="float32"&&(n=Fe(n,"float32"));const t=Ke(Bm(n),e,!0),s=Nd(t.shape,Zn()),r=ks(po(t,s));return Ve(n,r)})}function Rb(n,e){return he(()=>Tn(Bm(Ue(e,n)),-1))}function wC(n,e){return he(()=>Tn(Qn(Ue(e,n)),-1))}function SC(n,e){return he(()=>{const t=Ue(n,e),s=hr(Qn(n),Zn(),Number.MAX_VALUE),r=Qn(Ve(t,s));return Q(100,Tn(r,-1))})}function eX(n,e){return he(()=>{const t=hr(e,Zn(),Number.MAX_VALUE),s=Xr($e(1,t)),r=hr(n,Zn(),Number.MAX_VALUE),i=Xr($e(1,r));return Tn(Bm(Ue(s,i)),-1)})}function tX(n,e){return he(()=>{const t=po(0,Ue(1,Q(n,e)));return Tn(Bm(t),-1)})}function nX(n,e){return he(()=>{const t=po(0,Ue(1,Q(n,e)));return Tn(t,-1)})}function sX(n,e){return he(()=>{const t=Ke(Q(n,e),-1),s=Ci(Q(Ue(1,n),e),-1);return po(0,$e(1,Ue(s,t)))})}function rX(n,e){return he(()=>{const t=Math.log(2),s=Ue(e,n),r=Ue($e(s,kd(Q(-2,s))),t);return Tn(r,-1)})}function yf(n,e,t=!1){return he(()=>{if(t)e=Y0(e);else{const s=Ke(e,e.shape.length-1,!0);e=Ve(e,s)}return e=hr(e,Zn(),1-Zn()),gn(Ke(Q(Fe(n,"float32"),Xr(e)),e.shape.length-1))})}function dx(n,e,t=!1){return he(()=>{const s=Fe(_m(N8(n)),"int32");e=hr(e,Zn(),1-Zn());const r=e.shape,i=ae(DS(s,r[r.length-1]),r);return yf(i,e,t)})}function iX(n,e){if(!xt(n.shape,e.shape))throw new oe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return he(()=>{const t=Ia(e),s=gn(Qn(e));return $e(Ue(t,Q(e,n)),B0(Ks(s)))})}function Ab(n,e){return he(()=>{let t;return t=hr(e,Zn(),1-Zn()),t=Xr(Ve(t,Ue(1,t))),Tn(iX(n,t),-1)})}function aX(n,e){return he(()=>{const t=hr(n,Zn(),1),s=hr(e,Zn(),1);return Ke(Q(n,Xr(Ve(t,s))),-1)})}function oX(n,e){return he(()=>{const t=Xr($e(Zn(),e));return Tn(Ue(e,Q(n,t)),-1)})}function BD(n,e){return he(()=>{const t=hx(n,-1),s=hx(e,-1),r=Q(t,s);return gn(Ke(r,-1))})}const px={meanSquaredError:Rb,meanAbsoluteError:wC,meanAbsolutePercentageError:SC,meanSquaredLogarithmicError:eX,squaredHinge:tX,hinge:nX,categoricalHinge:sX,logcosh:rX,categoricalCrossentropy:yf,sparseCategoricalCrossentropy:dx,binaryCrossentropy:Ab,kullbackLeiblerDivergence:aX,poisson:oX,cosineProximity:BD};function bw(n){if(typeof n=="string"){if(n in px)return px[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new oe(e)}else return n}function VD(n,e){return he(()=>{const t=Q(.5,Kr(e)),s=xa(_r(e,t),n.dtype);return Tn(ji(n,s),-1)})}function UD(n,e){return he(()=>xa(ji(Tu(n,-1),Tu(e,-1)),"float32"))}function lX(n,e){return he(()=>Fe(Ke(wa(ji(n,1),ji(e,1))),"float32"))}function uX(n,e){return he(()=>Fe(Ke(wa(ji(n,0),ji(e,1))),"float32"))}function cX(n,e){return he(()=>{const t=lX(n,e),s=uX(n,e),r=$e(t,s);return Fe(Fs(_r(r,0),Ve(t,r),0),"float32")})}function hX(n,e){return Ab(n,e)}function dX(n,e){return n.rank===e.rank&&(n=Wt(n,[n.rank-1])),e=Tu(e,-1),e.dtype!==n.dtype&&(e=Fe(e,n.dtype)),Fe(ji(n,e),"float32")}const pX=Rb,fX=Rb,mX=wC,gX=wC,yX=SC,xX=SC,WD=yf,bX=BD,GD=dx,fx={binaryAccuracy:VD,categoricalAccuracy:UD,precision:cX,categoricalCrossentropy:WD,sparseCategoricalCrossentropy:GD,mse:pX,MSE:fX,mae:mX,MAE:gX,mape:yX,MAPE:xX,cosine:bX};function vX(n){if(typeof n=="string"&&n in fx)return fx[n];if(typeof n!="string"&&n!=null)return n;throw new oe(`Unknown metric ${n}`)}function Ny(n){if(fa(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(px))if(px[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(fx))if(fx[t]===n){e=t;break}return e!==void 0?e:n.name}}function wX(n){const e={Adagrad:()=>jc.adagrad(.01),Adadelta:()=>jc.adadelta(1,.95,Zn()),Adam:()=>jc.adam(.001,.9,.999,Zn()),Adamax:()=>jc.adamax(.002,.9,.999,Zn(),0),RMSProp:()=>jc.rmsprop(.001,.9,0,Zn()),SGD:()=>jc.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new oe(`Unknown Optimizer ${n}`)}const IT=1*1024*1024;function TT(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!x2(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>IT&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${IT}.`)}}function x2(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!x2(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!x2(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function SX(n,e,t,s=console.log){const r=NX(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let a;if(!r){i.push("Receives inputs"),a=[];for(const d in n.nodesByDepth)a.push(...n.nodesByDepth[d])}s("_".repeat(e)),mx(i,t,s),s("=".repeat(e));const o=n.layers;for(let d=0;d<o.length;++d)r?kX(o[d],t,s):$X(o[d],t,a,s),s((d===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const u=CX(n),c=lx(n.nonTrainableWeights);s(`Total params: ${u+c}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function CX(n){let e;return n.collectedTrainableWeights!=null?e=lx(n.collectedTrainableWeights):e=lx(n.trainableWeights),e}function NX(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function mx(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function kX(n,e,t){let s,r;try{r=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,a=n.getClassName(),o=[`${i} (${a})`,r,s,n.countParams().toString()];mx(o,e,t)}function $X(n,e,t,s){let r,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=[];for(const p of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const g=p.inboundLayers[m].name,x=p.nodeIndices[m],b=p.tensorIndices[m];a.push(`${g}[${x}][${b}]`)}const o=n.name,u=n.getClassName(),c=a.length===0?"":a[0],d=[`${o} (${u})`,i,r,n.countParams().toString(),c];mx(d,e,s);for(let p=1;p<a.length;++p)mx(["","","","",a[p]],e,s)}function HD(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function b2(n,e){if(n===null)return null;if(typeof n=="string")return cu(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];HD(e,r,i)?t.push(i):t.push(b2(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=cu(s);t[i]=b2(r,i)}}return t}}function v2(n,e){if(n==null)return null;if(typeof n=="string")return eo(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];HD(e,r,i)?t.push(i):t.push(v2(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=eo(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=v2(r,s)}return t}}const jD="4.22.0";const IX=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Bi extends Nt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const N=this.getClassName().toLowerCase();this.name=Ib(N)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],al(this.inputs).length!==this.inputs.length)throw new oe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(N=>N.name)}`);al(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(N=>N.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const N of this.outputs){const I=N.sourceLayer,$=N.nodeIndex,E=N.tensorIndex;this.outputLayers.push(I),this.outputLayersNodeIndices.push($),this.outputLayersTensorIndices.push(E)}for(const N of this.inputs){const I=N.sourceLayer,$=N.nodeIndex,E=N.tensorIndex;fa($===0,"input layer has >1 nodes"),fa(E===0,"input layer has >1 tensors"),this.inputLayers.push(I),this.inputLayersNodeIndices.push($),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let N=0;N<this.inputLayers.length;N++){const I=this.inputLayers[N];if(!(I instanceof Um))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${N} (0-based) originates from layer type ${I.getClassName()}.`);this.inputNames.push(I.name),this.feedInputShapes.push(I.batchInputShape),this.feedInputNames.push(I.name)}for(const N of this.outputLayers)this.outputNames.push(N.name);this.internalInputShapes=this.inputs.map(N=>N.shape),this.internalOutputShapes=this.outputs.map(N=>N.shape);const t={},s={},r={},i={},a={},o=[],u=(N,I,$,E,D,F)=>{(E==null||D==null||F==null)&&(E=N.sourceLayer,D=N.nodeIndex,F=N.tensorIndex);const L=E.inboundNodes[D];if($.indexOf(L)!==-1)throw new vi(`The tensor ${N.name} at layer "${E.name}" is part of a cycle.`);if(I.indexOf(L)!==-1)return;this.containerNodes.add(Bi.nodeKey(E,D)),E.id in a||(a[E.id]=Object.keys(a).length),$.indexOf(L)===-1&&$.push(L);const z=L.inboundLayers.length;for(let M=0;M<z;M++){const O=L.inputTensors[M],H=L.inboundLayers[M],X=L.nodeIndices[M],te=L.tensorIndices[M];u(O,I,$,H,X,te)}for(I.push(L);$.indexOf(L)>=0;)$.splice($.indexOf(L),1);o.push(L)},c=[],d=[];for(const N of this.outputs)u(N,c,d);const p=o.slice().reverse();for(const N of p){s[N.id]=N,N.id in t||(t[N.id]=0);let I=t[N.id];const $=r[N.outboundLayer.id]==null?0:r[N.outboundLayer.id];I=Math.max(I,$),r[N.outboundLayer.id]=I,i[N.outboundLayer.id]=N.outboundLayer,t[N.id]=I;for(let E=0;E<N.inboundLayers.length;E++){const D=N.inboundLayers[E],F=N.nodeIndices[E],L=D.inboundNodes[F],z=t[L.id]==null?0:t[L.id];t[L.id]=Math.max(I+1,z),s[L.id]=L}}const m={};for(const N in t){const I=t[N];I in m||(m[I]=[]),m[I].push(s[N])}const g={};for(const N in r){const I=r[N];I in g||(g[I]=[]),g[I].push(i[N])}let x=Object.keys(g).map(N=>parseInt(N,10)).sort(wy);this.layers=[];for(const N of x){const I=g[N];I.sort(($,E)=>{const D=a[$.id],F=a[E.id];return D<F?-1:D>F?1:0});for(const $ of I)$ instanceof Bi&&this.internalContainerRefs.push($),this.layers.push($)}this.layersByDepth=g,x=Object.keys(m).map(N=>parseInt(N,10)).sort(wy);const b=this.inputs.slice(),v=[];for(const N of x)for(const I of m[N]){const $=I.outboundLayer;if($!=null){for(const E of I.inputTensors)if(b.indexOf(E)===-1)throw new vi(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${$.name}". The following previous layers were accessed without issue: ${v}`);for(const E of I.outputTensors)b.push(E);v.push($.name)}}this.nodesByDepth=m;const w=this.layers.map(N=>N.name);for(const N of w){const I=w.filter($=>$===N).length;if(I!==1)throw new vi(`The name "${N}" is used ${I} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(w))}this.outboundNodes=[],this.inboundNodes=[],new Eb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(N=>null),outputMasks:this.outputs.map(N=>null),inputShapes:this.inputs.map(N=>N.shape),outputShapes:this.outputs.map(N=>N.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new oe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=IX(e);i&&this.parseWeights(e);for(const o of this.layers)for(const[u,c]of o.weights.entries()){const d=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${u}`:c.originalName;if(s[d]!=null)throw new oe(`Duplicate weight name: ${d}`);s[d]=c,r++}const a=[];for(const o in e){let u=o;if(s[o]==null){const c=o.split("/");u=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[u]!=null)a.push([s[u],e[o]]);else if(t)throw new oe(`Provided weight data has no target variable: ${o}`);delete s[u]}if(t){const o=[];for(const u in s)o.push(u);if(o.length>0)throw new oe(`${o.length} of ${r} weights are not set: ${o}`)}bC(a)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!r.includes(a)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${jD}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=v2(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return he(()=>{e=Yt(e);const s=new tl;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Kp(this.outputs,s,t)})}computeMask(e,t){return he(()=>{e=Yt(e);let s;return t==null?s=Du(null,e.length):s=Yt(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=ox(e);if(t.length!==this.inputLayers.length)throw new oe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const u=this.inputLayers[o],c=t[o],d=u.name+"_0_0";s[d]=c}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(wy);if(r.length>1)for(const o of r){const u=this.nodesByDepth[o];for(const c of u){const d=c.outboundLayer;if(this.inputLayers.map(b=>b.id).indexOf(d.id)!==-1)continue;const p=[];for(let b=0;b<c.inboundLayers.length;b++){const v=c.inboundLayers[b],w=c.nodeIndices[b],N=c.tensorIndices[b],I=`${v.name}_${w}_${N}`,$=s[I];p.push($)}const m=d.computeOutputShape(ar(p)),g=ox(m),x=d.inboundNodes.indexOf(c);for(let b=0;b<g.length;b++){const v=`${d.name}_${x}_${b}`;s[v]=g[b]}}}const i=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const u=this.outputLayers[o],c=this.outputLayersNodeIndices[o],d=this.outputLayersTensorIndices[o],p=`${u.name}_${c}_${d}`;a.push(p)}for(let o=0;o<a.length;o++){const u=a[o];fa(u in s),i.push(s[u])}return ar(i)}runInternalGraph(e,t){t==null&&(t=Du(null,e.length));const s={};for(let u=0;u<this.inputs.length;++u){const c=this.inputs[u],d=e[u],p=t[u];s[c.id]=[d,p]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(wy);for(const u of r){const c=this.nodesByDepth[u];for(const d of c){const p=d.outboundLayer,m=d.inputTensors,g=d.outputTensors,x=new Array;for(const b of m)b.id in s&&x.push(s[b.id]);if(x.length===m.length){let b={},v,w,N,I;if(d.callArgs!=null&&(b=d.callArgs),x.length===1){const[$,E]=x[0];b.mask==null&&(b.mask=E),N=Yt(p.call($,b)),I=Yt(p.computeMask($,E)),v=[$],w=[E]}else v=x.map($=>$[0]),w=x.map($=>$[1]),b.mask==null&&(b.mask=w),N=Yt(p.call(v,b)),I=Yt(p.computeMask(v,w));if(p.activityRegularizer)throw new St("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let $=0;$<g.length;++$){const E=g[$],D=N[$],F=I[$];s[E.id]=[D,F]}}}}const i=[],a=[],o=[];for(const u of this.outputs){fa(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[c,d]=s[u.id];o.push(c.shape),i.push(c),a.push(d)}return[i,a,o]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof Bi?1:0;for(let i=0;i<r.inboundNodes.length;i++){const a=Bi.nodeKey(r,i);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new oe("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new oe(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new oe(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return he(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=Bi.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const o=a.getClassName(),u=a.getConfig(),c=[];for(let p=0;p<a.inboundNodes.length;p++){const m=a.inboundNodes[p],g=Bi.nodeKey(a,p);let x={};if(this.containerNodes.has(g)){if(m.callArgs)try{JSON.stringify(m.callArgs),x=m.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),x={}}if(m.inboundLayers.length>0){const b=[];for(let v=0;v<m.inboundLayers.length;v++){const w=m.inboundLayers[v],N=m.nodeIndices[v],I=m.tensorIndices[v],$=Bi.nodeKey(w,N);let E=t[$];E==null&&(E=0),b.push([w.name,E,I,x])}c.push(b)}}}const d={};d.name=a.name,d.className=o,d.config=u,d.inboundNodes=c,s.push(d)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],u=this.inputLayersNodeIndices[a],c=Bi.nodeKey(o,u);if(!this.containerNodes.has(c))continue;let d=t[c];d==null&&(d=0);const p=this.inputLayersTensorIndices[a];r.push([o.name,d,p])}e.inputLayers=r;const i=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=Bi.nodeKey(o,u);if(!this.containerNodes.has(c))continue;let d=t[c];d==null&&(d=0);const p=this.outputLayersTensorIndices[a];i.push([o.name,d,p])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},a={};function o(v,w){v.name in a?a[v.name].push(w):a[v.name]=[w]}function u(v,w){const N=[];let I;for(const $ of w){const E=$[0],D=$[1],F=$[2];if(I=$[3]==null?{}:$[3],!(E in i)){o(v,w);return}const L=i[E];if(L.inboundNodes.length<=D){o(v,w);return}const z=L.inboundNodes[D];N.push(z.outputTensors[F])}N.length>0&&v.apply(ar(N),I)}function c(v){const w=v.name,N=ao(v,t.customObjects!=null?t.customObjects:{});N.setFastWeightInitDuringBuild(r),i[w]=N,v.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new oe(`Corrupted configuration, expected array for nodeData: ${$}`);o(N,$)})}const d=t.name,p=t.layers;for(const v of p)c(v);for(;!h8(a);)for(const v of p){const w=i[v.name];if(w.name in a){const N=a[w.name];delete a[w.name];for(const I of N)u(w,I)}}const m=[],g=[],x=t.inputLayers;for(const v of x){const w=v[0],N=v[1],I=v[2];fa(w in i);const E=i[w].inboundNodes[N].outputTensors;m.push(E[I])}const b=t.outputLayers;for(const v of b){const w=v[0],N=v[1],I=v[2];fa(w in i);const E=i[w].inboundNodes[N].outputTensors;g.push(E[I])}return new e({inputs:m,outputs:g,name:d})}get stateful(){if(this._stateful)throw new oe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){he(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function TX(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function qD(n,e){return TX(n,e,"classWeight")}async function XD(n,e,t,s){if(t!=null){const r=he(()=>{if(n.shape.length===1)return io(n);if(n.shape.length===2){if(n.shape[1]>1)return Tu(n,1);if(n.shape[1]===1)return ae(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());rt(r);const a=[];return i.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),Gn(a,"float32")}else return null}function EX(n,e){return Q(n,e)}const RX=32;function KD(n,e){let t,s;const r=e;t=r.xs,s=r.ys,B(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=ET("input",n.inputNames,t),a=ET("output",n.outputNames,s),o=i[0].shape[0];B(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),B(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<i.length;u++)B(i[u].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let u=0;u<a.length;u++)B(a[u].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:i,ys:a}}function ET(n,e,t){if(t instanceof Kt)return[t];if(Array.isArray(t))return B(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new oe(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function AX(n){if(n.length===3)throw new St("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function DX(n,e,t){const s=t.batchesPerEpoch!=null;if(B(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),B(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),B(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),B(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),B(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,a;if(r)if(RT(t.validationData))B(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const v=AX(t.validationData);i=v.xs,a=v.ys}const o=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let c;r?c=u.slice().concat(u.map(v=>"val_"+v)):c=u.slice();const d=MD(t.callbacks,t.yieldEvery),p=t.verbose==null?1:t.verbose,{callbackList:m,history:g}=PD(d,p,t.epochs,null,null,_X(e,t),null,r,c);m.setModel(n),n.history=g,await m.onTrainBegin(),n.stopTraining_=!1;let x=t.initialEpoch==null?0:t.initialEpoch,b=await e.iterator();for(;x<t.epochs;){const v={};await m.onEpochBegin(x);let w=0,N=0;for(s||(b=await e.iterator());!s||w<t.batchesPerEpoch;){const I=await b.next();if(s&&I.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${w} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(I.value!=null){const{xs:$,ys:E}=KD(n,I.value),D={};D.batch=N,D.size=$[0].shape[0],await m.onBatchBegin(N,D);const F=[];if(t.classWeight!=null){const M=qD(t.classWeight,n.outputNames);for(let O=0;O<M.length;++O)F.push(await XD(E[O],null,M[O]))}const L=$.concat(E).concat(F),z=o(L);rt(L);for(let M=0;M<u.length;++M){const O=u[M],H=z[M];D[O]=H,ms(H)}await m.onBatchEnd(N,D),LD(D),N++,w++}if(s?w>=t.batchesPerEpoch:I.done){if(r){let $;RT(t.validationData)?$=Yt(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):$=Yt(n.evaluate(i,a,{batchSize:t.validationBatchSize==null?RX:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)v[`val_${n.metricsNames[E]}`]=$[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(x,v),x++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function _X(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function RT(n){return typeof n.iterator=="function"}function OX(n){return typeof n.next=="function"}async function FX(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new St("Verbose mode is not implemented yet.");B(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=OX(e)?e:await e.iterator();let o=0,u=0;for(;!s||u<t.batches;){const c=await a.next();if(i=he(()=>{if(c.value){const{xs:d,ys:p}=KD(n,c.value),m=d.concat(p),g=he(()=>r(m));if(rt(m),u===0)for(let b=0;b<g.length;++b)i.push(Je(0));const x=m[0].shape[0];for(let b=0;b<g.length;++b){const v=g[b],w=i[b];i[b]=he(()=>$e(i[b],Q(x,v))),u>0&&rt(w)}rt(g),o+=x,++u}return i}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const d=i[c];i[c]=Ve(i[c],o),rt(d)}return ar(i)}function vw(n){B(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Wp(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>bu(s,e,t-e)):bu(n,e,t-e)}function w2(n,e){return he(()=>n==null?null:Array.isArray(n)?n.map(t=>w2(t,e)):CD(n,e.dtype==="int32"?e:Fe(e,"int32")))}function ww(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function YD(n){const e=[];n instanceof Kt&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Pm(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Pi(n,e){if(n==null)return;const t=[];if(e instanceof Kt)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof Kt)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function zX(n){return n instanceof Kt}function S2(n){return Array.isArray(n)}function AT(n){return!zX(n)&&!S2(n)}function DT(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(S2(n)&&n.length>0)a=!0;else if(AT(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new oe(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let i;if(AT(n)){n=n,i=[];for(const a of e){if(n[a]==null)throw new oe(`No data provided for "${a}". Need data for each key in: ${e}`);i.push(n[a])}}else if(S2(n)){if(n=n,n.length!==e.length)throw new oe(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new oe(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=YD(i),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new oe(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<t[a].length;++u){if(u===0&&!s)continue;const c=o.shape[u],d=t[a][u];if(d!=null&&d>=0&&c!==d)throw new oe(`${r} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return i}function LX(n,e,t){const s=al(n.map(i=>i.shape[0]));s.sort();const r=al(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new oe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new oe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!xt(s,r))throw new oe(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function MX(n,e,t){const s=[Rb,Ab,yf];for(let r=0;r<n.length;++r){const i=n[r],a=e[r],o=t[r];if(a!=null){if(a===yf&&i.shape[i.shape.length-1]===1)throw new oe(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const u=i.shape.slice(1),c=o.slice(1);for(let d=0;d<u.length;++d){const p=u[d],m=c[d];if(m!=null&&p!==m)throw new oe(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function _T(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new oe(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new oe(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new oe(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<t[a].length;++u){if(u===0&&!s)continue;const c=o.shape[u],d=t[a][u];if(d!=null&&d!==c)throw new oe(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function PX(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const BX="layers-model";class lh extends Bi{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new oe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");SX(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=wX(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof $l))throw new oe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new oe(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(bw(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new oe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>bw(o))}else{const a=bw(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],xu("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=PX(e.metrics,this.outputNames),i=(a,o,u)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([u,a])};xu("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=r[a];(c=>{let p,m,g;for(const x of c){if(typeof x=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(x)!==-1){const v=this.internalOutputShapes[a];v[v.length-1]===1||this.lossFunctions[a]===Ab?["accuracy","acc"].indexOf(x)!==-1?m=VD:["crossentropy","ce"].indexOf(x)!==-1&&(m=hX):this.lossFunctions[a]===dx?["accuracy","acc"].indexOf(x)!==-1?m=dX:["crossentropy","ce"].indexOf(x)!==-1&&(m=GD):["accuracy","acc"].indexOf(x)!==-1?m=UD:["crossentropy","ce"].indexOf(x)!==-1&&(m=WD);let w;["accuracy","acc"].indexOf(x)!==-1?w="acc":["crossentropy","ce"].indexOf(x)!==-1&&(w="ce"),g=m,p=""+w}else g=vX(x),p=""+Ny(x);let b;xu(p,()=>{b=g}),i(a,p,b)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;vw(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const o=a[0].concat(a[1]);this.makeTestFunction();const u=this.testFunction,c=this.testLoop(u,o,r,s.verbose,s.steps);return ar(c)}finally{Pi(a[0],e),Pi(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),FX(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new oe(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new oe(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new oe("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),a=new tl;if(e instanceof Kt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new oe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(c==null)throw new oe(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const o=Kp(i,a);return s?o:o[0]}retrieveSymbolicTensors(e){const t=Du(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],a=i.map(o=>o.name);for(let o=0;o<e.length;++o){const u=a.indexOf(e[o]);if(u!==-1&&(t[o]=i[u],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,a)=>{i==null&&r.push(e[a])}),new oe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return he(()=>{const r=this.checkNumSamples(e);if(s)throw new St("Verbose predictLoop() is not implemented yet.");const i=ww(r,t),a=this.outputs.map(o=>[]);for(let o=0;o<i.length;++o)he(()=>{const c=i[o][0],d=i[o][1],p=Wp(e,c,d),m=[];if(Array.isArray(p))for(let x=0;x<p.length;++x)m.push({key:this.inputs[x],value:p[x]});else m.push({key:this.inputs[0],value:p});const g=new tl(m);return Kp(this.outputs,g)}).forEach((c,d)=>a[d].push(c));return ar(a.map(o=>$n(o,0)))})}predict(e,t={}){const s=YD(e);_T(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return vw(r),this.predictLoop(s,r)}finally{Pi(s,e)}}predictOnBatch(e){_T(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new vi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===dx?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(e=DT(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=DT(t,this.feedOutputNames,i,!1,"target"),LX(e,t),MX(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new oe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,a){const[o,u]=this.standardizeUserDataXY(e,t,i,a);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const d=qD(r,this.outputNames);c=[];for(let p=0;p<d.length;++p)c.push(await XD(u[p],null,d[p]))}return[o,u,c]}testLoop(e,t,s,r=0,i){return he(()=>{const a=this.checkNumSamples(t,s,i,"steps"),o=[];if(r>0)throw new St("Verbose mode is not implemented yet.");if(i!=null)throw new St("steps mode in testLoop() is not implemented yet");{const u=ww(a,s),c=Gn(Yi(0,a));for(let d=0;d<u.length;++d){const p=u[d][0],m=u[d][1],g=bu(c,p,m-p),x=w2(t,g),b=e(x);if(d===0)for(let v=0;v<b.length;++v)o.push(Je(0));for(let v=0;v<b.length;++v){const w=b[v];o[v]=$e(o[v],Q(m-p,w))}}for(let d=0;d<o.length;++d)o[d]=Ve(o[d],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(yT(e,r)>1){const a=yT(e.slice(0,s),r);i+=`_${a}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const p=[];for(let b=0;b<this.inputs.length;++b)p.push({key:this.inputs[b],value:s[b]});const m=new tl(p),g=Kp(this.outputs,m,{training:!0});let x;for(let b=0;b<this.lossFunctions.length;++b){const v=this.lossFunctions[b];let w=v(r[b],g[b]);i[b]!=null&&(w=EX(w,i[b]));const N=Tn(w);t.push(N),b===0?x=w:x=$e(x,w)}for(let b=0;b<this.metricsTensors.length;++b){let v;if(this.outputs.length>1&&b<this.outputs.length)v=t[b];else{const w=this.metricsTensors[b][0],N=this.metricsTensors[b][1];v=Tn(w(r[N],g[N]))}ms(v),a.push(v)}return x=Tn(x),this.calculateLosses().forEach(b=>{x=$e(x,b)}),x},u=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(o,!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>he(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:r[c]});const o=new tl(a),u=Kp(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const d=this.lossFunctions[c],p=Tn(d(i[c],u[c]));c===0?s=p:s=$e(s,p),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const d=this.metricsTensors[c][0],p=this.metricsTensors[c][1],m=Tn(d(i[p],u[p]));t.push(m)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,a,o,u,c,d,p,m;try{const g=s.batchSize==null?32:s.batchSize;vw(g);const b=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,g);r=b[0],i=b[1],m=b[2];let v=!1,w;if(s.validationData!=null&&s.validationData.length>0){if(v=!0,s.validationData.length===2)u=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new St("validationData including sample weights is not supported yet."):new oe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const M=await this.standardizeUserData(u,c,null,null,!0,g);d=M[0],p=M[1],w=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){v=!0;const z=Math.floor(r[0].shape[0]*(1-s.validationSplit)),M=r[0].shape[0];d=Wp(r,z,M),a=r,r=Wp(r,0,z),p=Wp(i,z,M),o=i,i=Wp(i,0,z),w=d.concat(p)}else s.validationSteps!=null&&(v=!0);const N=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const I=this.makeTrainFunction(),$=this.getDedupedMetricsNames();let E,D;v?(this.makeTestFunction(),E=this.testFunction,D=$.slice().concat($.map(z=>"val_"+z))):(E=null,w=[],D=$.slice());const F=MD(s.callbacks,s.yieldEvery);return await this.fitLoop(I,N,$,g,s.epochs,s.verbose,F,E,w,s.shuffle,D,s.initialEpoch,null,null)}finally{this.isTraining=!1,Pi(r,e),Pi(i,t),Pi(a,e),Pi(o,t),Pi(d,u),Pi(p,c),m!=null&&rt(m)}}async fitLoop(e,t,s,r,i,a,o,u,c,d,p,m,g,x){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),m==null&&(m=0);let b=!1;if(u!=null&&c!=null&&(b=!0),x!=null&&(b=!0,g==null))throw new oe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const v=this.checkNumSamples(t,r,g,"steps_per_epoch");let w;v!=null&&(w=Yi(0,v)),a==null&&(a=1);const{callbackList:N,history:I}=PD(o,a,i,m,v,g,r,b,p);N.setModel(this),this.history=I,await N.onTrainBegin(),this.stopTraining_=!1;for(let $=m;$<i;++$){await N.onEpochBegin($);const E={};if(g!=null)throw new St("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new St("batch shuffling is not implemneted yet");d&&_B(w);const D=Gn(w),F=ww(v,r);for(let L=0;L<F.length;++L){const z={};if(await N.onBatchBegin(L,z),he(()=>{const M=F[L][0],O=F[L][1],H=bu(D,M,O-M);z.batch=L,z.size=O-M;const X=w2(t,H),te=e(X);for(let Z=0;Z<s.length;++Z){const W=s[Z],ee=te[Z];z[W]=ee,ms(ee)}if(L===F.length-1&&b){const Z=this.testLoop(u,c,r);for(let W=0;W<s.length;++W){const ee=s[W],ie=Z[W];ms(ie),E["val_"+ee]=ie}}}),await N.onBatchEnd(L,z),LD(z),this.stopTraining_)break}D.dispose()}if(await N.onEpochEnd($,E),this.stopTraining_)break}return await N.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return DX(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],o=this.makeTrainFunction()(r.concat(i)),u=[];for(const c of o){const d=await c.data();u.push(d[0])}return rt(o),Pi(s[0],e),Pi(s[1],t),ar(u)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||t.push({name:r[a].originalName,tensor:i[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=HI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-HI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=eo(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>eo(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=eo(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[eo(Ny(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>eo(Ny(e)));{const e={};for(const t in this.metrics)e[t]=eo(Ny(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=b2(e.optimizer_config),s=ao(t);let r;if(typeof e.loss=="string")r=cu(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>cu(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=cu(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>cu(a));else if(e.metrics!=null){i={};for(const a in e.metrics)i[a]=cu(e.metrics[a])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=l3(e);if(c.length===0)throw new oe(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new oe(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new oe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await n2(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:BX,generatedBy:`TensorFlow.js tfjs-layers v${jD}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:d,specs:p}=await n2(await this.optimizer.getWeights(),c);s.specs.push(...p),s.data=i3([s.data,d])}return this.userDefinedMetadata!=null&&(TT(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){TT(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}lh.className="Model";Ae(lh);class QD extends lh{}QD.className="Functional";Ae(QD);class xf extends lh{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Ib("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new oe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof xf||e instanceof lh;let s;if(t){if(s=e,s.outputs.length!==1)throw new oe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new oe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new oe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=U8({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new oe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new oe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=DD(this.outputs[0])}this.inboundNodes=[],new Eb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Du(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Vt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new lh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new oe("Legacy serialization format not supported yet.");i=t}else B(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof xf))throw new St(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const u of i){const d=ao(u,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(e){if(this.model==null)throw new oe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new oe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}xf.className="Sequential";Ae(xf);let Ls=class extends Td{getConfig(){return{}}};class ZD extends Ls{apply(e,t=1){return $8(e,t)}}ZD.className="elu";Ae(ZD);class JD extends Ls{apply(e){return MS(e)}}JD.className="selu";Ae(JD);class e_ extends Ls{apply(e){return Ia(e)}}e_.className="relu";Ae(e_);class t_ extends Ls{apply(e){return he(()=>pl(6,Ia(e)))}}t_.className="relu6";Ae(t_);class n_ extends Ls{apply(e){return e}}n_.className="linear";Ae(n_);class s_ extends Ls{apply(e){return qr(e)}}s_.className="sigmoid";Ae(s_);class r_ extends Ls{apply(e){return T8(e)}}r_.className="hardSigmoid";Ae(r_);class i_ extends Ls{apply(e){return kd(e)}}i_.className="softplus";Ae(i_);class a_ extends Ls{apply(e){return I8(e)}}a_.className="softsign";Ae(a_);class o_ extends Ls{apply(e){return Ru(e)}}o_.className="tanh";Ae(o_);let CC=class extends Ls{apply(e,t=-1){return Y0(e,t)}};CC.className="softmax";Ae(CC);class l_ extends Ls{apply(e,t=-1){return TS(e,t)}}l_.className="logSoftmax";Ae(l_);class u_ extends Ls{apply(e){return he(()=>he(()=>{const t=Math.sqrt(2),s=Q(.5,$e(1,kS(Ve(e,t))));return Q(e,s)}))}}u_.className="gelu";Ae(u_);class c_ extends Ls{apply(e){return he(()=>Q(.5,Q(e,$e(1,Ru(Q(ks(Ve(2,Math.PI)),$e(e,Q(.044715,uo(e,3)))))))))}}c_.className="gelu_new";Ae(c_);class h_ extends Ls{apply(e){return he(()=>Q(e,Ru(kd(e))))}}h_.className="mish";Ae(h_);class d_ extends Ls{apply(e,t=1){return he(()=>Q(qr(Q(e,t)),e))}}d_.className="swish";Ae(d_);function ml(n){return n.getClassName()}function Sw(n,e={}){return Mm(n,xi.getMap().classNameMap,e,"activation")}function gl(n){if(n==null){const e={};return e.className="linear",e.config={},Sw(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},Sw(e)}else return n instanceof Ls?n:Sw(n)}function VX(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class p_ extends Td{}class f_ extends p_{constructor(e){super(),VX(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return he(()=>{let t=zn([1]);return this.hasL1&&(t=$e(t,Ke(Q(this.l1,Qn(e))))),this.hasL2&&(t=$e(t,Ke(Q(this.l2,Bm(e))))),ae(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}f_.className="L1L2";Ae(f_);const OT={l1l2:"L1L2"};function un(n){return uC(n)}function FT(n,e={}){return Mm(n,xi.getMap().classNameMap,e,"regularizer")}function wn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in OT?OT[n]:n,config:{}};return FT(t)}else return n instanceof p_?n:FT(n)}class m_ extends Nt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=pt(e);let s=Ia(e);return this.maxValue!=null&&(s=hr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}m_.className="ReLU";Ae(m_);class g_ extends Nt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=pt(e);return P0(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}g_.className="LeakyReLU";Ae(g_);class y_ extends Nt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=vn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wn(e.alphaRegularizer),this.alphaConstraint=ns(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new oe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Vt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new Jn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=pt(e),j0(e,this.alpha.read())}getConfig(){const e={alphaInitializer:kn(this.alphaInitializer),alphaRegularizer:un(this.alphaRegularizer),alphaConstraint:ts(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}y_.className="PReLU";Ae(y_);let x_=class extends Nt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new St(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=pt(e);return Am(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};x_.className="ELU";Ae(x_);class b_ extends Nt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=pt(e);return Q(s,Fe(_r(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}b_.className="ThresholdedReLU";Ae(b_);class v_ extends Nt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new CC().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return he(()=>{let s=pt(e);const r=t.mask;if(r!=null){const i=Q(Ue($r(s.shape),Fe(r,s.dtype)),Je(-1e9));s=$e(s,i)}return this.axis instanceof Array?this.axis.length>1?Ks(Ue(s,V0(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}v_.className="Softmax";Ae(v_);function uh(n,e,t){if(typeof n=="number")return Du(n,e);if(n.length!==e)throw new oe(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!S8(r))throw new oe(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Gi(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let a;return t==="same"?a=n:a=n-i+1,Math.floor((a+s-1)/s)}function ma(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+fl([t-e,0]);else if(s==="same")n=n*e;else throw new oe(`Unsupport padding mode: ${s}.`);return n}function NC(n,e){return he(()=>(Pn(e),e==="channelsFirst"?_t(n,[0,2,3,1]):n))}function w_(n,e){return he(()=>(Pn(e),e==="channelsFirst"?_t(n,[0,2,3,4,1]):n))}function UX(n,e,t,s=1,r="valid",i,a=1){return he(()=>{if(i==null&&(i=Qi()),Pn(i),n.shape.length!==3)throw new oe(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new oe(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new oe(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=_t(n,[0,2,1])),r==="causal")throw new St("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=vS(n,e,s,r==="same"?"same":"valid","NWC",a);return t!=null&&(o=ta(o,t)),o})}function zT(n,e,t,s=[1,1],r="valid",i,a,o=null){return he(()=>{if(i==null&&(i=Qi()),Pn(i),n.rank!==3&&n.rank!==4)throw new oe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new oe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=NC(n,i);if(r==="causal")throw new St("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=fA({x:u,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),i==="channelsFirst"&&(u=_t(u,[0,3,1,2])),u})}function WX(n,e,t,s=[1,1,1],r="valid",i,a){return he(()=>{if(i==null&&(i=Qi()),Pn(i),n.rank!==4&&n.rank!==5)throw new oe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new oe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=w_(n,i);if(r==="causal")throw new St("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=F3(o,e,s,r==="same"?"same":"valid","NDHWC",a),t!=null&&(o=ta(o,t)),i==="channelsFirst"&&(o=_t(o,[0,4,1,2,3])),o})}class Db extends Nt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Db.verifyArgs(t),this.rank=e,gs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new St(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=uh(t.kernelSize,e,"kernelSize"),this.strides=uh(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Zr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Pn(this.dataFormat),this.activation=gl(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=vn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ns(t.biasConstraint),this.biasRegularizer=wn(t.biasRegularizer),this.activityRegularizer=wn(t.activityRegularizer),this.dilationRate=uh(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new oe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new oe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new oe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(fa("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!cC(e.kernelSize,"number",1,3))throw new oe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ml(this.activation),useBias:this.useBias,biasInitializer:kn(this.biasInitializer),biasRegularizer:un(this.biasRegularizer),activityRegularizer:un(this.activityRegularizer),biasConstraint:ts(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Ed extends Db{constructor(e,t){super(e,t),this.kernel=null,Ed.verifyArgs(t),this.filters=t.filters,gs(this.filters,"filters"),this.kernelInitializer=vn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ns(t.kernelConstraint),this.kernelRegularizer=wn(t.kernelRegularizer)}build(e){e=Vt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return he(()=>{e=pt(e);let s;const r=this.bias==null?null:this.bias.read(),i=yD(this.activation.getClassName());if(i!=null&&this.rank===2)s=zT(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=UX(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=zT(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=WX(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new St("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Vt(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const a=Gi(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:kn(this.kernelInitializer),kernelRegularizer:un(this.kernelRegularizer),kernelConstraint:ts(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new oe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Gm extends Ed{constructor(e){super(2,e),Gm.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!cC(e.kernelSize,"number",1,2))throw new oe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Gm.className="Conv2D";Ae(Gm);class Hm extends Ed{constructor(e){super(3,e),Hm.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new oe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Hm.className="Conv3D";Ae(Hm);class S_ extends Gm{constructor(e){if(super(e),this.inputSpec=[new Jn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new oe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Vt(e),e.length!==4)throw new oe("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Jn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return he(()=>{let s=pt(e);if(s.shape.length!==4)throw new oe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const u=r[a],c=r[o],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],g=this.strides[1],x=ma(u,m,d,this.padding),b=ma(c,g,p,this.padding),v=[i,x,b,this.filters];this.dataFormat!=="channelsLast"&&(s=_t(s,[0,2,3,1]));let w=SS(s,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=_t(w,[0,3,1,2])),this.bias!=null&&(w=ta(w,this.bias.read(),this.dataFormat)),this.activation!=null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=Vt(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const a=this.kernelSize[0],o=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[r]=ma(t[r],u,a,this.padding),t[i]=ma(t[i],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}S_.className="Conv2DTranspose";Ae(S_);class C_ extends Hm{constructor(e){if(super(e),this.inputSpec=[new Jn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new oe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Vt(e),e.length!==5)throw new oe("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Jn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return he(()=>{let s=pt(e);if(s.shape.length!==5)throw new oe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o,u;this.dataFormat==="channelsFirst"?(u=2,a=3,o=4):(u=1,a=2,o=3);const c=r[u],d=r[a],p=r[o],m=this.kernelSize[0],g=this.kernelSize[1],x=this.kernelSize[2],b=this.strides[0],v=this.strides[1],w=this.strides[2],N=ma(c,b,m,this.padding),I=ma(d,v,g,this.padding),$=ma(p,w,x,this.padding),E=[i,N,I,$,this.filters];this.dataFormat!=="channelsLast"&&(s=_t(s,[0,2,3,4,1]));let D=L3(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(D=_t(D,[0,4,1,2,3])),this.bias!==null&&(D=ta(D,this.bias.read(),this.dataFormat)),this.activation!==null&&(D=this.activation.apply(D)),D})}computeOutputShape(e){e=Vt(e);const t=e.slice();let s,r,i,a;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,a=4):(s=4,r=1,i=2,a=3);const o=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return t[s]=this.filters,t[r]=ma(t[r],d,o,this.padding),t[i]=ma(t[i],p,u,this.padding),t[a]=ma(t[a],m,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}C_.className="Conv3DTranspose";Ae(C_);class N_ extends Ed{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new oe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new oe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new oe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=vn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wn(t.depthwiseRegularizer),this.depthwiseConstraint=ns(t.depthwiseConstraint),this.pointwiseInitializer=vn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wn(t.pointwiseRegularizer),this.pointwiseConstraint=ns(t.pointwiseConstraint)}build(e){if(e=Vt(e),e.length<this.rank+2)throw new oe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new oe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Jn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return he(()=>{e=pt(e);let s;if(this.rank===1)throw new St("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=_t(e,[0,2,3,1])),s=PS(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ta(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=_t(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=kn(this.depthwiseInitializer),e.pointwiseInitializer=kn(this.pointwiseInitializer),e.depthwiseRegularizer=un(this.depthwiseRegularizer),e.pointwiseRegularizer=un(this.pointwiseRegularizer),e.depthwiseConstraint=ts(this.depthwiseConstraint),e.pointwiseConstraint=ts(this.pointwiseConstraint),e}}N_.className="SeparableConv";class k_ extends N_{constructor(e){super(2,e)}}k_.className="SeparableConv2D";Ae(k_);class _b extends Ed{constructor(e){super(1,e),_b.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!cC(e.kernelSize,"number",1,1))throw new oe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}_b.className="Conv1D";Ae(_b);class $_ extends Nt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return he(()=>{if(e=pt(e),this.dataFormat==="channelsLast"){const s=Cy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Cy(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Cy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Cy(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}$_.className="Cropping2D";Ae($_);class I_ extends Nt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,b8(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return he(()=>{let s=pt(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=_t(s,[0,2,3,1]);const i=this.size[0]*r[2],a=this.size[1]*r[3],o=this.interpolation==="nearest"?Xs.resizeNearestNeighbor(s,[i,a]):Xs.resizeBilinear(s,[i,a]);return _t(o,[0,3,1,2])}else{const i=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Xs.resizeNearestNeighbor(s,[i,a]):Xs.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}I_.className="UpSampling2D";Ae(I_);function GX(n,e,t=[1,1],s="valid",r,i){return he(()=>{r==null&&(r=Qi()),Pn(r);let a=NC(n,r);if(n.rank!==4)throw new oe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new oe(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Rm(a,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(a=_t(a,[0,3,1,2])),a})}class T_ extends Db{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=vn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ns(e.depthwiseConstraint),this.depthwiseRegularizer=wn(e.depthwiseRegularizer)}build(e){if(e=Vt(e),e.length<4)throw new oe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new oe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return he(()=>{e=pt(e);let s=GX(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ta(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Vt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Gi(t,this.kernelSize[0],this.padding,this.strides[0]),a=Gi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,a]:[e[0],i,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=kn(this.depthwiseInitializer),e.depthwiseRegularizer=un(this.depthwiseRegularizer),e.depthwiseConstraint=ts(this.depthwiseRegularizer),e}}T_.className="DepthwiseConv2D";Ae(T_);function E_(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new oe("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function R_(n,e,t,s=!1,r,i,a=!1,o=!1){return he(()=>{const u=e.shape.length;if(u<3)throw new oe(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(Yi(2,u));e=_t(e,c),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Fe(Fe(r,"bool"),"float32"),r.rank===u-1&&(r=Wn(r,-1)),r=_t(r,c)),s&&(e=$i(e,0),r!=null&&(r=$i(r,0)));const d=[];let p,m=t;const g=e.shape[0],x=Ii(e);let b;r!=null&&(b=Ii(r));for(let w=0;w<g;++w){const N=x[w],I=he(()=>n(N,m));if(r==null)p=I[0],m=I[1];else{const $=he(()=>{const E=b[w],D=Ue(Kr(E),E),F=$e(Q(I[0],E),Q(m[0],D)),L=m.map((z,M)=>$e(Q(I[1][M],E),Q(z,D)));return{output:F,newStates:L}});p=$.output,m=$.newStates}o&&d.push(p)}let v;return o&&(v=Tr(d,1)),[p,v,m]})}class Il extends Nt{constructor(e){super(e);let t;if(e.cell==null)throw new oe("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new IC({cells:e.cell}):t=e.cell,t.stateSize==null)throw new oe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Jn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Yi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){g2(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const a of t)i.push([e[0],a]);return[r].concat(i)}else return r}computeMask(e,t){return he(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new St("Constants support is not implemented in RNN yet.");g2(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Jn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!xt(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new oe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new Jn({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){he(()=>{if(!this.stateful)throw new pa("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new oe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>zn([s,r])):this.states_=[zn([s,this.cell.stateSize])];else if(e==null)rt(this.states_),this.keptStates!=null&&(rt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>zn([s,r])):this.states_[0]=zn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new oe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):rt(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,a];if(!xt(i.shape,o))throw new oe(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>ms(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=E_(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let a=[],o=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new Jn({shape:c.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Sa){const c=[e].concat(a),d=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=d;const m=super.apply(c,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return he(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=pt(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new oe(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},c=R_((x,b)=>{const v=this.cell.call([x].concat(b),o);return[v[0],v.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],p=c[1],m=c[2];this.stateful&&this.resetStates(m,r);const g=this.returnSequences?p:d;return this.returnState?[g].concat(m):g})}getInitialState(e){return he(()=>{let t=zn(e.shape);return t=Ke(t,[1,2]),t=Pm(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?f2(t,[1,s]):t):this.cell.stateSize>1?[f2(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Il.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=ao(r,s);return new e(Object.assign(t,{cell:i}))}}Il.className="RNN";Ae(Il);class Ob extends Nt{}class kC extends Ob{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,gs(this.units,"units"),this.activation=gl(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wn(e.kernelRegularizer),this.recurrentRegularizer=wn(e.recurrentRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.kernelConstraint=ns(e.kernelConstraint),this.recurrentConstraint=ns(e.recurrentConstraint),this.biasConstraint=ns(e.biasConstraint),this.dropout=mh([1,fl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=mh([1,fl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return he(()=>{if(e=e,e.length!==2)throw new oe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>Kr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>Kr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?i=ba(Q(e,a),this.kernel.read()):i=ba(e,this.kernel.read()),this.bias!=null&&(i=ta(i,this.bias.read())),o!=null&&(s=Q(s,o));let u=$e(i,ba(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ml(this.activation),useBias:this.useBias,kernelInitializer:kn(this.kernelInitializer),recurrentInitializer:kn(this.recurrentInitializer),biasInitializer:kn(this.biasInitializer),kernelRegularizer:un(this.kernelRegularizer),recurrentRegularizer:un(this.recurrentRegularizer),biasRegularizer:un(this.biasRegularizer),activityRegularizer:un(this.activityRegularizer),kernelConstraint:ts(this.kernelConstraint),recurrentConstraint:ts(this.recurrentConstraint),biasConstraint:ts(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}kC.className="SimpleRNNCell";Ae(kC);class A_ extends Il{constructor(e){e.cell=new kC(e),super(e)}call(e,t){return he(()=>{this.cell.dropoutMask!=null&&(rt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(rt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}A_.className="SimpleRNN";Ae(A_);class $C extends Ob{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new oe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,gs(this.units,"units"),this.activation=gl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=gl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wn(e.kernelRegularizer),this.recurrentRegularizer=wn(e.recurrentRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.kernelConstraint=ns(e.kernelConstraint),this.recurrentConstraint=ns(e.recurrentConstraint),this.biasConstraint=ns(e.biasConstraint),this.dropout=mh([1,fl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=mh([1,fl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return he(()=>{if(e=e,e.length!==2)throw new oe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>Kr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>Kr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let o,u,c;0<this.dropout&&this.dropout<1&&(e=Q(e,i[0]));let d=ba(e,this.kernel.read());this.useBias&&(d=ta(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Q(r,a[0]));const p=this.recurrentKernel.read(),[m,g]=Ir(p,[2*this.units,this.units],p.rank-1),x=ba(r,m),[b,v,w]=Ir(d,3,d.rank-1),[N,I]=Ir(x,2,x.rank-1);o=this.recurrentActivation.apply($e(b,N)),u=this.recurrentActivation.apply($e(v,I));const $=ba(Q(u,r),g);c=this.activation.apply($e(w,$));const E=$e(Q(o,r),Q($e(1,gn(o)),c));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ml(this.activation),recurrentActivation:ml(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kn(this.kernelInitializer),recurrentInitializer:kn(this.recurrentInitializer),biasInitializer:kn(this.biasInitializer),kernelRegularizer:un(this.kernelRegularizer),recurrentRegularizer:un(this.recurrentRegularizer),biasRegularizer:un(this.biasRegularizer),activityRegularizer:un(this.activityRegularizer),kernelConstraint:ts(this.kernelConstraint),recurrentConstraint:ts(this.recurrentConstraint),biasConstraint:ts(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}$C.className="GRUCell";Ae($C);class D_ extends Il{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new $C(e),super(e)}call(e,t){return he(()=>{this.cell.dropoutMask!=null&&(rt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(rt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}D_.className="GRU";Ae(D_);class Fb extends Ob{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,gs(this.units,"units"),this.activation=gl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=gl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wn(e.kernelRegularizer),this.recurrentRegularizer=wn(e.recurrentRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.kernelConstraint=ns(e.kernelConstraint),this.recurrentConstraint=ns(e.recurrentConstraint),this.biasConstraint=ns(e.biasConstraint),this.dropout=mh([1,fl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=mh([1,fl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Vt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;r=new(t=class extends Ti{apply(u,c){const d=i.apply([a]),p=new dC().apply([a]),m=i.apply([a*2]);return bT(bT(d,p),m)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return he(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new oe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>Kr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>Kr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let u,c,d,p;0<this.dropout&&this.dropout<1&&(e=Q(e,a[0]));let m=ba(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Q(r,o[0])),m=$e(m,ba(r,this.recurrentKernel.read())),this.useBias&&(m=ta(m,this.bias.read()));const[g,x,b,v]=Ir(m,4,m.rank-1);u=this.recurrentActivation.apply(g),c=this.recurrentActivation.apply(x),d=$e(Q(c,i),Q(u,this.activation.apply(b))),p=this.recurrentActivation.apply(v);const w=Q(p,this.activation.apply(d));return[w,w,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ml(this.activation),recurrentActivation:ml(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kn(this.kernelInitializer),recurrentInitializer:kn(this.recurrentInitializer),biasInitializer:kn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:un(this.kernelRegularizer),recurrentRegularizer:un(this.recurrentRegularizer),biasRegularizer:un(this.biasRegularizer),activityRegularizer:un(this.activityRegularizer),kernelConstraint:ts(this.kernelConstraint),recurrentConstraint:ts(this.recurrentConstraint),biasConstraint:ts(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Fb.className="LSTMCell";Ae(Fb);class __ extends Il{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Fb(e),super(e)}call(e,t){return he(()=>{this.cell.dropoutMask!=null&&(rt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(rt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}__.className="LSTM";Ae(__);class IC extends Ob{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return he(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let a;for(let o=0;o<this.cells.length;++o){const u=this.cells[o];s=r[o],o===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=u.call(a,t),i.push(a.slice(1))}s=[];for(const o of i.slice().reverse())s.push(...o);return[a[0]].concat(s)})}build(e){g2(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{xu(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(ao(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return y2(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],i[a]])}bC(t)}}IC.className="StackedRNNCells";Ae(IC);function yl(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,a=()=>i!=null?i(e(),t):ND(e(),t),o=()=>Vm(a,e,s);return!r||r<=1?ms(o().clone()):Array(r).fill(void 0).map(o).map(c=>ms(c.clone()))}var HX=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class O_ extends Il{constructor(e){if(e.unroll)throw new St("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new St("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Jn({ndim:5})]}call(e,t){return he(()=>{if(this.cell.dropoutMask!=null&&(rt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(rt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new oe("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return he(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],a=zn(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){he(()=>{if(!this.stateful)throw new pa("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new oe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>zn(i)):this.states_=[zn(i)];else if(e==null)rt(this.states_),this.keptStates!=null&&(rt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>zn(i)):this.states_[0]=zn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new oe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):rt(this.states_);for(let o=0;o<this.states_.length;++o){const u=e[o],c=i;if(!xt(u.shape,c))throw new oe(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[o]=u}}this.states_=this.states_.map(o=>ms(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:a,dilationRate:o}=this.cell,u=t==="channelsFirst",c=e[u?3:2],d=e[u?4:3],p=Gi(c,r[0],i,a[0],o[0]),m=Gi(d,r[1],i,a[1],o[1]);return[...e.slice(0,2),...u?[s,p,m]:[p,m,s]]}}O_.className="ConvRNN2D";class TC extends Fb{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,gs(this.filters,"filters"),this.kernelSize=uh(s,2,"kernelSize"),this.kernelSize.forEach(u=>gs(u,"kernelSize")),this.strides=uh(r||1,2,"strides"),this.strides.forEach(u=>gs(u,"strides")),this.padding=i||"valid",Zr(this.padding),this.dataFormat=a||"channelsLast",Pn(this.dataFormat),this.dilationRate=uh(o||1,2,"dilationRate"),this.dilationRate.forEach(u=>gs(u,"dilationRate"))}build(e){var t;e=Vt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new oe(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,a=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new(t=class extends Ti{apply(m,g){const x=c.apply([d]),b=$r([d]),v=c.apply([d*2]);return hC([x,b,v])}},t.className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return he(()=>{if(e.length!==3)throw new oe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>Kr(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(ge,G,re)=>!G||!G[re]?ge:Q(G[re],ge);let d=c(r,u,0),p=c(r,u,1),m=c(r,u,2),g=c(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>Kr(i),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const x=this.recurrentDropoutMask;let b=c(i,x,0),v=c(i,x,1),w=c(i,x,2),N=c(i,x,3);const I=3,[$,E,D,F]=Ir(this.kernel.read(),o,I),[L,z,M,O]=this.useBias?Ir(this.bias.read(),o):[null,null,null,null];d=this.inputConv(d,$,L,this.padding),p=this.inputConv(p,E,z,this.padding),m=this.inputConv(m,D,M,this.padding),g=this.inputConv(g,F,O,this.padding);const[H,X,te,Z]=Ir(this.recurrentKernel.read(),o,I);b=this.recurrentConv(b,H),v=this.recurrentConv(v,X),w=this.recurrentConv(w,te),N=this.recurrentConv(N,Z);const W=this.recurrentActivation.apply($e(d,b)),ee=this.recurrentActivation.apply($e(p,v)),ie=$e(Q(ee,a),Q(W,this.activation.apply($e(m,w)))),de=Q(this.recurrentActivation.apply($e(g,N)),this.activation.apply(ie));return[de,de,ie]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=HX(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=hl(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?ta(i,s,this.dataFormat):i}recurrentConv(e,t){return hl(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}TC.className="ConvLSTM2DCell";Ae(TC);class F_ extends O_{constructor(e){const t=new TC(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}F_.className="ConvLSTM2D";Ae(F_);class EC extends Nt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return Vm(()=>ND(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}EC.className="Dropout";Ae(EC);class z_ extends EC{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}z_.className="SpatialDropout1D";Ae(z_);class L_ extends Nt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,gs(this.units,"units"),this.activation=gl(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ns(e.kernelConstraint),this.biasConstraint=ns(e.biasConstraint),this.kernelRegularizer=wn(e.kernelRegularizer),this.biasRegularizer=wn(e.biasRegularizer),this.activityRegularizer=wn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Vt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Vt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e),r=yD(this.activation.getClassName());let i;return r!=null?i=ba(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=ba(s,this.kernel.read()),this.bias!=null&&(i=ta(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:ml(this.activation),useBias:this.useBias,kernelInitializer:kn(this.kernelInitializer),biasInitializer:kn(this.biasInitializer),kernelRegularizer:un(this.kernelRegularizer),biasRegularizer:un(this.biasRegularizer),activityRegularizer:un(this.activityRegularizer),kernelConstraint:ts(this.kernelConstraint),biasConstraint:ts(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}L_.className="Dense";Ae(L_);class M_ extends Nt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Vt(e);for(const t of e.slice(1))if(t==null)throw new oe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ol(e,1)]}call(e,t){return he(()=>{this.invokeCallHook(e,t);let s=pt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=_t(s,r)}return k8(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}M_.className="Flatten";Ae(M_);class P_ extends Nt{constructor(e){super(e),this.supportsMasking=!0,this.activation=gl(e.activation)}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e);return this.activation.apply(s)})}getConfig(){const e={activation:ml(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}P_.className="Activation";Ae(P_);class B_ extends Nt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return he(()=>(e=pt(e),C8(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}B_.className="RepeatVector";Ae(B_);class V_ extends Nt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,a=null;for(let u=0;u<r.length;++u){const c=r[u];if(this.isUnknown(c))if(a===null)a=u;else throw new oe("Can only specifiy one unknown dimension.");else i*=c}const o=ol(e);if(a!==null){if(i===0||o%i!==0)throw new oe(s);r[a]=o/i}else if(o!==i)throw new oe(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ae(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}V_.className="Reshape";Ae(V_);class U_ extends Nt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Yi(1,e.dims.length+1);if(!xt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Jn({ndim:this.dims.length+1})]}computeOutputShape(e){e=Vt(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return _t(pt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}U_.className="Permute";Ae(U_);class W_ extends Nt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=pt(e);return ix(ph(s,this.maskValue),-1)}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e),a=ix(ph(s,this.maskValue),-1,!0);return Q(s,Fe(a,s.dtype))})}}W_.className="Masking";Ae(W_);class G_ extends Nt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Yt(e.inputLength))}this.inputDim=e.inputDim,gs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,gs(this.outputDim,"outputDim"),this.embeddingsInitializer=vn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wn(e.embeddingsRegularizer),this.activityRegularizer=wn(e.activityRegularizer),this.embeddingsConstraint=ns(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return he(()=>this.maskZero?(e=pt(e),ph(e,Ot(e))):null)}computeOutputShape(e){if(e=Vt(e),this.inputLength==null)return[...e,this.outputDim];const t=Yt(this.inputLength);if(t.length!==e.length-1)throw new oe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],a=e[r+1];if(i!=null&&a!=null&&i!==a)throw new oe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return he(()=>{this.invokeCallHook(e,t);let s=pt(e);s.dtype!=="int32"&&(s=xa(s,"int32"));const r=CD(this.embeddings.read(),ae(s,[s.size]));return ae(r,Vt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:kn(this.embeddingsInitializer),embeddingsRegularizer:un(this.embeddingsRegularizer),activityRegularizer:un(this.activityRegularizer),embeddingsConstraint:ts(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}G_.className="Embedding";Ae(G_);class qu extends Nt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new St}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],a=t[r];if(i==null||a==null||i<0||a<0)s.push(null);else if(i===1)s.push(a);else if(a===1)s.push(i);else{if(i!==a)throw new oe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Vt(e)]),e=e,e.length<2)throw new oe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=al(t),t.length>1)throw new oe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const a=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&al(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return he(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=fl(r);for(let a of e){const o=a.rank;for(let u=0;u<i-o;++u)a=Pm(a,1);s.push(a)}return this.mergeFunction(s)}else{let i=!1;for(const u of e){const c=u.rank;if(c==null){const d=u.shape,p=d[0],m=d.slice(1).concat([p]);let g=ae(u,[p].concat(ol(d.slice(1))));g=_t(g,[1,0]),g=ae(g,m),s.push(g),i=!0}else if(c>1){const d=Yi(1,c).concat([0]);s.push(_t(u,d)),i=!0}else s.push(u)}let a=this.mergeFunction(s);const o=a.rank;if(i){if(o==null){const u=a.shape,c=u.length,d=u[c-1],p=[d].concat(u.slice(0,u.length-1));a=ae(_t(ae(a,[-1,d]),[1,0]),p)}else if(o>1){const u=[o-1].concat(Yi(0,o-1));a=_t(a,u)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=al(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return he(()=>{if(t==null)return null;if(!Array.isArray(t))throw new oe("`mask` should be an Array");if(!Array.isArray(e))throw new oe("`inputs` should be an Array");if(t.length!==e.length)throw new oe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Wn(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=wa(s,t[r]);return s})}}class H_ extends qu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=$e(t,e[s]);return t})}}H_.className="Add";Ae(H_);class j_ extends qu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Q(t,e[s]);return t})}}j_.className="Multiply";Ae(j_);class q_ extends qu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=$e(t,e[s]);return Q(1/e.length,t)})}}q_.className="Average";Ae(q_);class X_ extends qu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=po(t,e[s]);return t})}}X_.className="Maximum";Ae(X_);class K_ extends qu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=pl(t,e[s]);return t})}}K_.className="Minimum";Ae(K_);class Y_ extends qu{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new oe("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let a=!1;for(const o of s)if(xt(o,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new oe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return he(()=>hC(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new oe("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new oe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new oe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new oe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return he(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(Fe(Kr(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Wn(t[a],-1)):r.push(t[a]);const i=$n(r,this.axis);return xS(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Y_.className="Concatenate";Ae(Y_);function Gp(n,e){for(;n<0;)n+=e;return n}function jX(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new St("batchDot is not implemented for tensors of 4D or higher rank yet");if(B(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),B(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new St("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return he(()=>{let a;if(s>r){a=s-r;const u=[];for(let c=0;c<a;++c)u.push(1);e=ae(e,e.shape.concat(u))}else if(r>s){a=r-s;const u=[];for(let c=0;c<a;++c)u.push(1);n=ae(n,n.shape.concat(u))}else a=0;let o;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?o=Ke(Q(n,e),i[0]):o=Ke(Q(_t(n,[1,0]),e),i[1]);else{const u=i[0]!==n.shape.length-1,c=i[1]===e.shape.length-1;o=kt(n,e,u,c)}if(a>0){let u;s>r?u=s+r-3:u=s-1;const c=[];for(let d=u;d<u+a;++d)c.push(d);o=Wt(o,c)}return o.shape.length===1&&(o=Wn(o,1)),o})}class Q_ extends qu{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){B(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new St("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new oe(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new oe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,a)=>Gp(i,e[a].shape.length)):r=[Gp(this.axes,t.shape.length),Gp(this.axes,s.shape.length)],this.normalize&&(t=hx(t,r[0]),s=hx(s,r[1])),jX(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Gp(this.axes,e.length),Gp(this.axes,t.length)],s}computeOutputShape(e){B(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new St("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Q_.className="Dot";Ae(Q_);class Z_ extends Nt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e);return Vm(()=>$e(Tb(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}Z_.className="GaussianNoise";Ae(Z_);class J_ extends Nt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return he(()=>{this.invokeCallHook(e,t);const s=pt(e);return this.rate>0&&this.rate<1?Vm(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return Q(s,Tb(s.shape,1,i))},()=>s,t.training||!1):s})}}J_.className="GaussianDropout";Ae(J_);class eO extends Nt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||pt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return he(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Vm(()=>{const i=pt(e),o=-1.6732632423543772*1.0507009873554805;let u=kl(Uu(s),this.rate);u=xa(u,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,d=-c*o*this.rate,p=$e(Q(i,u),Q($e(u,-1),o));return $e(Q(p,c),d)},()=>pt(e),t.training||!1)}return e})}}eO.className="AlphaDropout";Ae(eO);function bf(n,e,t,s,r,i=.001){let a;if(n.rank===2)a=$3(n,e,t,s,r,i);else if(n.rank===3)a=I3(n,e,t,s,r,i);else if(n.rank===4)a=T3(n,e,t,s,r,i);else throw new St(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function qX(n,e,t,s,r=.001){return he(()=>{const i=G0(n,s),a=i.mean,o=i.variance;return[bf(n,a,o,t,e,r),a,o]})}function XX(n,e,t,s,r=.001){return he(()=>{const i=G0(n,s),a=i.mean,o=i.variance,u=[];for(const x of Yi(0,n.rank))s.indexOf(x)!==-1?u.push(1):u.push(n.shape[x]);const c=ae(a,u),d=ae(o,u),p=e==null?null:ae(e,u),m=t==null?null:ae(t,u);return[bf(n,c,d,m,p,r),a,o]})}function KX(n,e,t,s,r=.001){return xt(s.slice().sort(),Yi(0,n.rank-1))?qX(n,e,t,s,r):XX(n,e,t,s,r)}class tO extends Nt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=vn(e.betaInitializer||"zeros"),this.gammaInitializer=vn(e.gammaInitializer||"ones"),this.movingMeanInitializer=vn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=vn(e.movingVarianceInitializer||"ones"),this.betaConstraint=ns(e.betaConstraint),this.gammaConstraint=ns(e.gammaConstraint),this.betaRegularizer=wn(e.betaRegularizer),this.gammaRegularizer=wn(e.gammaRegularizer)}build(e){e=Vt(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new oe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Jn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return he(()=>{const s=t.training==null?!1:t.training,r=pt(e),i=r.shape,a=i.length,o=Yi(0,a),u=this.axis>=0?this.axis:this.axis+a;o.splice(u,1);const c=Du(1,a);c[u]=i[u];const d=o.slice();d.sort();const p=!xt(d,Yi(0,a).slice(0,a-1)),m=()=>{if(p){const N=ae(this.movingMean.read(),c),I=ae(this.movingVariance.read(),c),$=this.center?ae(this.beta.read(),c):null,E=this.scale?ae(this.gamma.read(),c):null;return bf(r,N,I,$,E,this.epsilon)}else return bf(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[g,x,b]=KX(r,this.gamma.read(),this.beta.read(),o,this.epsilon),v=(N,I,$)=>{he(()=>{const E=1-$,D=N.read(),F=Q(Ue(D,I),E);N.write(Ue(D,F))})};return(()=>{v(this.movingMean,x,this.momentum),v(this.movingVariance,b,this.momentum)})(),g})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:kn(this.betaInitializer),gammaInitializer:kn(this.gammaInitializer),movingMeanInitializer:kn(this.movingMeanInitializer),movingVarianceInitializer:kn(this.movingVarianceInitializer),betaRegularizer:un(this.betaRegularizer),gammaRegularizer:un(this.gammaRegularizer),betaConstraint:ts(this.betaConstraint),gammaConstraint:ts(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}tO.className="BatchNormalization";Ae(tO);class nO extends Nt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=vn(e.betaInitializer||"zeros"),this.gammaInitializer=vn(e.gammaInitializer||"ones"),this.betaRegularizer=wn(e.betaRegularizer),this.gammaRegularizer=wn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Vt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==al(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=pt(e),r=s.shape,i=r.length;return he(()=>{let{mean:o,variance:u}=G0(s,this.axis,!0);const c=Du(1,i);for(const b of this.axis)c[b]=r[b];const d=b=>b!=null&&b.shape.length!==i?ae(b,c):b;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const g=[],x=[];for(let b=0;b<i;++b)this.axis.indexOf(b)!==-1?(g.push(r[b]),x.push(1)):(g.push(1),x.push(r[b]));return o=bi(o,g),u=bi(u,g),p!=null&&(p=bi(p,x)),m!=null&&(m=bi(m,x)),bf(s,o,u,m,p,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:kn(this.betaInitializer),gammaInitializer:kn(this.gammaInitializer),betaRegularizer:un(this.betaRegularizer),gammaRegularizer:un(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}nO.className="LayerNormalization";Ae(nO);function YX(n,e,t){return he(()=>{if(n.rank!==4)throw new oe(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new oe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Qi()),t!=="channelsLast"&&t!=="channelsFirst")throw new oe(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],qi(n,s)})}class sO extends Nt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Qi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new oe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new oe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new oe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new Jn({ndim:4})]}computeOutputShape(e){e=Vt(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return he(()=>YX(pt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}sO.className="ZeroPadding2D";Ae(sO);function zb(n,e,t,s,r,i){return he(()=>{Pn(r),bD(i),Zr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Qi()),i==null&&(i="max"),n=NC(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=W0(n,e,t,o):a=F0(n,e,t,o),r==="channelsFirst"&&(a=_t(a,[0,3,1,2])),a})}function rO(n,e,t,s,r,i){return he(()=>{Pn(r),bD(i),Zr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Qi()),i==null&&(i="max"),n=w_(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=Z3(n,e,t,o):a=k3(n,e,t,o),r==="channelsFirst"&&(a=_t(a,[0,4,1,2,3])),a})}class iO extends Nt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new oe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(gs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new oe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);gs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Zr(this.padding),this.inputSpec=[new Jn({ndim:3})]}computeOutputShape(e){e=Vt(e);const t=Gi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return he(()=>{this.invokeCallHook(e,t),e=Pm(pt(e),2);const s=this.poolingFunction(pt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Wt(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class aO extends iO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Pn(i),Zr(r),zb(e,t,s,r,i,"max")}}aO.className="MaxPooling1D";Ae(aO);class oO extends iO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Pn(i),Zr(r),zb(e,t,s,r,i,"avg")}}oO.className="AveragePooling1D";Ae(oO);class lO extends Nt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new oe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];gs(this.poolSize,"poolSize"),gs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pn(this.dataFormat),Zr(this.padding),this.inputSpec=[new Jn({ndim:4})]}computeOutputShape(e){e=Vt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Gi(t,this.poolSize[0],this.padding,this.strides[0]),s=Gi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return he(()=>(this.invokeCallHook(e,t),this.poolingFunction(pt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class uO extends lO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Pn(i),Zr(r),zb(e,t,s,r,i,"max")}}uO.className="MaxPooling2D";Ae(uO);class cO extends lO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Pn(i),Zr(r),zb(e,t,s,r,i,"avg")}}cO.className="AveragePooling2D";Ae(cO);class hO extends Nt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new oe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];gs(this.poolSize,"poolSize"),gs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pn(this.dataFormat),Zr(this.padding),this.inputSpec=[new Jn({ndim:5})]}computeOutputShape(e){e=Vt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Gi(t,this.poolSize[0],this.padding,this.strides[0]),s=Gi(s,this.poolSize[1],this.padding,this.strides[1]),r=Gi(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return he(()=>(this.invokeCallHook(e,t),this.poolingFunction(pt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class dO extends hO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Pn(i),Zr(r),rO(e,t,s,r,i,"max")}}dO.className="MaxPooling3D";Ae(dO);class pO extends hO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Pn(i),Zr(r),rO(e,t,s,r,i,"avg")}}pO.className="AveragePooling3D";Ae(pO);class fO extends Nt{constructor(e){super(e),this.inputSpec=[new Jn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new St}}class mO extends fO{constructor(e){super(e||{})}call(e,t){return he(()=>{const s=pt(e);return Tn(s,1)})}}mO.className="GlobalAveragePooling1D";Ae(mO);class gO extends fO{constructor(e){super(e||{})}call(e,t){return he(()=>{const s=pt(e);return Ci(s,1)})}}gO.className="GlobalMaxPooling1D";Ae(gO);class yO extends Nt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pn(this.dataFormat),this.inputSpec=[new Jn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new St}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class xO extends yO{call(e,t){return he(()=>{const s=pt(e);return this.dataFormat==="channelsLast"?Tn(s,[1,2]):Tn(s,[2,3])})}}xO.className="GlobalAveragePooling2D";Ae(xO);class bO extends yO{call(e,t){return he(()=>{const s=pt(e);return this.dataFormat==="channelsLast"?Ci(s,[1,2]):Ci(s,[2,3])})}}bO.className="GlobalMaxPooling2D";Ae(bO);class vO extends Nt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=ao(r,s);delete t.layer;const a={layer:i};return Object.assign(a,t),new e(a)}}class wO extends vO{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Vt(e),e.length<3)throw new oe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Vt(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return he(()=>(e=pt(e),R_((a,o)=>[pt(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}wO.className="TimeDistributed";Ae(wO);function QX(n){ju(x8,"BidirectionalMergeMode",n)}const ZX="concat";class SO extends vO{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=ao(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=ao(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?ZX:e.mergeMode,QX(this.mergeMode),e.weights)throw new St("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):ar(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=E_(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const a=[],o=[];if(s!=null){const c=s.length;if(c%2>0)throw new oe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const d=s.map(p=>new Jn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),o.push(...d)}if(r!=null)throw new St("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof Sa;for(const c of a)if(c instanceof Sa!==u)throw new oe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=d;const m=super.apply(c,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return he(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=$i(i,1));let o;return this.mergeMode==="concat"?o=hC([r,i]):this.mergeMode==="sum"?o=$e(r,i):this.mergeMode==="ave"?o=Q(.5,$e(r,i)):this.mergeMode==="mul"?o=Q(r,i):this.mergeMode==null&&(o=[r,i]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){xu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),xu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=ao(t.layer);if(delete t.layer,t.numConstants!=null)throw new St("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}SO.className="Bidirectional";Ae(SO);class CO extends Nt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return he(()=>(e=pt(e),e.dtype!=="float32"&&(e=xa(e,"float32")),$e(Q(e,this.scale),this.offset)))}}CO.className="Rescaling";Ae(CO);const{resizeBilinear:JX,cropAndResize:eK}=Xs;class NO extends Nt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,a,o,u){return he(()=>{let c,d=!1;const p=t/a,m=s/o,g=(r+t)/a,x=(i+s)/o,b=[p,m,g,x],v=[];e.rank===3?(d=!0,c=Tr([e])):c=e;for(let E=0;E<c.shape[0];E++)v.push(b);const w=Wi(v,[v.length,4]),N=fh(0,v.length,1,"int32"),$=eK(c,w,N,[r,i],"nearest");return xa(d?pt(Ii($)):$,u)})}upsize(e,t,s,r){return he(()=>{const i=JX(e,[t,s]);return xa(i,r)})}call(e,t){return he(()=>{const s=pt(e),r=s.dtype,i=s.shape,a=i[i.length-3],o=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),u>=0&&c>=0?this.centerCrop(s,u,c,this.height,this.width,a,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Vt(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}NO.className="CenterCrop";Ae(NO);function tK(n,e,t,s){let r=pt(n);if(r.dtype!=="int32"&&(r=xa(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=Wn(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Wn(r,-1)),r.rank>2)throw new oe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),o=r;let u;if(typeof s<"u"&&e==="count"?u=l2(o,s,t,a):u=l2(o,[],t,a),e!=="tfIdf")return u;if(s)return Q(u,s);throw new oe("When outputMode is 'tfIdf', weights must be provided.")}class kO extends Nt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Vt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return he(()=>{e=pt(e),e.dtype!=="int32"&&(e=xa(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new oe(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=pt(t.countWeights)}const r=Ci(e),i=hf(e),a=_r(this.numTokens,r).bufferSync().get(0),o=kl(i,0).bufferSync().get(0);if(!(a&&o))throw new oe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return tK(e,this.outputMode,this.numTokens,s)})}}kO.className="CategoryEncoding";Ae(kO);const nK=["bilinear","nearest"],LT=new Set(nK);class $O extends Nt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(LT.has(e.interpolation))this.interpolation=e.interpolation;else throw new oe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Vt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return he(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Xs.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Xs.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...LT]} are supported`)})}}$O.className="Resizing";Ae($O);class IO{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}IO.className="RandomSeed";class TO extends Nt{constructor(e){super(e),this.randomGenerator=new IO(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}TO.className="BaseRandomLayer";const sK=["bilinear","nearest"],MT=new Set(sK);class EO extends TO{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new oe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new oe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new oe(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(MT.has(s))this.interpolation=s;else throw new oe(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Vt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return he(()=>{const s=pt(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Uu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Xs.resizeBilinear(e,a);case"nearest":return Xs.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...MT]} are supported`)}})}}EO.className="RandomWidth";Ae(EO);const rK=fe();rK.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Cr;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Cr||(Cr={}));var PT;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(PT||(PT={}));const iK={};function RO(n){return iK[n]}function R(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,u=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,c=o<0?e.inputNames.length+o:o;if(i.type==="tensor")return Ss(e.inputNames[c],t,s,r);if(i.type==="tensors"){const m=e.inputs.slice(o,u);return e.inputNames.slice(o,u).filter((x,b)=>{var v;return((v=m[b])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(x=>Ss(x,t,s,r))}const d=Ss(e.inputNames[c],t,s,r),p=d.dataSync();return i.type==="number"?p[0]:Si(d.shape,p)}const a=e.attrParams[n];return a&&a.value}function Ss(n,e,t,s){const[r,i]=Nr(n,t);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[gx(r,o)]);return a!==void 0?e[gx(r,a)][i]:void 0}function BT(n,e,t){return e[gx(n,t.currentContextId)]}function to(n,e){const[t,s,r]=Nr(n,e);return[gx(t,e&&e.currentContextId),s,r]}function gx(n,e){return e?`${n}-${e}`:n}function Nr(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],a=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[i,o,a]}return t&&e.parseNodeNameCache.set(n,r),r}function jy(n,e,t){let s=R("pad",n,e,t);if(s==="explicit"){s=R("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function no(n){return n.kept?n:io(n)}const aK=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],oK=Object.freeze(Object.defineProperty({__proto__:null,json:aK},Symbol.toStringTag,{value:"Module"}));const lK=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uK=Object.freeze(Object.defineProperty({__proto__:null,json:lK},Symbol.toStringTag,{value:"Module"}));const cK=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],hK=Object.freeze(Object.defineProperty({__proto__:null,json:cK},Symbol.toStringTag,{value:"Module"}));const dK=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],pK=Object.freeze(Object.defineProperty({__proto__:null,json:dK},Symbol.toStringTag,{value:"Module"}));const fK=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],mK=Object.freeze(Object.defineProperty({__proto__:null,json:fK},Symbol.toStringTag,{value:"Module"}));const gK=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yK=Object.freeze(Object.defineProperty({__proto__:null,json:gK},Symbol.toStringTag,{value:"Module"}));const xK=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],bK=Object.freeze(Object.defineProperty({__proto__:null,json:xK},Symbol.toStringTag,{value:"Module"}));const vK=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],wK=Object.freeze(Object.defineProperty({__proto__:null,json:vK},Symbol.toStringTag,{value:"Module"}));const SK=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],CK=Object.freeze(Object.defineProperty({__proto__:null,json:SK},Symbol.toStringTag,{value:"Module"}));const NK=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],kK=Object.freeze(Object.defineProperty({__proto__:null,json:NK},Symbol.toStringTag,{value:"Module"}));const $K=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],IK=Object.freeze(Object.defineProperty({__proto__:null,json:$K},Symbol.toStringTag,{value:"Module"}));const TK=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],EK=Object.freeze(Object.defineProperty({__proto__:null,json:TK},Symbol.toStringTag,{value:"Module"}));const RK=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],AK=Object.freeze(Object.defineProperty({__proto__:null,json:RK},Symbol.toStringTag,{value:"Module"}));const DK=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],_K=Object.freeze(Object.defineProperty({__proto__:null,json:DK},Symbol.toStringTag,{value:"Module"}));const OK=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],FK=Object.freeze(Object.defineProperty({__proto__:null,json:OK},Symbol.toStringTag,{value:"Module"}));const zK=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],LK=Object.freeze(Object.defineProperty({__proto__:null,json:zK},Symbol.toStringTag,{value:"Module"}));const MK=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],PK=Object.freeze(Object.defineProperty({__proto__:null,json:MK},Symbol.toStringTag,{value:"Module"}));const BK=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],VK=Object.freeze(Object.defineProperty({__proto__:null,json:BK},Symbol.toStringTag,{value:"Module"}));const UK=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],WK=Object.freeze(Object.defineProperty({__proto__:null,json:UK},Symbol.toStringTag,{value:"Module"}));class VT{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[oK,uK,hK,pK,mK,yK,bK,wK,CK,kK,IK,EK,AK,_K,FK,LK,PK,VK,WK],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],a=[],o=s.reduce((b,v)=>(b[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?r.push(b[v.name]):v.op==="Const"?i.push(b[v.name]):(v.input==null||v.input.length===0)&&a.push(b[v.name]),b),{});let u=[];const c=[];let d={},p={};t!=null&&(d=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));const m=Object.keys(o);m.forEach(b=>{const v=o[b];v.inputNames.forEach((w,N)=>{const[I,,$]=to(w),E=o[I];if(E.outputs!=null){const D=E.outputs.indexOf($);if(D!==-1){const F=`${I}:${D}`;v.inputNames[N]=F}}v.inputs.push(E),E.children.push(v)})}),Object.keys(p).length===0?m.forEach(b=>{const v=o[b];v.children.length===0&&c.push(v)}):Object.keys(p).forEach(b=>{const[v]=to(b),w=o[v];w!=null&&(w.signatureKey=p[b],c.push(w))}),Object.keys(d).length>0?Object.keys(d).forEach(b=>{const[v]=to(b),w=o[v];w&&(w.signatureKey=d[b],u.push(w))}):u=r;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((b,v)=>(b[v.signature.name]=this.mapFunction(v),b),{}));const x={nodes:o,inputs:u,outputs:c,weights:i,placeholders:r,signature:t,functions:g};return a.length>0&&(x.initNodes=a),x}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=RO(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const a=i.type;let o;switch(i.type){case"string":o=C2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=C2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=R2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=R2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=k2(e.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=k2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=E2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=E2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=N2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=N2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=D2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=D2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=T2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=T2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=A2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=A2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=$2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=$2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=I2(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=I2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=UT(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=UT(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:o,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&r.push(p[m.name]),p),{}));const a=[],o=[];e.signature.inputArg.forEach(p=>{const[m]=to(p.name),g={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:RC(p.type),type:"dtype"}},children:[]};g.signatureKey=p.name,a.push(g),i[m]=g}),Object.keys(i).forEach(p=>{const m=i[p];m.inputNames.forEach((g,x)=>{const[b,,v]=to(g),w=i[b];if(w.outputs!=null){const N=w.outputs.indexOf(v);if(N!==-1){const I=`${b}:${N}`;m.inputNames[x]=I}}m.inputs.push(w),w.children.push(m)})});const c=e.ret;e.signature.outputArg.forEach(p=>{const[m,g]=to(c[p.name]),x=i[m];x!=null&&(x.defaultOutput=g,o.push(x))});const d=this.mapArgsToSignature(e);return{nodes:i,inputs:a,outputs:o,weights:r,placeholders:s,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function GK(n){const e=fe().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function AO(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):GK(n);return e?t:t.toLowerCase()}function C2(n,e,t,s=!1){const r=n[e];return r!=null?AO(r.s,s):t}function N2(n,e,t){const s=n[e];return s?s.b:t}function k2(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function RC(n){switch(typeof n=="string"&&(n=Cr[n]),n){case Cr.DT_FLOAT:case Cr.DT_HALF:return"float32";case Cr.DT_INT32:case Cr.DT_INT64:case Cr.DT_INT8:case Cr.DT_UINT8:return"int32";case Cr.DT_BOOL:return"bool";case Cr.DT_DOUBLE:return"float32";case Cr.DT_STRING:return"string";case Cr.DT_COMPLEX64:case Cr.DT_COMPLEX128:return"complex64";default:return null}}function UT(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function $2(n,e,t){const s=n[e];return s&&s.type?RC(s.type):t}function I2(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>RC(r)):t}function DO(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function T2(n,e,t){const s=n[e];return s&&s.shape?DO(s.shape):t}function E2(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function R2(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>AO(i,s)):t}function A2(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>DO(r)):t}function D2(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class HK{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return Ss(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Ss(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return k2(this.node.rawAttrs,e,t);if(s.s!=null)return C2(this.node.rawAttrs,e,t);if(s.b!=null)return N2(this.node.rawAttrs,e,t);if(s.shape!=null)return T2(this.node.rawAttrs,e,t);if(s.type!=null)return $2(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return E2(this.node.rawAttrs,e,t);if(s.list.s!=null)return R2(this.node.rawAttrs,e,t);if(s.list.shape!=null)return A2(this.node.rawAttrs,e,t);if(s.list.b!=null)return D2(this.node.rawAttrs,e,t);if(s.list.type!=null)return I2(this.node.rawAttrs,e,t)}return t}}const $s=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:t3,abs:Qn,acos:y3,acosh:x3,add:$e,addN:lV,all:xS,any:ix,argMax:Tu,argMin:b3,asin:v3,asinh:w3,atan:S3,atan2:C3,atanh:N3,avgPool:F0,avgPool3d:k3,basicLSTMCell:AV,batchNorm:Em,batchNorm2d:$3,batchNorm3d:I3,batchNorm4d:T3,batchToSpaceND:z0,bincount:E3,bitwiseAnd:BV,booleanMaskAsync:NH,broadcastArgs:UV,broadcastTo:oh,buffer:ft,cast:Fe,ceil:R3,clipByValue:hr,clone:io,complex:ll,concat:$n,concat1d:A3,concat2d:D3,concat3d:_3,concat4d:O3,conv1d:vS,conv2d:hl,conv2dTranspose:SS,conv3d:F3,conv3dTranspose:L3,cos:L0,cosh:CS,cosineWindow:KS,cumprod:ax,cumsum:NS,denseBincount:l2,depthToSpace:M3,depthwiseConv2d:Rm,diag:hU,dilation2d:P3,div:Ve,divNoNan:B3,dot:V3,dropout:dA,einsum:sh,elu:Am,enclosingPowerOfTwo:pA,ensureShape:wU,equal:ji,erf:kS,euclideanNorm:G3,exp:Ks,expandDims:Wn,expm1:H3,eye:IS,fft:Q0,fill:Nd,floor:_m,floorDiv:yS,fused:jH,gather:Om,gatherND:OH,greater:_r,greaterEqual:kl,ifft:mf,imag:M0,image:Xs,inTopKAsync:MH,irfft:WS,isFinite:j3,isInf:q3,isNaN:X3,leakyRelu:P0,less:df,lessEqual:Vu,linalg:wA,linspace:qU,localResponseNormalization:K3,log:Xr,log1p:B0,logSigmoid:Y3,logSoftmax:TS,logSumExp:V0,logicalAnd:wa,logicalNot:U0,logicalOr:ES,logicalXor:Q3,losses:C6,lowerBound:uW,matMul:kt,max:Ci,maxPool:W0,maxPool3d:Z3,maxPoolWithArgmax:pW,maximum:po,mean:Tn,meshgrid:gW,min:hf,minimum:pl,mirrorPad:AS,mod:J3,moments:G0,movingAverage:IH,mul:Q,multiRNNCell:SW,multinomial:NW,neg:gn,norm:Dm,notEqual:ph,oneHot:DS,ones:$r,onesLike:Kr,op:J,outerProduct:EW,pad:qi,pad1d:DW,pad2d:OW,pad3d:zW,pad4d:MW,pool:eA,pow:uo,prelu:j0,print:g3,prod:tA,raggedGather:jW,raggedRange:XW,raggedTensorToTensor:YW,rand:ZW,randomGamma:vG,randomNormal:OS,randomStandardNormal:CG,randomUniform:Uu,randomUniformInt:$G,range:fh,real:pf,reciprocal:nA,relu:Ia,relu6:FS,reshape:ae,reverse:$i,reverse1d:_G,reverse2d:FG,reverse3d:LG,reverse4d:PG,rfft:Z0,round:zS,rsqrt:LS,scalar:Je,scatterND:EH,searchSorted:RS,selu:MS,separableConv2d:PS,setdiff1dAsync:HG,sigmoid:qr,sign:sA,signal:S6,sin:BS,sinh:VS,slice:dt,slice1d:X0,slice2d:US,slice3d:K0,slice4d:ff,softmax:Y0,softplus:kd,spaceToBatchND:H0,sparse:N6,sparseToDense:DH,spectral:w6,split:Ir,sqrt:ks,square:tn,squaredDifference:GS,squeeze:Wt,stack:Tr,step:$d,stridedSlice:rA,string:k6,sub:Ue,sum:Ke,tan:iA,tanh:Ru,tensor:Wi,tensor1d:Gn,tensor2d:Ni,tensor3d:aA,tensor4d:hH,tensor5d:dH,tensor6d:pH,tensorScatterUpdate:mH,tile:bi,topk:lA,transpose:_t,truncatedNormal:jS,unique:uA,unsortedSegmentSum:qS,unstack:Ii,upperBound:wH,variable:cA,where:Fs,whereAsync:hA,zeros:zn,zerosLike:Ot},Symbol.toStringTag,{value:"Module"}));const jK=(n,e,t,s=$s)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(R("a",n,e,t),R("b",n,e,t))];case"AddN":return[s.addN(R("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(R("a",n,e,t),R("b",n,e,t))];case"Mul":return[s.mul(R("a",n,e,t),R("b",n,e,t))];case"RealDiv":case"Div":return[s.div(R("a",n,e,t),R("b",n,e,t))];case"DivNoNan":return[s.divNoNan(R("a",n,e,t),R("b",n,e,t))];case"FloorDiv":return[s.floorDiv(R("a",n,e,t),R("b",n,e,t))];case"Sub":return[s.sub(R("a",n,e,t),R("b",n,e,t))];case"Minimum":return[s.minimum(R("a",n,e,t),R("b",n,e,t))];case"Maximum":return[s.maximum(R("a",n,e,t),R("b",n,e,t))];case"Pow":return[s.pow(R("a",n,e,t),R("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(R("a",n,e,t),R("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const qK=(n,e,t,s=$s)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(R("x",n,e,t))];case"Acos":return[s.acos(R("x",n,e,t))];case"Acosh":return[s.acosh(R("x",n,e,t))];case"Asin":return[s.asin(R("x",n,e,t))];case"Asinh":return[s.asinh(R("x",n,e,t))];case"Atan":return[s.atan(R("x",n,e,t))];case"Atan2":return[s.atan2(R("x",n,e,t),R("y",n,e,t))];case"Atanh":return[s.atanh(R("x",n,e,t))];case"Ceil":return[s.ceil(R("x",n,e,t))];case"Complex":return[s.complex(R("real",n,e,t),R("imag",n,e,t))];case"Cos":return[s.cos(R("x",n,e,t))];case"Cosh":return[s.cosh(R("x",n,e,t))];case"Elu":return[s.elu(R("x",n,e,t))];case"Erf":return[s.erf(R("x",n,e,t))];case"Exp":return[s.exp(R("x",n,e,t))];case"Expm1":return[s.expm1(R("x",n,e,t))];case"Floor":return[s.floor(R("x",n,e,t))];case"Log":return[s.log(R("x",n,e,t))];case"Log1p":return[s.log1p(R("x",n,e,t))];case"Imag":return[s.imag(R("x",n,e,t))];case"Neg":return[s.neg(R("x",n,e,t))];case"Reciprocal":return[s.reciprocal(R("x",n,e,t))];case"Real":return[s.real(R("x",n,e,t))];case"Relu":return[s.relu(R("x",n,e,t))];case"Round":return[s.round(R("x",n,e,t))];case"Selu":return[s.selu(R("x",n,e,t))];case"Sigmoid":return[s.sigmoid(R("x",n,e,t))];case"Sin":return[s.sin(R("x",n,e,t))];case"Sign":return[s.sign(R("x",n,e,t))];case"Sinh":return[s.sinh(R("x",n,e,t))];case"Softplus":return[s.softplus(R("x",n,e,t))];case"Sqrt":return[s.sqrt(R("x",n,e,t))];case"Square":return[s.square(R("x",n,e,t))];case"Tanh":return[s.tanh(R("x",n,e,t))];case"Tan":return[s.tan(R("x",n,e,t))];case"ClipByValue":return[s.clipByValue(R("x",n,e,t),R("clipValueMin",n,e,t),R("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(R("x",n,e,t))];case"Rsqrt":return[s.rsqrt(Ss(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(R("x",n,e,t),R("alpha",n,e,t))];case"Prelu":return[s.prelu(R("x",n,e,t),R("alpha",n,e,t))];case"IsNan":return[s.isNaN(Ss(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(Ss(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(Ss(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function yi(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){B(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];B(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function WT(n){return!(typeof n=="number"||n.some(e=>e<0))}function Hp(n,e,t){let s=_2(n,t);const r=!WT(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=_2(i.shape,s)}),!WT(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function _2(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}class XK{constructor(e,t,s,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Je(0),ms(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),yi(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,ms(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Wi([],[0].concat(this.elementShape));const s=this.readMany(e);return yi(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Tr(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Wi([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return yi(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),$n(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Ii(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,a=[];he(()=>{t=ae(t,[1,s,i]);for(let u=0;u<e.length;++u){const d=[0,u===0?0:r[u-1],0],p=[1,e[u],i];a[u]=ae(dt(t,d,p),this.elementShape)}return a});const o=[];for(let u=0;u<e.length;u++)o[u]=u;this.writeMany(o,a)}}class _u{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);yi(t,i.shape,"TensorList shape mismatch: "),ms(i)}),this.idTensor=Je(0),this.maxNumElements=r,ms(this.idTensor)}copy(){return new _u([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);yi(e,this.elementShape,"TensorList shape mismatch: ");const r=Hp(this.elementShape,this.tensors,e);return he(()=>{const i=this.tensors.map(a=>ae(a,r));return Tr(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Hp(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,yi(r.shape,e,"TensorList shape mismatch: "),ae(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(yi(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ms(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new _u([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);yi(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Hp(this.elementShape,this.tensors,t);return ae(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);yi(this.elementShape,t.shape,"TensorList shape mismatch: "),ms(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);yi(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Hp(this.elementShape,this.tensors,s);return e.length===0?Wi([],[0].concat(r)):he(()=>{const i=e.map(a=>ae(this.tensors[a],r));return Tr(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);yi(this.elementShape,t,"TensorList shape mismatch: ");const s=Hp(this.elementShape,this.tensors,t);return this.size()===0?Wi([],[0].concat(s)):he(()=>{const r=this.tensors.map(i=>ae(i,s));return $n(r,0)})}}function KK(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);yi(r,e,"TensorList shape mismatch: ");const i=Ii(n);return new _u(i,e,s)}function YK(n,e,t,s){return new _u([],n,e,s)}function QK(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new _u([],t,n.dtype,s),a=Ii(n,0);return e.forEach((o,u)=>{i.setItem(o,a[u])}),i}function ZK(n,e,t){let s=0;const r=e.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),a=_2(i,t),o=s===0?0:n.size/s,u=he(()=>{const d=[];n=ae(n,[1,s,o]);for(let p=0;p<e.length;++p){const g=[0,p===0?0:r[p-1],0],x=[1,e[p],o];d[p]=ae(dt(n,g,x),a)}return n.dispose(),d}),c=new _u([],t,n.dtype,e.length);for(let d=0;d<u.length;d++)c.setItem(d,u[d]);return c}const JK=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=R("thenBranch",n,e,t),r=R("elseBranch",n,e,t),i=R("cond",n,e,t),a=R("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=R("body",n,e,t),r=R("cond",n,e,t),i=R("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),o=i.map(d=>d.id);let u=await a[0].data();a.forEach(d=>{!d.kept&&o.indexOf(d.id)===-1&&d.dispose()});let c=i;for(;u[0];){const d=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const p=c.map(g=>g.id);d.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()});const m=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const s=R("pred",n,e,t);return[no(s)]}case"Switch":{const s=R("pred",n,e,t);let r=R("data",n,e,t);return r.kept||(r=no(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>Ss(r,e,t)!==void 0);if(s){const r=Ss(s,e,t);return[no(r)]}return}case"Enter":{const s=R("frameName",n,e,t),r=R("tensor",n,e,t);return t.enterFrame(s),[no(r)]}case"Exit":{const s=R("tensor",n,e,t);return t.exitFrame(),[no(s)]}case"NextIteration":{const s=R("tensor",n,e,t);return t.nextIteration(),[no(s)]}case"TensorArrayV3":{const s=R("size",n,e,t),r=R("dtype",n,e,t),i=R("elementShape",n,e,t),a=R("dynamicSize",n,e,t),o=R("clearAfterRead",n,e,t),u=R("identicalElementShapes",n,e,t),c=R("name",n,e,t),d=new XK(c,r,s,i,u,a,o);return t.addTensorArray(d),[d.idTensor,Je(1)]}case"TensorArrayWriteV3":{const s=R("tensorArrayId",n,e,t),r=R("index",n,e,t),i=R("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,i),[a.idTensor]}case"TensorArrayReadV3":{const s=R("tensorArrayId",n,e,t),r=R("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=R("tensorArrayId",n,e,t),r=R("indices",n,e,t),i=R("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=R("tensorArrayId",n,e,t),r=R("indices",n,e,t),i=R("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=R("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=R("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=R("tensorArrayId",n,e,t),r=R("tensor",n,e,t),i=R("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(i,r),[a.idTensor]}case"TensorArraySizeV3":{const s=R("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Je(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=R("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=R("tensorListId",n,e,t),r=R("index",n,e,t),i=R("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,i),[a.idTensor]}case"TensorListGetItem":{const s=R("tensorListId",n,e,t),r=R("index",n,e,t),i=R("elementShape",n,e,t),a=R("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=R("indices",n,e,t),r=R("tensor",n,e,t),i=R("elementShape",n,e,t),a=R("numElements",n,e,t),o=QK(r,s,i,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=R("elementShape",n,e,t),r=R("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const a=R(i,n,e,t),o=n.op==="TensorListReserve"?-1:a,u=YK(s,r,a,o);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=R("tensorListId",n,e,t),r=R("indices",n,e,t),i=R("elementShape",n,e,t),a=R("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,i)]}case"TensorListStack":{const s=R("tensorListId",n,e,t),r=R("elementShape",n,e,t),i=R("elementDType",n,e,t),a=R("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,a)]}case"TensorListFromTensor":{const s=R("tensor",n,e,t),r=R("elementShape",n,e,t),i=R("elementDType",n,e,t),a=KK(s,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=R("tensorListId",n,e,t),r=t.getTensorList(s.id),i=R("dtype",n,e,t),a=R("elementShape",n,e,t);return[r.concat(i,a)]}case"TensorListPushBack":{const s=R("tensorListId",n,e,t),r=R("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=R("tensorListId",n,e,t),r=R("elementShape",n,e,t),i=R("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=R("tensor",n,e,t),r=R("elementShape",n,e,t),i=R("lengths",n,e,t),a=ZK(s,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=R("tensorListId",n,e,t),r=t.getTensorList(s.id);return[Je(r.size(),"int32")]}case"TensorListResize":{const s=R("tensorListId",n,e,t),r=R("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function GT(n,e,t){const[s,r]=R("fusedOps",n,e,t),i=s==="biasadd",a=!i,o=r==="prelu",u=s==="fusedbatchnorm",c=R("numArgs",n,e,t);if(i){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=R("strides",n,e,t),p=jy(n,e,t),m=R("dataFormat",n,e,t).toUpperCase(),g=R("dilations",n,e,t);let[x,b]=R("args",n,e,t);a&&(b=x,x=void 0);const v=R("leakyreluAlpha",n,e,t);return{stride:d,pad:p,dataFormat:m,dilations:g,biasArg:x,preluArg:b,activationFunc:r,leakyreluAlpha:v}}const e7=(n,e,t,s=$s)=>{switch(n.op){case"Conv1D":{const r=R("stride",n,e,t),i=R("pad",n,e,t),a=R("dataFormat",n,e,t).toUpperCase(),o=R("dilation",n,e,t);return[s.conv1d(R("x",n,e,t),R("filter",n,e,t),r,i,a,o)]}case"Conv2D":{const r=R("strides",n,e,t),i=jy(n,e,t),a=R("dataFormat",n,e,t).toUpperCase(),o=R("dilations",n,e,t);return[s.conv2d(R("x",n,e,t),R("filter",n,e,t),[r[1],r[2]],i,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:u,preluArg:c,activationFunc:d,leakyreluAlpha:p}=GT(n,e,t);return[s.fused.conv2d({x:R("x",n,e,t),filter:R("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:c,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:u,preluArg:c,activationFunc:d,leakyreluAlpha:p}=GT(n,e,t);return[s.fused.depthwiseConv2d({x:R("x",n,e,t),filter:R("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:c,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=R("outputShape",n,e,t),i=R("strides",n,e,t),a=jy(n,e,t);return[s.conv2dTranspose(R("x",n,e,t),R("filter",n,e,t),r,[i[1],i[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=R("strides",n,e,t),i=jy(n,e,t),a=R("dilations",n,e,t),o=R("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(R("input",n,e,t),R("filter",n,e,t),[r[1],r[2]],i,o,[a[1],a[2]])]}case"Conv3D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("dataFormat",n,e,t).toUpperCase(),o=R("dilations",n,e,t);return[s.conv3d(R("x",n,e,t),R("filter",n,e,t),[r[1],r[2],r[3]],i,a,[o[1],o[2],o[3]])]}case"AvgPool":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.avgPool(R("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.maxPool(R("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t),o=R("includeBatchInIndex",n,e,t),{result:u,indexes:c}=s.maxPoolWithArgmax(R("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i,o);return[u,c]}case"AvgPool3D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.avgPool3d(R("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("kernelSize",n,e,t);return[s.maxPool3d(R("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=R("strides",n,e,t),i=R("pad",n,e,t),a=R("dilations",n,e,t),o=r[1],u=r[2],c=a[1],d=a[2];return[s.dilation2d(R("x",n,e,t),R("filter",n,e,t),[o,u],i,[c,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const t7=(n,e,t,s=$s)=>{switch(n.op){case"Fill":{const r=R("shape",n,e,t),i=R("dtype",n,e,t),a=R("value",n,e,t);return[s.fill(r,a,i)]}case"LinSpace":{const r=R("start",n,e,t),i=R("stop",n,e,t),a=R("num",n,e,t);return[s.linspace(r,i,a)]}case"Multinomial":{const r=R("logits",n,e,t),i=R("numSamples",n,e,t),a=R("seed",n,e,t);return[s.multinomial(r,i,a)]}case"OneHot":{const r=R("indices",n,e,t),i=R("depth",n,e,t),a=R("onValue",n,e,t),o=R("offValue",n,e,t),u=R("dtype",n,e,t);return[s.oneHot(r,i,a,o,u)]}case"Ones":return[s.ones(R("shape",n,e,t),R("dtype",n,e,t))];case"OnesLike":return[s.onesLike(R("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(R("shape",n,e,t),R("dtype",n,e,t),R("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(R("shape",n,e,t),R("minval",n,e,t),R("maxval",n,e,t),R("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(R("shape",n,e,t),R("minval",n,e,t),R("maxval",n,e,t),R("seed",n,e,t))];case"Range":{const r=R("start",n,e,t),i=R("stop",n,e,t),a=R("step",n,e,t);return[s.range(r,i,a,R("dtype",n,e,t))]}case"TruncatedNormal":{const r=R("shape",n,e,t),i=R("mean",n,e,t),a=R("stdDev",n,e,t),o=R("seed",n,e,t);return[s.truncatedNormal(r,i,a,R("dtype",n,e,t),o)]}case"Zeros":return[s.zeros(R("shape",n,e,t),R("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(R("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Cw(n,e,t){const s=R("boxes",n,e,t),r=R("scores",n,e,t),i=R("maxOutputSize",n,e,t),a=R("iouThreshold",n,e,t),o=R("scoreThreshold",n,e,t),u=R("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:u}}const n7=async(n,e,t,s,r=$s)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:c,softNmsSigma:d}=Cw(n,e,t),p=await r.image.nonMaxSuppressionWithScoreAsync(i,a,o,u,c,d);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:c}=Cw(n,e,t),d=R("padToMaxOutputSize",n,e,t),p=await r.image.nonMaxSuppressionPaddedAsync(i,a,o,u,c,d);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:c}=Cw(n,e,t);return[await r.image.nonMaxSuppressionAsync(i,a,o,u,c)]}case"Where":{const i=r.cast(R("condition",n,e,t),"bool"),a=[await r.whereAsync(i)];return i.dispose(),a}case"ListDiff":return r.setdiff1dAsync(R("x",n,e,t),R("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const s7=(n,e,t,s=$s)=>{switch(n.op){case"LowerBound":{const r=R("sortedSequence",n,e,t),i=R("values",n,e,t);return[s.lowerBound(r,i)]}case"TopKV2":{const r=R("x",n,e,t),i=R("k",n,e,t),a=R("sorted",n,e,t),o=s.topk(r,i,a);return[o.values,o.indices]}case"UpperBound":{const r=R("sortedSequence",n,e,t),i=R("values",n,e,t);return[s.upperBound(r,i)]}case"Unique":{const r=R("x",n,e,t),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=R("x",n,e,t),i=R("axis",n,e,t),a=s.unique(r,i);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const r7=(n,e,t,s=$s)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=R("default",n,e,t);return[Ss(n.name,e,t)||r];case"Placeholder":return[Ss(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=R("x",n,e,t);return[no(d)]}case"IdentityN":return R("x",n,e,t).map(d=>no(d));case"Snapshot":const i=R("x",n,e,t);return[no(i)];case"Shape":return[s.tensor1d(R("x",n,e,t).shape,"int32")];case"ShapeN":return R("x",n,e,t).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar(R("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(R("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=R("x",n,e,t),o=R("data",n,e,t),u=R("message",n,e,t),c=R("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,c));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class i7{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Je(0),this.tensorMap=new Map,ms(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Je(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),he(()=>{const r=Ii(t),i=s.length,a=r.length;B(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){const u=s[o],c=r[o];ms(c),this.tensorMap.set(u,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return he(()=>{const r=[];for(let i=0;i<s.length;i++){const a=s[i],o=this.findWithDefault(a,t);r.push(o)}return Tr(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const a7=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=R("keyDType",n,e,t),a=R("valueDType",n,e,t),o=new i7(i,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=R("tableHandle",n,e,t,s),i=R("keys",n,e,t),a=R("values",n,e,t);return[await s.getHashTableById(r.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=R("tableHandle",n,e,t,s),i=R("keys",n,e,t),a=R("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=R("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const o7=(n,e,t,s=$s)=>{switch(n.op){case"ResizeBilinear":{const r=R("images",n,e,t),i=R("size",n,e,t),a=R("alignCorners",n,e,t),o=R("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[i[0],i[1]],a,o)]}case"ResizeNearestNeighbor":{const r=R("images",n,e,t),i=R("size",n,e,t),a=R("alignCorners",n,e,t),o=R("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],a,o)]}case"CropAndResize":{const r=R("image",n,e,t),i=R("boxes",n,e,t),a=R("boxInd",n,e,t),o=R("cropSize",n,e,t),u=R("method",n,e,t),c=R("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,i,a,o,u,c)]}case"ImageProjectiveTransformV3":{const r=R("images",n,e,t),i=R("transforms",n,e,t),a=R("outputShape",n,e,t),o=R("fillValue",n,e,t),u=R("interpolation",n,e,t),c=R("fillMode",n,e,t);return[s.image.transform(r,i,u.toLowerCase(),c.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const l7=(n,e,t,s=$s)=>{switch(n.op){case"Equal":return[s.equal(R("a",n,e,t),R("b",n,e,t))];case"NotEqual":return[s.notEqual(R("a",n,e,t),R("b",n,e,t))];case"Greater":return[s.greater(R("a",n,e,t),R("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(R("a",n,e,t),R("b",n,e,t))];case"Less":return[s.less(R("a",n,e,t),R("b",n,e,t))];case"LessEqual":return[s.lessEqual(R("a",n,e,t),R("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(R("a",n,e,t),R("b",n,e,t))];case"LogicalNot":return[s.logicalNot(R("a",n,e,t))];case"LogicalOr":return[s.logicalOr(R("a",n,e,t),R("b",n,e,t))];case"Select":case"SelectV2":return[s.where(R("condition",n,e,t),R("a",n,e,t),R("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(R("a",n,e,t),R("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const u7=(n,e,t,s=$s)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(R("a",n,e,t),R("b",n,e,t),R("transposeA",n,e,t),R("transposeB",n,e,t))];case"Einsum":return[s.einsum(R("equation",n,e,t),...R("tensors",n,e,t))];case"Transpose":return[s.transpose(R("x",n,e,t),R("perm",n,e,t))];case"_FusedMatMul":const[r,i]=R("fusedOps",n,e,t),a=r==="biasadd",o=i==="prelu",u=R("numArgs",n,e,t),c=R("leakyreluAlpha",n,e,t);if(a){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,p]=R("args",n,e,t);return[s.fused.matMul({a:R("a",n,e,t),b:R("b",n,e,t),transposeA:R("transposeA",n,e,t),transposeB:R("transposeB",n,e,t),bias:d,activation:i,preluActivationWeights:p,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(R("a",n,e,t),R("numLower",n,e,t),R("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const c7=(n,e,t,s=$s)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(R("x",n,e,t),R("axis",n,e,t),R("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(R("x",n,e,t),R("mean",n,e,t),R("variance",n,e,t),R("offset",n,e,t),R("scale",n,e,t),R("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(R("x",n,e,t),R("mean",n,e,t),R("variance",n,e,t),R("offset",n,e,t),R("scale",n,e,t),R("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(R("x",n,e,t),R("radius",n,e,t),R("bias",n,e,t),R("alpha",n,e,t),R("beta",n,e,t))];case"Softmax":return[s.softmax(R("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(R("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const h7=(n,e,t,s=$s)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(R("paramsNestedSplits",n,e,t),R("paramsDenseValues",n,e,t),R("indices",n,e,t),R("outputRaggedRank",n,e,t));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(R("starts",n,e,t),R("limits",n,e,t),R("splits",n,e,t));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(R("shape",n,e,t),R("values",n,e,t),R("defaultValue",n,e,t),R("rowPartitionTensors",n,e,t),R("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const d7=(n,e,t,s=$s)=>{switch(n.op){case"Max":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.max(R("x",n,e,t),o,u)]}case"Mean":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.mean(R("x",n,e,t),o,u)]}case"Min":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.min(R("x",n,e,t),o,u)]}case"Sum":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.sum(R("x",n,e,t),o,u)]}case"All":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.all(R("x",n,e,t),o,u)]}case"Any":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.any(R("x",n,e,t),o,u)]}case"ArgMax":{const o=R("axis",n,e,t);return[s.argMax(R("x",n,e,t),o)]}case"ArgMin":{const o=R("axis",n,e,t);return[s.argMin(R("x",n,e,t),o)]}case"Prod":{const o=R("axis",n,e,t),u=R("keepDims",n,e,t);return[s.prod(R("x",n,e,t),o,u)]}case"Cumprod":{const o=R("axis",n,e,t),u=R("exclusive",n,e,t),c=R("reverse",n,e,t);return[s.cumprod(R("x",n,e,t),o,u,c)]}case"Cumsum":{const o=R("axis",n,e,t),u=R("exclusive",n,e,t),c=R("reverse",n,e,t);return[s.cumsum(R("x",n,e,t),o,u,c)]}case"Bincount":const r=R("x",n,e,t),i=R("weights",n,e,t),a=R("size",n,e,t);return[s.bincount(r,i,a)];case"DenseBincount":{const o=R("x",n,e,t),u=R("weights",n,e,t),c=R("size",n,e,t),d=R("binaryOutput",n,e,t);return[s.denseBincount(o,u,c,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const p7=(n,e,t,s=$s)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=R("n",n,e,t),i=R("axis",n,e,t);let a=R("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,i)]}case"Gather":{const r=R("x",n,e,t),i=R("indices",n,e,t);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=R("axis",n,e,t),i=R("batchDims",n,e,t),a=R("x",n,e,t),o=R("indices",n,e,t);return[s.gather(a,s.cast(o,"int32"),r,i)]}case"Reverse":{const r=R("dims",n,e,t),i=[];for(let o=0;o<r.length;o++)r[o]&&i.push(o);const a=R("x",n,e,t);return[s.reverse(a,i)]}case"ReverseV2":{const r=R("axis",n,e,t),i=R("x",n,e,t);return[s.reverse(i,r)]}case"Slice":{const r=R("begin",n,e,t),i=R("size",n,e,t);return[s.slice(R("x",n,e,t),r,i)]}case"StridedSlice":{const r=R("begin",n,e,t),i=R("end",n,e,t),a=R("strides",n,e,t),o=R("beginMask",n,e,t),u=R("endMask",n,e,t),c=R("ellipsisMask",n,e,t),d=R("newAxisMask",n,e,t),p=R("shrinkAxisMask",n,e,t),m=R("x",n,e,t);return[s.stridedSlice(m,r,i,a,o,u,c,d,p)]}case"Pack":return he(()=>{const r=R("axis",n,e,t),i=R("tensors",n,e,t),a=i[0].shape,o=s.squeeze(i[0]).shape,u=i.map(c=>{const d=xt(c.shape,a);if(!d&&!xt(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return d?c:s.reshape(c,a)});return[s.stack(u,r)]});case"Unpack":{const r=R("axis",n,e,t),i=R("tensor",n,e,t);return s.unstack(i,r)}case"Tile":{const r=R("reps",n,e,t);return[s.tile(R("x",n,e,t),r)]}case"Split":case"SplitV":{const r=R("axis",n,e,t),i=R("numOrSizeSplits",n,e,t),a=R("x",n,e,t);return s.split(a,i,r)}case"ScatterNd":{const r=R("indices",n,e,t),i=R("values",n,e,t),a=R("shape",n,e,t);return[s.scatterND(r,i,a)]}case"GatherNd":{const r=R("x",n,e,t),i=R("indices",n,e,t);return[s.gatherND(r,i)]}case"SparseToDense":{const r=R("sparseIndices",n,e,t),i=R("outputShape",n,e,t),a=R("sparseValues",n,e,t),o=R("defaultValue",n,e,t);return[s.sparseToDense(r,a,i,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}case"TensorScatterUpdate":{const r=R("indices",n,e,t),i=R("values",n,e,t),a=R("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const f7=(n,e,t,s=$s)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(R("indices",n,e,t),R("values",n,e,t),R("denseShape",n,e,t),R("defaultValue",n,e,t));return[r,i,a,o]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(R("inputIndices",n,e,t),R("inputShape",n,e,t),R("newShape",n,e,t));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(R("data",n,e,t),R("indices",n,e,t),R("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(R("data",n,e,t),R("indices",n,e,t),R("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const m7=(n,e,t,s=$s)=>{switch(n.op){case"FFT":return[s.fft(R("x",n,e,t))];case"IFFT":return[s.ifft(R("x",n,e,t))];case"RFFT":return[s.rfft(R("x",n,e,t))];case"IRFFT":return[s.irfft(R("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const g7=(n,e,t,s=$s)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(R("input",n,e,t),R("pattern",n,e,t),R("rewrite",n,e,t),R("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(R("data",n,e,t),R("dataSplits",n,e,t),R("separator",n,e,t),R("nGramWidths",n,e,t),R("leftPad",n,e,t),R("rightPad",n,e,t),R("padWidth",n,e,t),R("preserveShortSequences",n,e,t));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:a}=s.string.stringSplit(R("input",n,e,t),R("delimiter",n,e,t),R("skipEmpty",n,e,t));return[r,i,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(R("input",n,e,t),R("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const y7=(n,e,t,s=$s)=>{switch(n.op){case"Cast":return[s.cast(R("x",n,e,t),R("dtype",n,e,t))];case"ExpandDims":{const r=R("axis",n,e,t);return[s.expandDims(R("x",n,e,t),r)]}case"Squeeze":{const r=R("axis",n,e,t);return[s.squeeze(R("x",n,e,t),r)]}case"Reshape":return[s.reshape(R("x",n,e,t),R("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(R("x",n,e,t),R("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(R("x",n,e,t),R("padding",n,e,t),R("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(R("x",n,e,t),R("padding",n,e,t),R("constantValue",n,e,t))];case"SpaceToBatchND":{const r=R("blockShape",n,e,t),i=R("paddings",n,e,t);return[s.spaceToBatchND(R("x",n,e,t),r,i)]}case"BatchToSpaceND":{const r=R("blockShape",n,e,t),i=R("crops",n,e,t);return[s.batchToSpaceND(R("x",n,e,t),r,i)]}case"DepthToSpace":{const r=R("blockSize",n,e,t),i=R("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(R("x",n,e,t),r,i)]}case"BroadcastTo":return[s.broadcastTo(R("x",n,e,t),R("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(R("s0",n,e,t),R("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function HT(n,e,t,s,r=he){const i=((a,o,u)=>{switch(a.category){case"arithmetic":return r(()=>jK(a,o,u));case"basic_math":return r(()=>qK(a,o,u));case"control":return JK(a,o,u);case"convolution":return r(()=>e7(a,o,u));case"creation":return r(()=>t7(a,o,u));case"dynamic":return n7(a,o,u);case"evaluation":return r(()=>s7(a,o,u));case"image":return r(()=>o7(a,o,u));case"graph":return r(()=>r7(a,o,u));case"logical":return r(()=>l7(a,o,u));case"matrices":return r(()=>u7(a,o,u));case"normalization":return r(()=>c7(a,o,u));case"ragged":return r(()=>h7(a,o,u));case"reduction":return r(()=>d7(a,o,u));case"slice_join":return r(()=>p7(a,o,u));case"sparse":return r(()=>f7(a,o,u));case"spectral":return r(()=>m7(a,o,u));case"string":return r(()=>g7(a,o,u));case"transformation":return r(()=>y7(a,o,u));case"hash_table":return a7(a,o,u,s);case"custom":const c=RO(a.op);if(c&&c.customExecutor)return c.customExecutor(new HK(a,o,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Cu(i)?i.then(a=>[].concat(a)):[].concat(i)}class jT{constructor(e={},t={},s={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function qT(n,e,t,s){const r=new Set,i=[];let a=null,o=null;const u=new Set,c=new Set(Object.keys(n).map(m=>Nr(m)[0]));s=s||[];const d=new Set(s.map(m=>Nr(m.name)[0])),p=[...e];for(;p.length>0;){const m=p.pop();if((hu(m)||k7(m)||$7(m))&&a==null&&(a=m,o=a.children.map(g=>g.name).filter(g=>r.has(g))),r.add(m.name),t[m.name]==null&&!c.has(m.name)&&!d.has(m.name)){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(g=>{u.has(g.name)||(u.add(g.name),p.push(g))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:a,syncInputs:o}}function x7(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(v=>Nr(v)[0]).map(v=>n.nodes[v]),i=n.initNodes||[],a=v=>t.has(typeof v=="string"?v:v.name);function o(v){return[...new Map(v.map(w=>[w.name,w])).values()]}const u=o([...r,...n.weights,...i]).filter(a),c=o([...u,...Object.values(n.nodes)]).filter(a),d=new Map(c.map(v=>[v.name,v])),p={};for(const v of c){p[v.name]=p[v.name]||0;for(const w of v.children)a(w)||(p[w.name]=Number.POSITIVE_INFINITY),p[w.name]=(p[w.name]||0)+1}const m=Object.entries(p).filter(([,v])=>v===0).map(([v])=>v),g=[...m];for(;m.length>0;){const v=m.pop(),w=d.get(v);for(const N of w.children.filter(a))--p[N.name]===0&&(g.push(N.name),m.push(N.name))}const x=g.map(v=>d.get(v)),b=b7(x,u);return v7(b,u),b}function b7(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),o=t.get(a);for(const u of o.children)!t.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(a=>r.has(a.name))}class ky extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function v7(n,e){const t=new Map(n.map((o,u)=>[o.name,u])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),i=new Set(n.map(o=>o.name)),a=o=>i.has(typeof o=="string"?o:o.name);for(const o of n){for(const u of o.children.filter(a)){if(!t.has(u.name))throw new ky(`Child ${u.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(u.name))throw new ky(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(const u of o.inputs){if(!t.has(u.name))throw new ky(`Input ${u.name} of node ${o.name} is unreachable.`);if(t.get(u.name)>t.get(o.name))throw new ky(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function w7(n){const e=new Map(n.map((o,u)=>[o.name,u])),t=Number.MAX_SAFE_INTEGER,s=n.map((o,u)=>hu(o)?t:u),r=o=>{const u=s[e.get(o.name)];return u??-1},i=n.map((o,u)=>o.children.map(r).reduce((c,d)=>Math.max(c,d),s[u])),a=new Map;for(let o=0;o<n.length;++o){const u=i[o];if(u===t)continue;const c=n[o],d=n[u];a.has(d.name)||a.set(d.name,[]),a.get(d.name).push(c)}return a}const S7=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),C7=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),N7=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function hu(n){return S7.has(n.op)}function k7(n){return C7.has(n.op)}function $7(n){return N7.has(n.op)}class yx{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new yx(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=qT(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:a}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const c=t.map(p=>p.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=x7(this.graph,s),u=w7(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return ms(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(m=>this.graph.nodes[Nr(m)[0]]),i=t.map(m=>Nr(m)[0]),a=new Set(i);let o=i.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(r,o);let c=this.compiledMap.get(u);c==null&&(c=this.compile(e,o),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=fe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const d={},p={};return he(()=>{const m=new jT(this.weightMap,d,p,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(w=>{const[N,I]=Nr(w,m),$=[];$[I]=e[w],g[N]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[N]=this.cloneTensorList($))});const x=this.getFrozenTensorIds(g),{orderedNodes:b,nodeLiveUntilMap:v}=c;for(const w of b){if(g[w.name])continue;const N=HT(w,g,m,this._resourceManager);if(Cu(N))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);g[w.name]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[w.name]=this.cloneTensorList(N)),this.checkTensorForDisposalWithNodeLiveUntilInfo(w,g,m,x,a,v.get(w.name))}return this.parent==null&&m.dispose(x),t.map(w=>Ss(w,g,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,a,o){if(!(hu(t)||a.has(e))){for(const u of s[e])u!=null&&(o[u.id]=(o[u.id]||0)+t.children.length);for(const u of t.inputs){if(hu(u))continue;const c=BT(u.name,s,r);if(c!=null)for(const d of c){if(!d||d.kept||i.has(d.id))continue;const p=o[d.id];p===1?(d.dispose(),delete o[d.id]):p!=null&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,i,a){function o(u){return hu(u)||i.has(u.name)}if(!(hu(e)||a==null))for(const u of a){if(o(u))continue;const c=BT(u.name,t,s);for(const d of c)!d||d.kept||r.has(d.id)||d.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=fe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const a=new jT(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,s),u=t.map(m=>Ss(m,o,a)),c=u.map(m=>m.id),d=Object.keys(e).map(m=>e[m].id),p=new Set([...c,...d,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(g=>{g&&!g.isDisposed&&!p.has(g.id)&&g.dispose()})}),this.parent==null&&a.dispose(p),u}async executeFunctionAsync(e,t,s){const r=e.reduce((i,a,o)=>(i[this.inputs[o].name]=a,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),a=i.map($=>this.graph.nodes[Nr($)[0]]),o=s.map($=>Nr($)[0]),u=new Set(o);let c=o.map($=>this.graph.nodes[$]);c.length===0&&(c=this._outputs);const{usedNodes:d,missingInputs:p,dynamicNode:m,syncInputs:g}=qT(e,c,this.weightMap,this._initNodes),x=[...a,...this.graph.weights,...this._initNodes||[]].map($=>({node:$,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach($=>{const[E,D]=Nr($),F=[];F[D]=e[$],b[E]=F});const v={},w=this.getFrozenTensorIds(b),N={};for(;x.length>0;){const $=this.processStack(a,x,t,b,N,w,u,v,d);await Promise.all($)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=c.filter($=>!hu($)&&!Ss($.name,b,t)).map($=>$.name);if(I.length>0){let $="";throw m!=null&&($=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${i}]. Consider providing the following inputs: [${p}]. ${$}`)}return b}processStack(e,t,s,r,i,a,o,u,c){const d=[];for(;t.length>0;){const p=t.pop();s.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&R("isConstant",p.node,r,s)&&([m]=to(p.node.name,s)),r[p.node.name]==null){const g=HT(p.node,r,s,this._resourceManager);m||([m]=to(p.node.name,s));const x=s.currentContext;Cu(g)?d.push(g.then(b=>(r[m]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(b)),s.currentContext=x,this.checkTensorForDisposal(m,p.node,r,s,a,o,u),this.processChildNodes(p.node,t,s,r,i,c),b))):(r[m]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(g)),this.checkTensorForDisposal(m,p.node,r,s,a,o,u),this.processChildNodes(p.node,t,s,r,i,c))}else this.processChildNodes(p.node,t,s,r,i,c)}return d}processChildNodes(e,t,s,r,i,a){e.children.forEach(o=>{const[u]=to(o.name,s);i[u]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!Ss(c,r,s))&&(i[u]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!Ss(c,r,s))&&(i[u]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Nr(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const a=i.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((u,c)=>a[c]===-1||a[c]===u);B(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&B(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const i in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];a!=null?r[a.name]=e[i]:r[i]=e[i]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Nr(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Nr(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class I7{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const T7="?tfjs-format=file",E7="model.json";class R7{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=_A){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new I7}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Cu(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await r3(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new yx(VT.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=VT.Instance.transformGraph(e.modelInitializer);this.initializer=new yx(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Kt?[e]:e,s={};return t.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Kt)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const a in i){const o=i[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,a)=>{var o,u,c;const d=(c=(u=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||u===void 0?void 0:u[a])===null||c===void 0?void 0:c.resourceId;return d!=null?i[a]=this.resourceIdToCapturedInput[d]:i[a]=e[r++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const i=s[r],a=t[i];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&rt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function gh(n,e={},t=_A){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=A7(n));const s=new R7(n,e,t);return await s.load(),s}function A7(n){return n.endsWith("/")||(n=n+"/"),`${n}${E7}${T7}`}var XT;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(XT||(XT={}));function Ye(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const D7=XS;class Lb extends Fx{nextDataId(){return Lb.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Q2(this,Gs())}write(e,t,s){this.firstUse&&(this.firstUse=!1,fe().get("IS_NODE")&&Hr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ih(s[0])){const i=s.map(a=>ro(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Xi(r,i)}return zy(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Hi(r));return ft(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(e.shape,e.dtype,t)}makeOutput(e,t,s){return Gs().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=ir();return e(),{kernelMs:ir()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ye([e],"where");const t=this.readSync(e.dataId);return D7(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Lb.nextDataId=0;function _O(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const _7=n=>{const{x:e}=n.inputs,t=n.backend;Ye(e,"abs");let s=new Float32Array(ce(e.shape));const r=t.data.get(e.dataId).values;return s=_O(r),t.makeOutput(s,e.shape,e.dtype)},O7={kernelName:If,backendName:"cpu",kernelFunc:_7};function Bn(n){return(e,t,s,r,i)=>{const a=it(e,t),o=a.length,u=Ze(a),c=ce(a),d=ss(i,c),p=e.length,m=t.length,g=Ze(e),x=Ze(t),b=dl(e,a),v=dl(t,a);if(b.length+v.length===0)for(let w=0;w<d.length;++w)d[w]=n(s[w%s.length],r[w%r.length]);else for(let w=0;w<d.length;++w){const N=Th(w,o,u),I=N.slice(-p);b.forEach(F=>I[F]=0);const $=ya(I,p,g),E=N.slice(-m);v.forEach(F=>E[F]=0);const D=ya(E,m,x);d[w]=n(s[$],r[D])}return[d,a]}}function kr(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),u=t.data.get(o.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",a)},o}const F7={kernelName:Wx,backendName:"cpu",kernelFunc:kr};function xx(n,e,t="float32"){if(t==="complex64"){const r=xx(n,e,"float32"),i=xx(n,e,"float32");return kr({inputs:{real:r,imag:i},backend:n})}const s=Ns(ce(e),t);return n.makeTensorInfo(e,t,s)}function Ca(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const z7={kernelName:Kh,backendName:"cpu",kernelFunc:Ca};function Ou(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const L7={kernelName:y0,backendName:"cpu",kernelFunc:Ou};function OO(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Bu([0],t),[i,a]=Bn((o,u)=>o!==u?1:0)(e,[],n,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function xl(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Ca({inputs:{x:r},backend:t});const d=xx(t,r.shape,r.dtype),p=xl({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=kr({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){const d=Ou({inputs:{input:r},backend:t}),p=xl({inputs:{x:d},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(d),p}if(!eS(r.dtype,i)){const d=Ca({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:i}}const a=t.data.get(r.dataId).values,[o,u,c]=OO(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,u,c)}const M7={kernelName:zh,backendName:"cpu",kernelFunc:xl};function as(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a,b:o}=r,u=i;Ye([a,o],n);const c=u.data.get(a.dataId).values,d=u.data.get(o.dataId).values,p=a.dtype==="string"?Ki(c):c,m=a.dtype==="string"?Ki(d):d,g=s||a.dtype,[x,b]=e(a.shape,o.shape,p,m,g);return u.makeTensorInfo(b,g,x)}:({inputs:r,backend:i})=>{const{a,b:o}=r,u=i;if(a.dtype==="complex64"||o.dtype==="complex64"){const c=xl({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(c.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,g=u.data.get(p.dataId).values,x=u.data.get(m.dataId).values,b=xl({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),v=u.data.get(b.dataId),w=v.complexTensorInfos.real,N=v.complexTensorInfos.imag,I=u.data.get(w.dataId).values,$=u.data.get(N.dataId).values,[E,D,F]=t(a.shape,o.shape,g,x,I,$),L=u.makeTensorInfo(F,"float32",E),z=u.makeTensorInfo(F,"float32",D),M=kr({inputs:{real:L,imag:z},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(b),u.disposeIntermediateTensorInfo(L),u.disposeIntermediateTensorInfo(z),M}else{const c=u.data.get(a.dataId).values,d=u.data.get(o.dataId).values,p=s||a.dtype,[m,g]=e(a.shape,o.shape,c,d,p);return u.makeTensorInfo(g,p,m)}}}function AC(n){return(e,t,s,r,i,a)=>{const o=it(e,t),u=ce(o),c=o.length,d=Ze(o),p=ss("float32",u),m=ss("float32",u),g=dl(e,o),x=dl(t,o),b=Xi(s,r),v=Xi(i,a),w=e.length,N=Ze(e),I=t.length,$=Ze(t);if(g.length+x.length===0)for(let E=0;E<p.length;E++){const D=E%b.length,F=E%v.length,L=n(b[D*2],b[D*2+1],v[F*2],v[F*2+1]);p[E]=L.real,m[E]=L.imag}else for(let E=0;E<p.length;E++){const D=Th(E,c,d),F=D.slice(-w);g.forEach(H=>F[H]=0);const L=ya(F,w,N),z=D.slice(-I);x.forEach(H=>z[H]=0);const M=ya(z,I,$),O=n(b[L*2],b[L*2+1],v[M*2],v[M*2+1]);p[E]=O.real,m[E]=O.imag}return[p,m,o]}}const FO=Bn(((n,e)=>n+e)),P7=AC(((n,e,t,s)=>({real:n+t,imag:e+s}))),yh=as(Pu,FO,P7),B7={kernelName:Pu,backendName:"cpu",kernelFunc:yh};function DC(n,e,t,s,r){const i=ce(s),a=Ns(r,t);for(let o=0;o<n.length;o++){const u=n[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i>0?a[u]+=e[o]:a[u]+=1)}return a}function zO(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],a=ft([r,t],e.dtype);for(let o=0;o<r;o++)for(let u=0;u<i;u++){const c=n.get(o,u);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?a.set(1,o,c):e.size>0?a.set(a.get(o,c)+e.get(o,u),o,c):a.set(a.get(o,c)+1,o,c))}return a}const LO=Bn(((n,e)=>n&e)),V7=as(Vx,LO),U7={kernelName:Vx,backendName:"cpu",kernelFunc:V7};function Ea(n){return(e,t,s)=>{const r=En(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}function Qt(n,e,t){const s=Ea(e);return Tl(n,s,t)}function Tl(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;Ye(a,n);const o=i,u=o.data.get(a.dataId).values;let c;if(a.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=Ki(u)}else c=u;const d=t||a.dtype,p=e(c,d,r);return o.makeTensorInfo(a.shape,d,p)}}const MO=Ea(n=>Math.ceil(n)),W7=Tl(Lh,MO),G7={kernelName:Lh,backendName:"cpu",kernelFunc:W7};function PO(n,e,t,s){const r=En(t,ce(e));if(s&&t!=="string"){let i=0;n.forEach(a=>{const o=ce(a.shape);r.set(a.vals,i),i+=o})}else{let i=0;n.forEach(a=>{const o=t==="string"?Ki(a.vals):a.vals;let u=0;for(let c=0;c<a.shape[0];++c){const d=c*e[1]+i;for(let p=0;p<a.shape[1];++p)r[d+p]=o[u++]}i+=a.shape[1]})}return r}const BO=Bn((n,e)=>n===e?1:0),VO=as(Wf,BO,null,"bool"),H7={kernelName:Wf,backendName:"cpu",kernelFunc:VO};const UO=Ea(n=>Math.exp(n)),WO=Tl(Gh,UO,"float32"),j7={kernelName:Gh,backendName:"cpu",kernelFunc:WO};const GO=Ea(n=>Math.expm1(n)),q7=Tl(Hh,GO),X7={kernelName:Hh,backendName:"cpu",kernelFunc:q7};const HO=Ea(n=>Math.floor(n)),K7=Tl(jh,HO),Y7={kernelName:jh,backendName:"cpu",kernelFunc:K7};const jO=Bn((n,e)=>Math.floor(n/e)),Q7=as(qh,jO,null,"int32"),Z7={kernelName:qh,backendName:"cpu",kernelFunc:Q7};function qO(n,e,t,s,r,i,a,o,u){const c=ft([s,i],t);for(let d=0;d<s;d++){const p=[];let m=0;for(let g=0;g<r;g++){const x=n[d*r+g];m+=x*a[g],p.push(x)}if(m<0||m>=u/i)throw new Error(`Invalid indices: ${p} does not index into ${o}`);for(let g=0;g<i;g++)c.values[d*i+g]=e.get(...e.indexToLoc(m*i+g))}return c}function XO(n,e,t){const s=ft(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),o=a[0],u=a[2],c=e.locToIndex([o,u]);a[2]=e.values[c];const d=n.locToIndex(a);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const KO=Bn((n,e)=>n>e?1:0),J7=as(qf,KO,null,"bool"),e9={kernelName:qf,backendName:"cpu",kernelFunc:J7};const YO=Bn((n,e)=>n>=e?1:0),t9=as(Xh,YO,null,"bool"),n9={kernelName:Xh,backendName:"cpu",kernelFunc:t9};const QO=Bn((n,e)=>n<e?1:0),s9=as(Kf,QO,null,"bool"),r9={kernelName:Kf,backendName:"cpu",kernelFunc:s9};const ZO=Bn((n,e)=>n<=e?1:0),i9=as(Yf,ZO,null,"bool"),a9={kernelName:Yf,backendName:"cpu",kernelFunc:i9};function JO(n,e,t){const s=(e-n)/(t-1),r=Ns(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const eF=Ea(n=>Math.log(n)),o9=Tl(Jh,eF),l9={kernelName:Jh,backendName:"cpu",kernelFunc:o9};function tF(n,e,t,s){const r=ss(s,ce(t));for(let i=0;i<r.length;++i){const a=i*e;let o=n[a];for(let u=0;u<e;++u){const c=n[a+u];(Number.isNaN(c)||c>o)&&(o=c)}r[i]=o}return r}const nF=Bn(((n,e)=>Math.max(n,e))),u9=as(td,nF),c9={kernelName:td,backendName:"cpu",kernelFunc:u9};const sF=Bn(((n,e)=>Math.min(n,e))),h9=as(nd,sF),d9={kernelName:nd,backendName:"cpu",kernelFunc:h9};const _C=Bn(((n,e)=>n*e)),p9=AC(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),Mb=as(rd,_C,p9),f9={kernelName:rd,backendName:"cpu",kernelFunc:Mb};function rF(n,e,t){const s=wl(-1,t);return _C([],e,s,n,t)}function m9(n){const{inputs:e,backend:t}=n,{x:s}=e;Ye(s,"neg");const r=t.data.get(s.dataId).values,[i,a]=rF(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}const g9={kernelName:om,backendName:"cpu",kernelFunc:m9};const iF=Bn(((n,e)=>n!==e?1:0)),y9=as(lm,iF,null,"bool"),x9={kernelName:lm,backendName:"cpu",kernelFunc:y9};function OC(n,e,t,s,r){const i=e.length,a=ce(e),o=Ze(e),u=Ze(r),c=ss(t,ce(r));for(let d=0;d<a;++d){const p=Th(d,i,o),m=new Array(p.length);for(let x=0;x<m.length;x++)m[x]=p[s[x]];const g=ya(m,i,u);c[g]=n[d]}return c}function dr(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;Ye(r,"transpose");const a=r.shape.length,o=new Array(a);for(let p=0;p<o.length;p++)o[p]=r.shape[i[p]];const u=s.data.get(r.dataId).values,c=OC(u,r.shape,r.dtype,i,o);return{dataId:s.write(c,o,r.dtype),shape:o,dtype:r.dtype}}const b9={kernelName:yu,backendName:"cpu",kernelFunc:dr};function aF(n,e,t,s){const[r,i]=Mn(n,s),a=ys(e,"int32"),o=Ns(ce(r),a),u=ce(i);for(let c=0;c<o.length;++c){const d=c*u;let p=1;for(let m=0;m<u;++m)p*=t[d+m];o[c]=p}return{outVals:o,outShape:r,outDtype:a}}function v9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Ye(r,"prod");const o=r.shape.length,u=gt(i,r.shape),c=sn(u,o);let d=u,p=r;const m=[];c!=null&&(p=dr({inputs:{x:r},backend:t,attrs:{perm:c}}),m.push(p),d=mn(d.length,o));const g=t.data.get(p.dataId).values,{outVals:x,outShape:b,outDtype:v}=aF(p.shape,p.dtype,g,d);let w=b;return a&&(w=Dn(b,u)),m.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.makeTensorInfo(w,v,x)}const w9={kernelName:fm,backendName:"cpu",kernelFunc:v9};function S9(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=Th(r,e.length,Ze(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function C9(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function N9(n,e,t,s){const r=[];let i=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);C9(t,s);let u=1;for(let c=0;c<e.length-1;++c){u*=e[c];const d=e[c+1];for(let p=1;p<u+1;++p)o[c].push(p*d)}for(let c=0;c<n.length;++c){let d=n[c],p=n[c]+1;for(let m=0;m<t.length;++m){const g=t[m],x=m+e.length-1;if(x>=0){const b=o[x],v=b[b.length-1]-g[d];for(let w=d;w<p;++w)o[x].push(g[w+1]+v)}d=g[d],p=g[p]}p!==d&&(r.push([d,p]),i+=p-d)}return{outSplits:o,valueSlices:r,numValues:i}}function k9(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=En("int32",s);e.push(r),n[t].forEach((i,a)=>r[a]=i)}return e}function KT(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function $9(n,e,t,s,r,i){const a=KT(e,2)[1],o=KT(i,2)[1];let u=0;for(const c of t)for(let d=c[0];d<c[1];++d){for(let p=0;p<s;++p)r[u*o+p]=n[d*a+p];++u}}function I9(n,e,t,s,r){const i=e.slice();i[0]=r;const a=En(t,ce(i)),o=n.length,u=o===0?0:o/e[0];return $9(n,e,s,u,a,i),[a,i]}function oF(n,e,t,s,r,i,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(S9(i,a,u),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:d,valueSlices:p,numValues:m}=N9(i,a,n,c),g=k9(d),x=I9(t,s,r,p,m);return[g,x[0],x[1]]}const YT=2147483647;function lF(n,e,t,s,r,i,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,u=r.length===0,c=a.length===0,d=[];o||d.push(e[0]),u||d.push(r[0]),c||d.push(a[0]);for(let v=1;v<d.length;++v)if(d[v]!==d[v-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=En("int32",p+1);m[0]=0;for(let v=0;v<p;++v){const w=o?n[0]:n[v],N=u?s[0]:s[v],I=c?i[0]:i[v];if(I===0)throw new Error("Requires delta != 0");let $;if(I>0&&N<w||I<0&&N>w)$=0;else if($=Math.ceil(Math.abs((N-w)/I)),$>YT)throw new Error(`Requires ((limit - start) / delta) <= ${YT}`);m[v+1]=m[v]+$}const g=m[p],x=En(t,g);let b=0;for(let v=0;v<p;++v){const w=m[v+1]-m[v];let N=o?n[0]:n[v];const I=c?i[0]:i[v];for(let $=0;$<w;++$)x[b++]=N,N+=I}return[m,x]}var mi=Ui;class bx{constructor(e,t,s,r,i,a,o,u,c,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=HA(d),this.raggedRank=jA(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===mi.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===mi.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case mi.VALUE_ROWIDS:return bx.getMaxWidthValueRowID(t);case mi.ROW_SPLITS:return bx.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${mi[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let a=1;a<t;++a){const o=e[a];o!==r&&(r=o,i=Math.max(a-s,i),s=a)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ZT(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;qA(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=GA(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let a=0;for(let o=0;o<r;++o,a+=t)i.push(a);for(let o=r;o<e;++o)i.push(-1);return B(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,a=[];for(let o=0;o<i-1;++o){const u=e[o+1]-e[o];let c=Math.min(r,u),d=t[o];d===-1&&(c=0);for(let p=0;p<c;++p)a.push(d),d+=s;for(let p=0;p<u-c;++p)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,a=[];if(i===0)return[];let o=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let c=t[u];a.push(c);for(let d=1;d<i;++d){const p=e[d];if(p===u)c>=0&&(++o,o<r?c+=s:c=-1);else{if(o=0,u=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);c=t[p]}a.push(c)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case mi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case mi.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${mi[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case mi.FIRST_DIM_SIZE:return e[0];case mi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case mi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${mi[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const i=ZT(s,!1),a=En(this.valuesDType,ce(i));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,r[c],s[c]);this.setOutput(this.raggedRank,u,a,i)}return[i,a]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,a=s;let o=r.slice();o=o.slice(e+1);const u=ce(o),c=t.length;let d=this.defaultValue;if(d.length!==u&&d.length!==1){const x=this.defaultValueShape;he(()=>{const b=ae(d,x);d=oh(b,o).dataSync()})}let p=0,m=0,g=0;for(let x=0;x<=c;++x){let b=x<c?t[x]:-1;if(b===g){++g;continue}if(m<g){const v=i.subarray(p*u),w=a.subarray(m*u),N=(g-m)*u;QT(w,v,N)}if(x>=c){const v=s.length;b=Math.floor(v/u)}if(b>g)if(this.defaultValue.length===1)a.subarray(g*u,b*u).fill(this.defaultValue[0]),g=b;else for(;b>g;){const v=a.slice(g*u);QT(v,d,u),++g}b<0?(p=x+1,m=g):(p=x,m=g,g=m+1)}}}function QT(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function ZT(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function uF(n,e,t,s,r,i,a,o,u,c){return new bx(n,e,t,s,r,i,a,o,u,c).compute()}function cF(n,e,t,s){const r=n===e,i=n<e&&t<0,a=e<n&&t>1;if(r||i||a)return Ns(0,s);const o=Math.abs(Math.ceil((e-n)/t)),u=Ns(o,s);e<n&&t===1&&(t=-1),u[0]=n;for(let c=1;c<u.length;c++)u[c]=u[c-1]+t;return u}const hF=Ea(n=>1/Math.sqrt(n)),T9=Tl(cd,hF),E9={kernelName:cd,backendName:"cpu",kernelFunc:T9};function mu(n,e,t,s,r,i,a,o,u,c){const d=[s/r,r],p=n.values,m=e.values;if(s===0)return ft(t,e.dtype);const g=u instanceof es?u:ft(d,e.dtype);typeof u=="string"||typeof u=="number"?g.values.fill(u):typeof u=="boolean"&&g.values.fill(+u);for(let x=0;x<i;x++){const b=[];let v=0;for(let w=0;w<a;w++){const N=p[x*a+w];b.push(N),v+=N*o[w]}if(v<0||v>=s/r)throw new Error(`Invalid indices: ${b} does not index into ${t}`);for(let w=0;w<r;w++)c?g.values[v*r+w]+=m[x*r+w]:g.values[v*r+w]=e.rank===0?m[0]:m[x*r+w]}return g}const R9=Ea(n=>1/(1+Math.exp(-n))),dF=Qt(md,n=>1/(1+Math.exp(-n))),A9={kernelName:md,backendName:"cpu",kernelFunc:dF};function pF(n,e,t,s,r){const i=sC(s,e,t),a=ce(t),o=Ze(s);if(i){const p=rC(e,o);return r==="string"?n.slice(p,p+a):n.subarray(p,p+a)}const u=r==="string"?Ki(n):n,c=ft(s,r,u),d=ft(t,r);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),g=m.map((x,b)=>x+e[b]);d.set(c.get(...g),...m)}return r==="string"?dD(d.values):d.values}function Fu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s;Ye(r,"slice");const[o,u]=Fm(r,i,a);ab(r,o,u);const c=t.data.get(r.dataId).values,d=pF(c,o,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,d)}const D9={kernelName:vm,backendName:"cpu",kernelFunc:Fu};function fF(n,e,t,s,r,i,a){const o=e[0],u=i[0],c=new Array(u),d=new Array(o),p=e[1];if(u===0){if(o!==0)throw new Error(eD(o));const v=En(t,0),w=En(r,0);return[v,[0,p],w,c,d]}let m=!0,g=0;const x=new Array(u).fill(0);for(let v=0;v<o;++v){const w=n[v*p];if(w<0)throw new Error(tD(v,w));if(w>=u)throw new Error(nD(v,w,u));++x[w],m=m&&w>=g,g=w}let b=!0;for(let v=0;v<u;++v){const w=x[v]===0;c[v]=w,b=b&&!w,x[v]=Math.max(x[v],1),v>0&&(x[v]+=x[v-1])}if(b&&m){const v=n,w=s;for(let N=0;N<o;++N)d[N]=N;return[v,[o,p],w,c,d]}else{const v=x[u-1],w=En(t,v*p),N=En(r,v),I=new Array(u).fill(0);for(let $=0;$<o;++$){const E=n[$*p],D=I[E],F=(E===0?0:x[E-1])+D;I[E]++;for(let L=0;L<p;++L)w[F*p+L]=n[$*p+L];N[F]=s[$],d[$]=F}for(let $=0;$<u;++$)if(I[$]===0){const D=$===0?0:x[$-1];w[D*p+0]=$;for(let F=1;F<p;++F)w[D*p+F]=0;N[D]=a}return[w,[v,p],N,c,d]}}function mF(n,e,t,s,r){const i=ce(s),a=e[0],o=r.length,u=[];let c=1,d=-1;for(let v=0;v<o;++v){const w=r[v];if(w===-1){if(d!==-1)throw new Error(sD(d,v));d=v,u.push(1)}else{if(w<0)throw new Error(rD(v,w));c*=w,u.push(w)}}if(d!==-1){if(c<=0)throw new Error(iD());const v=Math.trunc(i/c);if(c*v!==i)throw new Error(aD(s,u));u[d]=v}if(ce(u)!==i)throw new Error(oD(s,u));const m=s.length,g=[];if(m>0){g[m-1]=1;for(let v=m-2;v>=0;--v)g[v]=g[v+1]*s[v+1]}const x=[];if(o>0){x[o-1]=1;for(let v=o-2;v>=0;--v)x[v]=x[v+1]*u[v+1]}const b=En(t,a*o);for(let v=0;v<a;++v){let w=0;for(let N=0;N<m;++N)w+=n[v*m+N]*g[N];for(let N=0;N<o;++N)b[v*o+N]=Math.trunc(w/x[N]),w%=x[N]}return[b,[a,o],u]}function FC(n,e,t,s,r,i=!1,a=0){const o=s.length,u=[e[0],n.length/e[0]],c=u[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(d2());const m=e.slice();m[0]=p;const g=m.reduce((I,$)=>I*$,1),x=En(t,g);if(o===0)return p>0&&x.fill(a),[x,m];if(p<=0)throw new Error(d2());let b=0,v=1,w=0,N=r[b];for(;;){let I=0;if(v<o){if(I=r[v],N===I){++v;continue}if(N>=I)throw new Error(lD())}if(N<0||N>=p)throw new Error(uD(N,p));N>w&&x.fill(a,w*c,N*c);for(let $=b;$<v;++$){const E=s[$];if(E<0||E>=u[0])throw new Error(cD($,s[$],u[0]));for(let D=0;D<c;D++)x[N*c+D]+=n[E*c+D]}if(i)for(let $=0;$<c;$++)x[N*c+$]/=v-b;if(b=v,++v,w=N+1,N=I,v>o)break}return w<p&&x.fill(a,w*c,p*c),[x,m]}const _9=Ea(n=>Math.sqrt(n)),O9=Qt(yd,n=>Math.sqrt(n)),F9={kernelName:yd,backendName:"cpu",kernelFunc:O9};const gF=Bn(((n,e)=>{const t=n-e;return t*t})),z9=as(xd,gF),L9={kernelName:xd,backendName:"cpu",kernelFunc:z9};const yF=Ea((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),M9=Tl(I0,yF),P9={kernelName:I0,backendName:"cpu",kernelFunc:M9};function xF(n,e,t,s){const r=ft(n,e.dtype);for(let i=0;i<r.size;i++){const a=r.indexToLoc(i),o=new Array(a.length);for(let u=0;u<o.length;u++)o[u]=a[u]*t[u]+s[u];r.set(e.get(...o),...a)}return r}class B9{constructor(e,t,s,r,i,a){this.separator=ro(e),this.nGramWidths=t,this.leftPad=ro(s),this.rightPad=ro(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,a){for(let o=0;o<i;++o){const u=this.getPadWidth(a),c=Math.max(0,u-o),d=Math.max(0,u-(i-(o+1))),p=a-(c+d),m=t+(c>0?0:o-u);let g=0;g+=c*this.leftPad.length;for(let N=0;N<p;++N)g+=e[m+N].length;g+=d*this.rightPad.length;const x=c+d+p-1;g+=x*this.separator.length,s[r+o]=new Uint8Array(g);const b=s[r+o];let v=0;const w=N=>N.forEach(I=>b[v++]=I);for(let N=0;N<c;++N)w(this.leftPad),w(this.separator);for(let N=0;N<p-1;++N)w(e[m+N]),w(this.separator);if(p>0){w(e[m+p-1]);for(let N=0;N<d;++N)w(this.separator),w(this.rightPad)}else{for(let N=0;N<d-1;++N)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<r;++c){let d=t[c]>=u;if(d=d&&t[c]<=s,!d)throw new Error(`Invalid split value ${t[c]}, must be in [${u}, ${s}]`);u=t[c]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const i=r-1,a=En("int32",r);if(s===0||r===0){const u=new Array(s);for(let c=0;c<=i;++c)a[c]=0;return[u,a]}a[0]=0;for(let u=1;u<=i;++u){const c=t[u]-t[u-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(c,p)}),this.preserveShort&&c>0&&d===0&&(d=1),a[u]=a[u-1]+d}const o=new Array(a[i]);for(let u=0;u<i;++u){const c=t[u];let d=a[u];if(this.nGramWidths.forEach(p=>{const m=t[u+1]-t[u],g=this.getNumNGrams(m,p);this.createNGrams(e,c,o,d,g,p),d+=g}),this.preserveShort&&d===a[u]){const p=t[u+1]-t[u];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(e,c,o,d,1,m)}}return[o,a]}}function bF(n,e,t,s,r,i,a,o){return new B9(t,s,r,i,a,o).compute(n,e)}function V9(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let a=n.indexOf(i);for(;a!==-1;){const o=n.subarray(0,a);(!t||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const a=n.subarray(r,i);(!t||a.length!==0)&&s.push(a),r=i+1}}function vF(n,e,t){const s=n.length,r=[];let i=0,a=0;const o=new Array(s);for(let m=0;m<s;++m){const g=r.length;V9(n[m],e,t,r);const x=r.length-g;o[m]=x,i+=x,a=Math.max(a,x)}const u=En("int32",i*2),c=new Array(i),d=[s,a];let p=0;for(let m=0;m<s;++m)for(let g=0;g<o[m];++g)u[p*2]=m,u[p*2+1]=g,c[p]=r[p],++p;return[u,c,d]}function wF(n,e){const t=En("int32",n.length);for(let s=0;s<n.length;++s)t[s]=t4(n[s]).modulo(e).getLowBitsUnsigned();return t}const SF=Bn(((n,e)=>n-e)),U9=AC(((n,e,t,s)=>({real:n-t,imag:e-s}))),zC=as(bd,SF,U9),W9={kernelName:bd,backendName:"cpu",kernelFunc:zC};function CF(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=ft(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),a=new Array(n.rank);for(let u=0;u<a.length;u++)a[u]=i[u]%n.shape[u];const o=n.locToIndex(a);s.values[r]=n.values[o]}return s}const Yp=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function NF(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,u=e-t+1,c=Math.log(o),d=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*d*(o-d)/o)*Math.sign(u-o/2),m=Math.max(t,Math.floor(e-u*d/o+p)),g=Math.min(s,Math.floor(e+(o-u)*d/o+p));NF(n,e,m,g)}const r=n[e];let i=t,a=s;for(eh(n,t,e),Yp(n[s],r)>0&&eh(n,t,s);i<a;){for(eh(n,i,a),i++,a--;Yp(n[i],r)<0;)i=i+1;for(;Yp(n[a],r)>0;)a=a-1}Yp(n[t],r)===0?eh(n,t,a):(a=a+1,eh(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function kF(n,e,t,s,r){const i=e[e.length-1],[a,o]=[n.length/i,i],u=ss(t,a*s),c=ss("int32",a*s);for(let p=0;p<a;p++){const m=p*o,g=n.subarray(m,m+o);let x=new Array(g.length);g.forEach((N,I)=>x[I]={value:N,index:I}),s<x.length&&(NF(x,s),x=x.slice(0,s)),r&&x.sort(Yp);const b=p*s,v=u.subarray(b,b+s),w=c.subarray(b,b+s);for(let N=0;N<s;N++)v[N]=x[N].value,w[N]=x[N].index}const d=e.slice();return d[d.length-1]=s,[ft(d,t,u),ft(d,"int32",c)]}function $F(n,e,t,s){const r=gt(e,t)[0],i=[1,t[0],1];for(let x=0;x<r;x++)i[0]*=t[x];i[1]=t[r];for(let x=r+1;x<t.length;x++)i[2]*=t[x];const a=new Map,o=new Int32Array(t[r]),u=new es(i,s,n),c=[],d=i[0]===1&&i[2]===1;for(let x=0;x<t[r];x++){let b;if(d)b=n[x].toString();else{const w=[];for(let N=0;N<i[0];N++)for(let I=0;I<i[2];I++)w.push(u.get(N,x,I));b=w.join(",")}const v=a.get(b);if(v!=null)o[x]=v;else{const w=a.size;a.set(b,w),o[x]=w,c.push(x)}}const p=i.slice();p[1]=a.size;const m=new es(p,s);c.forEach((x,b)=>{for(let v=0;v<i[0];v++)for(let w=0;w<i[2];w++)m.set(u.get(v,x,w),v,b,w)});const g=t.slice();return g[r]=p[1],{outputValues:m.values,outputShape:g,indices:o}}const IF=Object.freeze(Object.defineProperty({__proto__:null,addImpl:FO,bincountImpl:DC,bincountReduceImpl:zO,bitwiseAndImpl:LO,castImpl:OO,ceilImpl:MO,concatImpl:PO,equalImpl:BO,expImpl:UO,expm1Impl:GO,floorDivImpl:jO,floorImpl:HO,gatherNdImpl:qO,gatherV2Impl:XO,greaterEqualImpl:YO,greaterImpl:KO,lessEqualImpl:ZO,lessImpl:QO,linSpaceImpl:JO,logImpl:eF,maxImpl:tF,maximumImpl:nF,minimumImpl:sF,multiplyImpl:_C,negImpl:rF,notEqualImpl:iF,prodImpl:aF,raggedGatherImpl:oF,raggedRangeImpl:lF,raggedTensorToTensorImpl:uF,rangeImpl:cF,rsqrtImpl:hF,scatterImpl:mu,sigmoidImpl:R9,simpleAbsImpl:_O,sliceImpl:pF,sparseFillEmptyRowsImpl:fF,sparseReshapeImpl:mF,sparseSegmentReductionImpl:FC,sqrtImpl:_9,squaredDifferenceImpl:gF,staticRegexReplaceImpl:yF,stridedSliceImpl:xF,stringNGramsImpl:bF,stringSplitImpl:vF,stringToHashBucketFastImpl:wF,subImpl:SF,tileImpl:CF,topKImpl:kF,transposeImpl:OC,uniqueImpl:$F},Symbol.toStringTag,{value:"Module"}));fS("cpu",()=>new Lb,1);const TF=Qt(Uh,n=>n>=0?n:Math.exp(n)-1),G9={kernelName:Uh,backendName:"cpu",kernelFunc:TF};function EF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;Ye([r],"leakyRelu");const a=ce(r.shape),o=t.data.get(r.dataId).values,u=ss("float32",a);for(let c=0;c<o.length;c++)u[c]=o[c]<0?i*o[c]:o[c];return t.makeTensorInfo(r.shape,"float32",u)}const H9={kernelName:Xf,backendName:"cpu",kernelFunc:EF};const j9=Bn((n,e)=>n<0?e*n:n);function RF(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;Ye([s,r],"prelu");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[o,u]=j9(s.shape,r.shape,i,a,"float32");return t.makeTensorInfo(u,"float32",o)}const q9={kernelName:pm,backendName:"cpu",kernelFunc:RF};const AF=Qt(od,n=>Math.max(0,n)),X9={kernelName:od,backendName:"cpu",kernelFunc:AF};const DF=Qt(ld,n=>Math.min(Math.max(0,n),6)),K9={kernelName:ld,backendName:"cpu",kernelFunc:DF};function vx(n,e,t,s,r){if(t==="linear")return Ca({inputs:{x:e},backend:n});if(t==="relu")return AF({inputs:{x:e},backend:n});if(t==="elu")return TF({inputs:{x:e},backend:n});if(t==="relu6")return DF({inputs:{x:e},backend:n});if(t==="prelu")return RF({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return EF({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return dF({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function pn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=ce(r.shape),o=J2(i,a),u=ce(o);B(a===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const c=t.data.get(r.dataId);if(c.complexTensorInfos!=null){const d=c.complexTensorInfos.real,p=c.complexTensorInfos.imag;d.shape=o,p.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const Y9={kernelName:mm,backendName:"cpu",kernelFunc:pn};function _F(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;Ye([r,i],"matMul");const u=r.shape.length,c=i.shape.length,d=a?r.shape[u-2]:r.shape[u-1],p=o?i.shape[c-1]:i.shape[c-2],m=a?r.shape[u-1]:r.shape[u-2],g=o?i.shape[c-2]:i.shape[c-1],x=r.shape.slice(0,-2),b=i.shape.slice(0,-2),v=ce(x),w=ce(b),I=it(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,g]);B(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const $=a?[v,d,m]:[v,m,d],E=o?[w,g,p]:[w,p,g],D=pn({inputs:{x:r},backend:t,attrs:{shape:$}}),F=pn({inputs:{x:i},backend:t,attrs:{shape:E}}),L=a?D.shape[1]:D.shape[2],z=a?D.shape[2]:D.shape[1],M=o?F.shape[1]:F.shape[2],O=Math.max(v,w),H=t.data.get(D.dataId).values,X=t.data.get(F.dataId).values,te=Ze(D.shape),Z=Ze(F.shape),[W,ee,ie]=a?[te[0],1,te[1]]:[te[0],te[1],1],[de,ge,G]=o?[1,Z[1],Z[0]]:[Z[1],1,Z[0]],re=z*M,pe=ft([O,z,M],D.dtype),ve=pe.values,Ne=t.blockSize;for(let Ee=0;Ee<O;Ee++){const _e=Ee%v,je=Ee%w;for(let Be=0;Be<z;Be+=Ne){const at=Math.min(Be+Ne,z);for(let ot=0;ot<M;ot+=Ne){const Tt=Math.min(ot+Ne,M);for(let ut=0;ut<L;ut+=Ne){const mt=Math.min(ut+Ne,L);for(let Bt=Be;Bt<at;Bt++)for(let Ft=ot;Ft<Tt;Ft++){let Zt=0;for(let qt=ut;qt<mt;qt++){const Ps=H[_e*W+Bt*ee+qt*ie],yn=X[qt*de+Ft*ge+je*G];Zt+=Ps*yn}ve[Ee*re+(Bt*M+Ft)]+=Zt}}}}}return t.disposeIntermediateTensorInfo(D),t.disposeIntermediateTensorInfo(F),t.makeTensorInfo(I,pe.dtype,pe.values)}const Q9={kernelName:_f,backendName:"cpu",kernelFunc:_F};function Z9(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=s;let m,g,x;const b=[];m=_F({inputs:{a:r,b:i},attrs:{transposeA:u,transposeB:c},backend:t}),a&&(g=yh({inputs:{a:m,b:a},backend:t}),b.push(m),m=g),d&&(x=vx(t,m,d,o,p),b.push(m),m=x);for(const w of b)t.disposeIntermediateTensorInfo(w);return m}const J9={kernelName:rf,backendName:"cpu",kernelFunc:Z9};const eY=Qt(Eh,n=>Math.acos(n)),tY={kernelName:Eh,backendName:"cpu",kernelFunc:eY};const nY=Qt(Rh,n=>Math.acosh(n)),sY={kernelName:Rh,backendName:"cpu",kernelFunc:nY};function rY(n){const{inputs:e,backend:t}=n,s=e;Ye(e,"addN");const r=s.map(o=>t.data.get(o.dataId).values),i=ft(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const u=r[o];for(let c=0;c<a.length;c++)a[c]+=u[c]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const iY={kernelName:Tf,backendName:"cpu",kernelFunc:rY};function aY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Ye(r,"all");const o=gt(i,r.shape);let u=o;const c=sn(u,r.shape.length);let d=r;c!=null&&(d=dr({inputs:{x:r},backend:t,attrs:{perm:c}}),u=mn(u.length,r.shape.length)),Hn("all",u,d.shape.length);const[p,m]=Mn(d.shape,u),g=ce(m),x=Ns(ce(p),d.dtype),b=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const N=w*g;let I=b[N];for(let $=0;$<g;++$){const E=b[N+$];I=I&&E}x[w]=I}c!=null&&t.disposeIntermediateTensorInfo(d);const v=t.makeTensorInfo(p,d.dtype,x);if(a){const w=Dn(p,o),N=pn({inputs:{x:v},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(v),N}return v}const oY={kernelName:zx,backendName:"cpu",kernelFunc:aY};function lY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Ye(r,"any");const o=gt(i,r.shape);let u=o;const c=sn(u,r.shape.length);let d=r;c!=null&&(d=dr({inputs:{x:r},backend:t,attrs:{perm:c}}),u=mn(u.length,r.shape.length)),Hn("any",u,d.shape.length);const[p,m]=Mn(d.shape,u),g=ce(m),x=Ns(ce(p),d.dtype),b=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const N=w*g;let I=b[N];for(let $=0;$<g;++$){const E=b[N+$];I=I||E}x[w]=I}c!=null&&t.disposeIntermediateTensorInfo(d);const v=t.makeTensorInfo(p,d.dtype,x);if(a){const w=Dn(p,o),N=pn({inputs:{x:v},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(v),N}return v}const uY={kernelName:Lx,backendName:"cpu",kernelFunc:lY};function cY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Ye(r,"argMax");let a=gt(i,r.shape);const o=sn(a,r.shape.length);let u=r;const c=[];o!=null&&(u=dr({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(u),a=mn(a.length,u.shape.length)),a=[a[0]],Hn("argMax",a,u.shape.length);const[d,p]=Mn(u.shape,a),m=ce(d),g=Ns(m,"int32"),x=ce(p),b=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const w=v*x;let N=b[w],I=0;for(let $=0;$<x;++$){const E=b[w+$];E>N&&(N=E,I=$)}g[v]=I}return c.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(d,"int32",g)}const hY={kernelName:Ef,backendName:"cpu",kernelFunc:cY};function dY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Ye(r,"argMin");let a=gt(i,r.shape);const o=sn(a,r.shape.length);let u=r;const c=[];o!=null&&(u=dr({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(u),a=mn(a.length,u.shape.length)),a=[a[0]],Hn("argMin",a,u.shape.length);const[d,p]=Mn(u.shape,a),m=ce(d),g=Ns(m,"int32"),x=ce(p),b=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const w=v*x;let N=b[w],I=0;for(let $=0;$<x;++$){const E=b[w+$];E<N&&(N=E,I=$)}g[v]=I}return c.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(d,"int32",g)}const pY={kernelName:Rf,backendName:"cpu",kernelFunc:dY};const fY=Qt(Ah,n=>Math.asin(n)),mY={kernelName:Ah,backendName:"cpu",kernelFunc:fY};const gY=Qt(Dh,n=>Math.asinh(n)),yY={kernelName:Dh,backendName:"cpu",kernelFunc:gY};const xY=Qt(_h,n=>Math.atan(n)),bY={kernelName:_h,backendName:"cpu",kernelFunc:xY};const vY=Bn((n,e)=>Math.atan2(n,e)),wY=as(Fh,vY),SY={kernelName:Fh,backendName:"cpu",kernelFunc:wY};const CY=Qt(Oh,n=>Math.atanh(n)),NY={kernelName:Oh,backendName:"cpu",kernelFunc:CY};function LC(n,e,t,s,r,i){const a=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,g=r.padInfo.left,x=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=ft(r.outShape,t),v=b.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3],N=r.outShape[2]*r.outShape[3],I=r.outShape[3];for(let $=0;$<r.batchSize;++$){const E=$*w,D=$*s[0];for(let F=0;F<r.inChannels;++F)for(let L=0;L<r.outHeight;++L){const z=L*a-m,M=Math.max(0,z),O=Math.min(r.inHeight,d+z),H=E+L*N;for(let X=0;X<r.outWidth;++X){const te=X*o-g,Z=Math.max(0,te),W=Math.min(r.inWidth,p+te);let ee=x,ie=0,de=0;for(let G=M;G<O;G+=u){const re=D+G*s[1];for(let pe=Z;pe<W;pe+=c){const ve=re+pe*s[2],Ne=n[ve+F];i==="max"&&Ne>ee?ee=Ne:i==="avg"&&(ie+=Ne,de++)}if(isNaN(ee))break}const ge=H+X*I+F;v[ge]=i==="avg"?ie/de:ee}}}return b}function OF(n,e,t,s,r=!1,i=!1){const a=ft(s.outShape,"int32"),o=s.strideHeight,u=s.strideWidth,c=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,g=s.padInfo.top,x=s.padInfo.left,b=ft(e,t,n);for(let v=0;v<s.batchSize;++v)for(let w=0;w<s.inChannels;++w)for(let N=0;N<s.outHeight;++N){const I=N*o-g;let $=I;for(;$<0;)$+=c;const E=Math.min(s.inHeight,p+I);for(let D=0;D<s.outWidth;++D){const F=D*u-x;let L=F;for(;L<0;)L+=d;const z=Math.min(s.inWidth,m+F);let M=Number.NEGATIVE_INFINITY,O=-1;for(let H=$;H<E;H+=c){const X=H-I;for(let te=L;te<z;te+=d){const Z=te-F,W=b.get(v,H,te,w);W>M&&(M=W,r?O=i?((v*s.inHeight+H)*s.inWidth+te)*s.inChannels+w:(H*s.inWidth+te)*s.inChannels+w:O=X*m+Z)}}a.set(O,v,N,D,w)}}return a}function FF(n,e,t,s,r,i){const a=r.strideDepth,o=r.strideHeight,u=r.strideWidth,c=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,g=r.effectiveFilterHeight,x=r.effectiveFilterWidth,b=r.padInfo.front,v=r.padInfo.top,w=r.padInfo.left,N=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=ft(r.outShape,t),$=I.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],D=r.outShape[2]*r.outShape[3]*r.outShape[4],F=r.outShape[3]*r.outShape[4],L=r.outShape[4];for(let z=0;z<r.batchSize;++z){const M=z*E,O=z*s[0];for(let H=0;H<r.inChannels;++H)for(let X=0;X<r.outDepth;++X){const te=X*a-b;let Z=te;for(;Z<0;)Z+=c;const W=Math.min(r.inDepth,m+te),ee=M+X*D;for(let ie=0;ie<r.outHeight;++ie){const de=ie*o-v;let ge=de;for(;ge<0;)ge+=d;const G=Math.min(r.inHeight,g+de),re=ee+ie*F;for(let pe=0;pe<r.outWidth;++pe){const ve=pe*u-w;let Ne=ve;for(;Ne<0;)Ne+=p;const Ee=Math.min(r.inWidth,x+ve),_e=re+pe*L;let je=N,Be=0,at=0;for(let Tt=Z;Tt<W;Tt+=c){const ut=O+Tt*s[1];for(let mt=ge;mt<G;mt+=d){const Bt=ut+mt*s[2];for(let Ft=Ne;Ft<Ee;Ft+=p){const Zt=Bt+Ft*s[3],qt=n[Zt+H];if(i==="max"&&qt>je?je=qt:i==="avg"&&(Be+=qt,at++),isNaN(je))break}if(isNaN(je))break}if(isNaN(je))break}const ot=_e+H;$[ot]=i==="avg"?Be/Math.max(at,1):je}}}}return I}function kY(n,e){const t=ft(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;for(let b=0;b<e.batchSize;++b)for(let v=0;v<e.inChannels;++v)for(let w=0;w<e.outDepth;++w){const N=w*s-m;let I=N;for(;I<0;)I+=a;const $=Math.min(e.inDepth,c+N);for(let E=0;E<e.outHeight;++E){const D=E*r-g;let F=D;for(;F<0;)F+=o;const L=Math.min(e.inHeight,d+D);for(let z=0;z<e.outWidth;++z){const M=z*i-x;let O=M;for(;O<0;)O+=u;const H=Math.min(e.inWidth,p+M);let X=Number.NEGATIVE_INFINITY,te=-1;for(let Z=I;Z<$;Z+=a){const W=Z-N;for(let ee=F;ee<L;ee+=o){const ie=ee-D;for(let de=O;de<H;de+=u){const ge=de-M,G=n.get(b,Z,ee,de,v);G>=X&&(X=G,te=W*d*p+ie*d+ge)}}}t.set(te,b,w,E,z,v)}}}return t}function $Y(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Ye(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,c=1;B(is(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=zs(r.shape,i,a,c,o,u);let p;if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))p=Ca({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,g=Ze(r.shape),x=LC(m,r.shape,r.dtype,g,d,"avg");p=t.makeTensorInfo(d.outShape,r.dtype,x.values)}return p}const IY={kernelName:Af,backendName:"cpu",kernelFunc:$Y};function TY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:c}=s;Ye(r,"avgPool3d");const d=Qr(r.shape,i,a,1,o,u,c),p=t.data.get(r.dataId).values,m=FF(p,r.shape,r.dtype,Ze(r.shape),d,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const EY={kernelName:Df,backendName:"cpu",kernelFunc:TY};function RY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:u,dimRoundingMode:c}=s;Ye([r,i],"avgPool3DGrad");const d=Qr(i.shape,a,o,1,u,c),p=d.strideDepth,m=d.strideHeight,g=d.strideWidth,x=d.filterDepth,b=d.filterHeight,v=d.filterWidth,w=d.dilationDepth,N=d.dilationHeight,I=d.dilationWidth,$=d.effectiveFilterDepth,E=d.effectiveFilterHeight,D=d.effectiveFilterWidth,F=$-1-d.padInfo.front,L=D-1-d.padInfo.left,z=E-1-d.padInfo.top,M=ft(i.shape,"float32"),O=1/(x*b*v),H=t.bufferSync(r);for(let X=0;X<d.batchSize;++X)for(let te=0;te<d.inChannels;++te)for(let Z=0;Z<d.inDepth;++Z)for(let W=0;W<d.inHeight;++W)for(let ee=0;ee<d.inWidth;++ee){const ie=Z-F,de=W-z,ge=ee-L;let G=0;for(let re=0;re<$;re+=w){const pe=(ie+re)/p;if(!(pe<0||pe>=d.outDepth||Math.floor(pe)!==pe))for(let ve=0;ve<E;ve+=N){const Ne=(de+ve)/m;if(!(Ne<0||Ne>=d.outHeight||Math.floor(Ne)!==Ne))for(let Ee=0;Ee<D;Ee+=I){const _e=(ge+Ee)/g;if(_e<0||_e>=d.outWidth||Math.floor(_e)!==_e)continue;const je=H.get(X,pe,Ne,_e,te);G+=je}}}M.set(G*O,X,Z,W,ee,te)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const AY={kernelName:Px,backendName:"cpu",kernelFunc:RY};function DY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;Ye([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=s,d=zs(a.shape,o,u,1,c),p=d.strideHeight,m=d.strideWidth,g=d.filterHeight,x=d.filterWidth,b=d.dilationHeight,v=d.dilationWidth,w=d.effectiveFilterHeight,N=d.effectiveFilterWidth,I=N-1-d.padInfo.left,$=w-1-d.padInfo.top,E=ft(a.shape,"float32"),D=1/(g*x),F=t.data.get(r.dataId).values,L=ft(r.shape,"float32",F);for(let z=0;z<d.batchSize;++z)for(let M=0;M<d.inChannels;++M)for(let O=0;O<d.inHeight;++O)for(let H=0;H<d.inWidth;++H){const X=O-$,te=H-I;let Z=0;for(let W=0;W<w;W+=b){const ee=(X+W)/p;if(!(ee<0||ee>=d.outHeight||Math.floor(ee)!==ee))for(let ie=0;ie<N;ie+=v){const de=(te+ie)/m;if(de<0||de>=d.outWidth||Math.floor(de)!==de)continue;const ge=L.get(z,ee,de,M);Z+=ge}}E.set(Z*D,z,O,H,M)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const _Y={kernelName:Mx,backendName:"cpu",kernelFunc:DY};function OY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:a,mean:o,variance:u}=e;B(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ye([r,o,u,i,a],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const d=t.data.get(r.dataId).values,p=t.data.get(o.dataId).values,m=t.data.get(u.dataId).values,g=i?t.data.get(i.dataId).values:new Float32Array([1]),x=a?t.data.get(a.dataId).values:new Float32Array([0]),b=new Float32Array(d.length),v=x.length,w=g.length,N=m.length,I=p.length;let $=0,E=0,D=0,F=0;for(let L=0;L<d.length;++L)b[L]=x[$++]+(d[L]-p[E++])*g[D++]/Math.sqrt(m[F++]+c),$>=v&&($=0),E>=I&&(E=0),D>=w&&(D=0),F>=N&&(F=0);return t.makeTensorInfo(r.shape,r.dtype,b)}const FY={kernelName:Hf,backendName:"cpu",kernelFunc:OY};function zY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;Ye([r],"batchToSpaceND");const o=i.reduce((w,N)=>w*N),u=Wu(r.shape,i,o),c=Gu(u.length,i.length),d=Hu(r.shape,i,o),p=db(a,i.length),m=pb(d,a,i.length),g=pn({inputs:{x:r},backend:t,attrs:{shape:u}}),x=dr({inputs:{x:g},backend:t,attrs:{perm:c}}),b=pn({inputs:{x},backend:t,attrs:{shape:d}}),v=Fu({inputs:{x:b},backend:t,attrs:{begin:p,size:m}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),v}const LY={kernelName:Of,backendName:"cpu",kernelFunc:zY};function MY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,c=DC(o,u,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,c)}const PY={kernelName:Bx,backendName:"cpu",kernelFunc:MY};function BY(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=it(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const VY={kernelName:Ux,backendName:"cpu",kernelFunc:BY};const UY=Qt(Mh,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),WY={kernelName:Mh,backendName:"cpu",kernelFunc:UY};const GY=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(ce(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,o=t.data.get(i.dataId).values,u=t.data.get(a.dataId).values;for(let c=0;c<o.length;c++){const d=o[c],p=u[c];s[c]=Math.hypot(d,p)}return t.makeOutput(s,e.shape,"float32")},HY={kernelName:Ff,backendName:"cpu",kernelFunc:GY};function xh(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const jY={kernelName:o0,backendName:"cpu",kernelFunc:xh};function bh(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=gt(r,e[0].shape)[0],a=e.map(b=>b.shape);ub(a,i);let o=lr(e.map(b=>b.shape),i);if(ce(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(b=>ce(b.shape)>0);if(u.length===1)return Ca({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){const b=u.map($=>Ou({inputs:{input:$},backend:t})),v=u.map($=>xh({inputs:{input:$},backend:t})),w=bh({inputs:b,backend:t,attrs:{axis:i}}),N=bh({inputs:v,backend:t,attrs:{axis:i}}),I=kr({inputs:{real:w,imag:N},backend:t});return b.forEach($=>t.disposeIntermediateTensorInfo($)),v.forEach($=>t.disposeIntermediateTensorInfo($)),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(N),I}const c=u.map(b=>{const w=[-1,ce(b.shape.slice(i))];return pn({inputs:{x:b},backend:t,attrs:{shape:w}})}),d=c.map(b=>({vals:t.data.get(b.dataId).values,shape:b.shape}));o=lr(c.map(b=>b.shape),1);const p=c[0].shape[0]===1,m=PO(d,o,e[0].dtype,p),g=lr(u.map(b=>b.shape),i),x=t.makeTensorInfo(g,e[0].dtype,m);return c.forEach(b=>t.disposeIntermediateTensorInfo(b)),x}const qY={kernelName:zf,backendName:"cpu",kernelFunc:bh};function zF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:u,dilations:c,dimRoundingMode:d}=s;Ye([r,i],"conv2d");const p=Dr(u),m=fn(r.shape,i.shape,a,c,o,d,!1,p),g=m.filterHeight,x=m.filterWidth,b=m.dilationHeight,v=m.dilationWidth,w=m.padInfo.left,N=m.padInfo.top,I=m.dataFormat==="channelsLast",$=new es(m.outShape,r.dtype),E=Ze(r.shape),D=Ze(i.shape),F=E[0],L=I?E[1]:E[2],z=I?E[2]:1,M=I?1:E[1],O=$.strides[0],H=I?$.strides[1]:$.strides[2],X=I?$.strides[2]:1,te=I?1:$.strides[1],Z=t.data.get(r.dataId).values,W=t.data.get(i.dataId).values,ee=$.values;for(let ie=0;ie<m.batchSize;++ie){const de=ie*F,ge=ie*O;for(let G=0;G<m.outHeight;++G){const re=ge+G*H,pe=G*m.strideHeight-N;for(let ve=0;ve<g;++ve){const Ne=pe+ve*b;if(Ne<0||Ne>=m.inHeight)continue;const Ee=ve*D[0],_e=de+Ne*L;for(let je=0;je<m.outWidth;++je){const Be=re+je*X,at=je*m.strideWidth-w;for(let ot=0;ot<x;++ot){const Tt=at+ot*v;if(Tt<0||Tt>=m.inWidth)continue;const ut=Ee+ot*D[1],mt=_e+Tt*z;let Bt=ut;for(let Ft=0;Ft<m.inChannels;++Ft){const Zt=Z[mt+Ft*M];for(let qt=0;qt<m.outChannels;++qt)ee[Be+qt*te]+=Zt*W[Bt+qt];Bt+=m.outChannels}}}}}}return t.makeTensorInfo($.shape,$.dtype,ee)}const XY={kernelName:Lf,backendName:"cpu",kernelFunc:zF};function KY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:d}=s;Ye([r,i],"conv2dBackpropFilter");const p=Dr(u),m=fn(r.shape,d,a,1,o,c,!1,p),{strideHeight:g,strideWidth:x,filterHeight:b,filterWidth:v}=m,w=m.dataFormat==="channelsLast",N=new es(m.filterShape,"float32"),I=m.padInfo.left,$=m.padInfo.top,E=t.data.get(r.dataId).values,D=t.data.get(i.dataId).values,F=new es(r.shape,r.dtype,E),L=new es(i.shape,i.dtype,D);for(let z=0;z<b;++z){const M=Math.max(0,Math.ceil(($-z)/g)),O=Math.min(m.outHeight,(m.inHeight+$-z)/g);for(let H=0;H<v;++H){const X=Math.max(0,Math.ceil((I-H)/x)),te=Math.min(m.outWidth,(m.inWidth+I-H)/x);for(let Z=0;Z<m.inChannels;++Z)for(let W=0;W<m.outChannels;++W){let ee=0;for(let ie=0;ie<m.batchSize;++ie)for(let de=M;de<O;++de){const ge=z+de*g-$;for(let G=X;G<te;++G){const re=H+G*x-I;w?ee+=F.get(ie,ge,re,Z)*L.get(ie,de,G,W):ee+=F.get(ie,Z,ge,re)*L.get(ie,W,de,G)}}N.set(ee,z,H,Z,W)}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const YY={kernelName:Gx,backendName:"cpu",kernelFunc:KY};function QY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:u,dataFormat:c,dimRoundingMode:d}=s;Ye([r,i],"conv2dBackpropInput");const p=Ze(i.shape),m=Ze(r.shape);let g=Dr(c);const x=fn(a,i.shape,o,1,u,d,!1,g),b=new es(x.inShape,"float32"),v=b.values,w=t.data.get(r.dataId).values,N=t.data.get(i.dataId).values,[I,$,E]=p,{batchSize:D,filterHeight:F,filterWidth:L,inChannels:z,inHeight:M,inWidth:O,outChannels:H,outHeight:X,outWidth:te,strideHeight:Z,strideWidth:W}=x;g=x.dataFormat;const ee=F-1-x.padInfo.top,ie=L-1-x.padInfo.left,de=g==="channelsLast",ge=b.strides[0],G=de?b.strides[1]:b.strides[2],re=de?b.strides[2]:1,pe=de?1:b.strides[1],ve=m[0],Ne=de?m[1]:m[2],Ee=de?m[2]:1,_e=de?1:m[1];for(let je=0;je<D;++je)for(let Be=0;Be<z;++Be)for(let at=0;at<M;++at){const ot=at-ee,Tt=Math.max(0,Math.ceil(ot/Z)),ut=Math.min(X,(F+ot)/Z);for(let mt=0;mt<O;++mt){const Bt=mt-ie,Ft=Math.max(0,Math.ceil(Bt/W)),Zt=Math.min(te,(L+Bt)/W);let qt=0;for(let yn=Tt;yn<ut;++yn){const Js=yn*Z-ot;for(let os=Ft;os<Zt;++os){const ei=os*W-Bt,Ut=ve*je+Ne*yn+Ee*os,fr=I*(F-1-Js)+$*(L-1-ei)+E*Be;for(let Bs=0;Bs<H;++Bs){const er=w[Ut+_e*Bs],tr=N[fr+Bs];qt+=er*tr}}}const Ps=ge*je+G*at+re*mt+pe*Be;v[Ps]=qt}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const ZY={kernelName:Mf,backendName:"cpu",kernelFunc:QY};function JY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s;Ye([r,i],"conv3d");const c=ea(r.shape,i.shape,a,u,o),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:g,dilationHeight:x,dilationWidth:b,padInfo:v}=c,w=v.front,N=v.left,I=v.top,$=new es(c.outShape,r.dtype),E=t.data.get(r.dataId).values,D=t.data.get(i.dataId).values,F=$.values,L=Ze(r.shape),z=Ze(i.shape);for(let M=0;M<c.batchSize;++M){const O=M*L[0],H=M*$.strides[0];for(let X=0;X<c.outDepth;++X){const te=H+X*$.strides[1],Z=X*c.strideDepth-w;for(let W=0;W<d;++W){const ee=Z+W*g;if(ee<0||ee>=c.inDepth)continue;const ie=W*z[0],de=O+ee*L[1];for(let ge=0;ge<c.outHeight;++ge){const G=te+ge*$.strides[2],re=ge*c.strideHeight-I;for(let pe=0;pe<p;++pe){const ve=re+pe*x;if(ve<0||ve>=c.inHeight)continue;const Ne=ie+pe*z[1],Ee=de+ve*L[2];for(let _e=0;_e<c.outWidth;++_e){const je=G+_e*c.outChannels,Be=_e*c.strideWidth-N;for(let at=0;at<m;++at){const ot=Be+at*b;if(ot<0||ot>=c.inWidth)continue;const Tt=Ne+at*z[2],ut=Ee+ot*c.inChannels;let mt=Tt;for(let Bt=0;Bt<c.inChannels;++Bt){const Ft=E[ut+Bt];for(let Zt=0;Zt<c.outChannels;++Zt)F[je+Zt]+=Ft*D[mt+Zt];mt+=c.outChannels}}}}}}}}return t.makeTensorInfo($.shape,$.dtype,$.values)}const eQ={kernelName:Pf,backendName:"cpu",kernelFunc:JY};function tQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:u}=s;Ye([r,i],"conv3dBackpropFilterV2");const c=Ze(r.shape),d=Ze(i.shape),p=ea(r.shape,u,a,1,o),m=p.strideDepth,g=p.strideHeight,x=p.strideWidth,b=p.filterDepth,v=p.filterHeight,w=p.filterWidth,N=new es(p.filterShape,"float32"),I=N.values,[$,E,D,F]=N.strides,L=t.data.get(i.dataId).values,[z,M,O,H]=d,X=t.data.get(r.dataId).values,[te,Z,W,ee]=c,ie=p.padInfo.front,de=p.padInfo.left,ge=p.padInfo.top;for(let G=0;G<b;++G){const re=Math.max(0,Math.ceil((ie-G)/m)),pe=Math.min(p.outDepth,(p.inDepth+ie-G)/m),ve=G*$;for(let Ne=0;Ne<v;++Ne){const Ee=Math.max(0,Math.ceil((ge-Ne)/g)),_e=Math.min(p.outHeight,(p.inHeight+ge-Ne)/g),je=Ne*E+ve;for(let Be=0;Be<w;++Be){const at=Math.max(0,Math.ceil((de-Be)/x)),ot=Math.min(p.outWidth,(p.inWidth+de-Be)/x),Tt=Be*D+je;for(let ut=0;ut<p.inChannels;++ut){const mt=ut*F+Tt;for(let Bt=0;Bt<p.outChannels;++Bt){let Ft=0;for(let Zt=0;Zt<p.batchSize;++Zt){const qt=Zt*te,Ps=Zt*z;for(let yn=re;yn<pe;++yn){const os=(G+yn*m-ie)*Z+qt,ei=yn*M+Ps;for(let Ut=Ee;Ut<_e;++Ut){const Bs=(Ne+Ut*g-ge)*W+os,er=Ut*O+ei;for(let tr=at;tr<ot;++tr){const yo=(Be+tr*x-de)*ee+Bs,xo=tr*H+er;Ft+=X[yo+ut]*L[xo+Bt]}}}}I[mt+Bt]=Ft}}}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const nQ={kernelName:Hx,backendName:"cpu",kernelFunc:tQ};function sQ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:u}=s;Ye([r],"conv3dBackpropInputV2");const c=Ze(r.shape),d=Ze(i.shape),p=ea(u,i.shape,o,1,a),m=new es(p.inShape,"float32"),g=m.values,[x,b,v,w]=m.strides,N=t.data.get(r.dataId).values,[I,$,E,D]=c,F=t.data.get(i.dataId).values,[L,z,M,O]=d,{batchSize:H,filterDepth:X,filterHeight:te,filterWidth:Z,inChannels:W,inDepth:ee,inHeight:ie,inWidth:de,outChannels:ge,outDepth:G,outHeight:re,outWidth:pe,strideDepth:ve,strideHeight:Ne,strideWidth:Ee}=p,_e=X-1-p.padInfo.front,je=te-1-p.padInfo.top,Be=Z-1-p.padInfo.left;for(let at=0;at<H;++at)for(let ot=0;ot<W;++ot)for(let Tt=0;Tt<ee;++Tt){const ut=Tt-_e,mt=Math.max(0,Math.ceil(ut/ve)),Bt=Math.min(G,(X+ut)/ve);for(let Ft=0;Ft<ie;++Ft){const Zt=Ft-je,qt=Math.max(0,Math.ceil(Zt/Ne)),Ps=Math.min(re,(te+Zt)/Ne);for(let yn=0;yn<de;++yn){const Js=yn-Be,os=Math.max(0,Math.ceil(Js/Ee)),ei=Math.min(pe,(Z+Js)/Ee);let Ut=0;for(let fr=mt;fr<Bt;++fr){const Bs=fr*ve-ut;for(let er=qt;er<Ps;++er){const tr=er*Ne-Zt;for(let na=os;na<ei;++na){const yo=na*Ee-Js,xo=I*at+$*fr+E*er+D*na,tc=L*(X-1-Bs)+z*(te-1-tr)+M*(Z-1-yo)+O*ot;for(let Vs=0;Vs<ge;++Vs){const ls=N[xo+Vs],Or=F[tc+Vs];Ut+=ls*Or}}}}g[x*at+b*Tt+v*Ft+w*yn+ot]=Ut}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const rQ={kernelName:jx,backendName:"cpu",kernelFunc:sQ};const iQ=Qt(Ph,n=>Math.cos(n)),aQ={kernelName:Ph,backendName:"cpu",kernelFunc:iQ};const oQ=Qt(Bh,n=>Math.cosh(n)),lQ={kernelName:Bh,backendName:"cpu",kernelFunc:oQ};function uQ(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:u,extrapolationValue:c}=s,[d,p,m,g]=r.shape,x=i.shape[0],[b,v]=o,w=ft([x,b,v,g],"float32"),N=t.data.get(i.dataId).values,I=t.data.get(a.dataId).values,$=t.data.get(r.dataId).values,E=Ze(r.shape),D=Ze(w.shape);for(let F=0;F<x;F++){const L=F*4,z=N[L],M=N[L+1],O=N[L+2],H=N[L+3],X=I[F];if(X>=d)continue;const te=b>1?(O-z)*(p-1)/(b-1):0,Z=v>1?(H-M)*(m-1)/(v-1):0;for(let W=0;W<b;W++){const ee=b>1?z*(p-1)+W*te:.5*(z+O)*(p-1);if(ee<0||ee>p-1){for(let ie=0;ie<v;ie++)for(let de=0;de<g;de++){const ge=de+ie*D[2]+W*D[1]+F*D[0];w.values[ge]=c}continue}if(u==="bilinear"){const ie=Math.floor(ee),de=Math.ceil(ee),ge=ee-ie;for(let G=0;G<v;G++){const re=v>1?M*(m-1)+G*Z:.5*(M+H)*(m-1);if(re<0||re>m-1){for(let Ee=0;Ee<g;Ee++){const _e=Ee+G*D[2]+W*D[1]+F*D[0];w.values[_e]=c}continue}const pe=Math.floor(re),ve=Math.ceil(re),Ne=re-pe;for(let Ee=0;Ee<g;Ee++){let _e=Ee+pe*E[2]+ie*E[1]+X*E[0];const je=$[_e];_e=Ee+ve*E[2]+ie*E[1]+X*E[0];const Be=$[_e];_e=Ee+pe*E[2]+de*E[1]+X*E[0];const at=$[_e];_e=Ee+ve*E[2]+de*E[1]+X*E[0];const ot=$[_e],Tt=je+(Be-je)*Ne,ut=at+(ot-at)*Ne;_e=Ee+G*D[2]+W*D[1]+F*D[0],w.values[_e]=Tt+(ut-Tt)*ge}}}else for(let ie=0;ie<v;++ie){const de=v>1?M*(m-1)+ie*Z:.5*(M+H)*(m-1);if(de<0||de>m-1){for(let re=0;re<g;re++){const pe=re+ie*D[2]+W*D[1]+F*D[0];w.values[pe]=c}continue}const ge=Math.round(de),G=Math.round(ee);for(let re=0;re<g;re++){const pe=re+ge*E[2]+G*E[1]+X*E[0],ve=re+ie*D[2]+W*D[1]+F*D[0];w.values[ve]=$[pe]}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const cQ={kernelName:Xx,backendName:"cpu",kernelFunc:uQ};function hQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;Ye(r,"cumprod");const u=sn([i],r.shape.length);let c=r;u!=null&&(c=dr({inputs:{x:r},backend:t,attrs:{perm:u}}));const d=mn(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=ys(c.dtype,"int32"),m=tS(ce(c.shape),p),g=t.data.get(c.dataId).values,x=c.shape[c.shape.length-1],b=o?(w,N)=>w+x-N-1:(w,N)=>w+N;for(let w=0;w<g.length;w+=x)for(let N=0;N<x;N++){const I=b(w,N);if(N===0)m[I]=a?1:g[I];else{const $=b(w,N-1);m[I]=a?g[$]*m[$]:g[I]*m[$]}}const v=t.makeTensorInfo(c.shape,p,m);if(u!=null){const w=$a(u),N=dr({inputs:{x:v},backend:t,attrs:{perm:w}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(c),N}return v}const dQ={kernelName:qx,backendName:"cpu",kernelFunc:hQ};function pQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;Ye(r,"cumsum");const u=sn([i],r.shape.length);let c=r;u!=null&&(c=dr({inputs:{x:r},backend:t,attrs:{perm:u}}));const d=mn(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=ys(c.dtype,"int32"),m=Ns(ce(c.shape),p),g=t.data.get(c.dataId).values,x=c.shape[c.shape.length-1],b=o?(w,N)=>w+x-N-1:(w,N)=>w+N;for(let w=0;w<g.length;w+=x)for(let N=0;N<x;N++){const I=b(w,N);if(N===0)m[I]=a?0:g[I];else{const $=b(w,N-1);m[I]=a?g[$]+m[$]:g[I]+m[$]}}const v=t.makeTensorInfo(c.shape,p,m);if(u!=null){const w=$a(u),N=dr({inputs:{x:v},backend:t,attrs:{perm:w}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(c),N}return v}const fQ={kernelName:Bf,backendName:"cpu",kernelFunc:pQ};function mQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const u=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=DC(u,c,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const u=t.bufferSync(r),c=t.bufferSync(i),d=zO(u,c,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const gQ={kernelName:Kx,backendName:"cpu",kernelFunc:mQ};function yQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s;B(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=r.shape[0],u=r.shape[1],c=r.shape[2],d=r.shape[3],p=u*i,m=c*i,g=d/(i*i),x=t.data.get(r.dataId).values,b=new Float32Array(o*p*m*g);let v=0;for(let w=0;w<o;++w)for(let N=0;N<p;++N){const I=Math.floor(N/i),$=N%i;for(let E=0;E<m;++E){const D=Math.floor(E/i),F=E%i,L=($*i+F)*g;for(let z=0;z<g;++z){const O=z+L+d*(D+c*(I+u*w));b[v++]=x[O]}}}return t.makeTensorInfo([o,p,m,g],r.dtype,b)}const xQ={kernelName:Yx,backendName:"cpu",kernelFunc:yQ};function LF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u,dimRoundingMode:c}=s;Ye([r,i],"depthwiseConv2DNative");const d=Ze(r.shape),p=Ze(i.shape);let m=u;m==null&&(m=[1,1]),B(is(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);const g=fn(r.shape,i.shape,a,m,o,c,!0),{filterHeight:x,filterWidth:b,dilationHeight:v,dilationWidth:w,padInfo:N}=g,I=N.left,$=N.top,E=g.outChannels/g.inChannels,D=new es(g.outShape,r.dtype),F=t.data.get(r.dataId).values,L=t.data.get(i.dataId).values,z=D.values;for(let M=0;M<g.batchSize;++M){const O=M*d[0],H=M*D.strides[0];for(let X=0;X<g.outHeight;++X){const te=H+X*D.strides[1],Z=X*g.strideHeight-$;for(let W=0;W<x;++W){const ee=Z+W*v;if(ee<0||ee>=g.inHeight)continue;const ie=W*p[0],de=O+ee*d[1];for(let ge=0;ge<g.outWidth;++ge){const G=te+ge*D.strides[2],re=ge*g.strideWidth-I;for(let pe=0;pe<b;++pe){const ve=re+pe*w;if(ve<0||ve>=g.inWidth)continue;const Ne=ie+pe*p[1],Ee=de+ve*g.inChannels;let _e=G,je=Ne;for(let Be=0;Be<g.inChannels;++Be){const at=F[Ee+Be];for(let ot=0;ot<E;++ot)z[_e+ot]+=at*L[je+ot];_e+=E,je+=E}}}}}}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const bQ={kernelName:Vf,backendName:"cpu",kernelFunc:LF};function vQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:c,filterShape:d}=s;Ye([r,i],"depthwiseConv2dNativeBackpropFilter");const p=fn(r.shape,d,a,o,u,c,!0),{strideHeight:m,strideWidth:g,filterHeight:x,filterWidth:b}=p,v=new es(p.filterShape,"float32"),w=p.padInfo.left,N=p.padInfo.top,I=p.outChannels/p.inChannels,$=t.data.get(r.dataId).values,E=new es(r.shape,r.dtype,$),D=t.data.get(i.dataId).values,F=new es(i.shape,i.dtype,D);for(let L=0;L<x;++L){const z=Math.max(0,Math.ceil((N-L)/m)),M=Math.min(p.outHeight,(p.inHeight+N-L)/m);for(let O=0;O<b;++O){const H=Math.max(0,Math.ceil((w-O)/g)),X=Math.min(p.outWidth,(p.inWidth+w-O)/g);for(let te=0;te<p.outChannels;++te){const Z=Math.trunc(te/I),W=te%I;let ee=0;for(let ie=0;ie<p.batchSize;++ie)for(let de=z;de<M;++de){const ge=L+de*m-N;for(let G=H;G<X;++G){const re=O+G*g-w;ee+=E.get(ie,ge,re,Z)*F.get(ie,de,G,te)}}v.set(ee,L,O,Z,W)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const wQ={kernelName:Qx,backendName:"cpu",kernelFunc:vQ};function SQ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:c,inputShape:d}=s;Ye([r,i],"depthwiseConv2DNativeBackpropInput");const p=Ze(r.shape),m=Ze(i.shape),g=fn(d,i.shape,a,o,u,c,!0),x=new es(g.inShape,"float32"),b=x.values,[v,w,N]=x.strides,I=t.data.get(r.dataId).values,[$,E,D]=p,F=t.data.get(i.dataId).values,[L,z,M]=m,{batchSize:O,filterHeight:H,filterWidth:X,inChannels:te,inHeight:Z,inWidth:W,outChannels:ee,outHeight:ie,outWidth:de,strideHeight:ge,strideWidth:G}=g,re=H-1-g.padInfo.top,pe=X-1-g.padInfo.left,ve=ee/te;for(let Ne=0;Ne<O;++Ne)for(let Ee=0;Ee<te;++Ee)for(let _e=0;_e<Z;++_e){const je=_e-re,Be=Math.max(0,Math.ceil(je/ge)),at=Math.min(ie,(H+je)/ge);for(let ot=0;ot<W;++ot){const Tt=ot-pe,ut=Math.max(0,Math.ceil(Tt/G)),mt=Math.min(de,(X+Tt)/G);let Bt=0;for(let Ft=Be;Ft<at;++Ft){const Zt=Ft*ge-je;for(let qt=ut;qt<mt;++qt){const Ps=qt*G-Tt,yn=$*Ne+E*Ft+D*qt,Js=L*(H-1-Zt)+z*(X-1-Ps)+M*Ee;for(let os=0;os<ve;++os){const ei=Ee*ve+os,Ut=I[yn+ei],fr=F[Js+os];Bt+=Ut*fr}}}b[v*Ne+w*_e+N*ot+Ee]=Bt}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const CQ={kernelName:Zx,backendName:"cpu",kernelFunc:SQ};function NQ(n){const{inputs:e,backend:t}=n,{x:s}=e,r=ce(s.shape),i=t.data.get(s.dataId).values,a=ft([r,r],s.dtype),o=a.values;for(let c=0;c<i.length;c++)o[c*r+c]=i[c];const u=[...s.shape,...s.shape];return t.makeTensorInfo(u,a.dtype,a.values)}const kQ={kernelName:Jx,backendName:"cpu",kernelFunc:NQ};const $Q={kernelName:Uf,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:a,dilations:o}=t,u=e,c=u.data.get(s.dataId).values,d=s.shape.length,p=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:g,inHeight:x,inWidth:b,inChannels:v,outHeight:w,outWidth:N,padInfo:I,strideHeight:$,strideWidth:E,filterHeight:D,filterWidth:F,dilationHeight:L,dilationWidth:z,outShape:M}=Nl(s.shape,r.shape,i,a,"NHWC",o),O=ce(M),H=M.length,X=En(s.dtype,O);for(let Z=0;Z<g;++Z)for(let W=0;W<w;++W){const ee=W*$-I.top;for(let ie=0;ie<N;++ie){const de=ie*E-I.left;for(let ge=0;ge<v;++ge){let G=Number.MIN_SAFE_INTEGER;for(let pe=0;pe<D;++pe){const ve=ee+pe*L;if(ve>=0&&ve<x)for(let Ne=0;Ne<F;++Ne){const Ee=de+Ne*z;if(Ee>=0&&Ee<b){const _e=ya([Z,ve,Ee,ge],d,Ze(s.shape)),je=ya([pe,Ne,ge],m,Ze(r.shape)),Be=c[_e]+p[je];Be>G&&(G=Be)}}}const re=ya([Z,W,ie,ge],H,Ze(M));X[re]=G}}}return{dataId:u.write(Bu(X,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}};const IQ={kernelName:Jy,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:u}=t,c=e,d=Si(s.shape,c.data.get(s.dataId).values),p=Si(r.shape,c.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:x,inChannels:b,outHeight:v,outWidth:w,padInfo:N,strideHeight:I,strideWidth:$,filterHeight:E,filterWidth:D,dilationHeight:F,dilationWidth:L,outShape:z}=Nl(s.shape,r.shape,a,o,"NHWC",u);B(i.rank===z.length,()=>`Error in ${Jy}, dy must have the same rank as output ${z.length}, but got ${i.rank}`);const M=Si(z,c.data.get(i.dataId).values),O=LR(r.shape,r.dtype);for(let X=0;X<m;++X)for(let te=0;te<v;++te){const Z=te*I-N.top;for(let W=0;W<w;++W){const ee=W*$-N.left;for(let ie=0;ie<b;++ie){let de=Number.MIN_SAFE_INTEGER,ge=0,G=0;for(let re=0;re<E;++re){const pe=Z+re*F;if(pe>=0&&pe<g)for(let ve=0;ve<D;++ve){const Ne=ee+ve*L;if(Ne>=0&&Ne<x){const Ee=d[X][pe][Ne][ie]+p[re][ve][ie];Ee>de&&(de=Ee,ge=re,G=ve)}}}O[ge][G][ie]+=M[X][te][W][ie]}}}return{dataId:c.write(Bu(O,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const TQ={kernelName:Zy,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:u}=t,c=e,d=Si(s.shape,c.data.get(s.dataId).values),p=Si(r.shape,c.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:x,inChannels:b,outHeight:v,outWidth:w,padInfo:N,strideHeight:I,strideWidth:$,filterHeight:E,filterWidth:D,dilationHeight:F,dilationWidth:L,outShape:z}=Nl(s.shape,r.shape,a,o,"NHWC",u);B(i.rank===z.length,()=>`Error in ${Zy}, dy must have the same rank as output ${z.length}, but got ${i.rank}`);const M=Si(z,c.data.get(i.dataId).values),O=LR(s.shape,s.dtype);for(let X=0;X<m;++X)for(let te=0;te<v;++te){const Z=te*I-N.top;for(let W=0;W<w;++W){const ee=W*$-N.left;for(let ie=0;ie<b;++ie){let de=Number.MIN_SAFE_INTEGER,ge=Z<0?0:Z,G=ee<0?0:ee;for(let re=0;re<E;++re){const pe=Z+re*F;if(pe>=0&&pe<g)for(let ve=0;ve<D;++ve){const Ne=ee+ve*L;if(Ne>=0&&Ne<x){const Ee=d[X][pe][Ne][ie]+p[re][ve][ie];Ee>de&&(de=Ee,ge=pe,G=Ne)}}}O[X][ge][G][ie]+=M[X][te][W][ie]}}}return{dataId:c.write(Bu(O,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function EQ(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,{contextOptions:o,imageOptions:u}=a||{},c=u?.alpha||1,d=o?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const p=i.getContext(d,o?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,g]=r.shape.slice(0,2),x=r.shape.length===2?1:r.shape[2],b=t.data.get(r.dataId).values,v=r.dtype==="float32"?255:1,w=new Uint8ClampedArray(g*m*4);for(let I=0;I<m*g;++I){const $=[0,0,0,255*c];for(let D=0;D<x;D++){const F=b[I*x+D];if(r.dtype==="float32"){if(F<0||F>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${F}.`)}else if(r.dtype==="int32"&&(F<0||F>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${F}.`);x===1?($[0]=F*v,$[1]=F*v,$[2]=F*v):$[D]=F*v}const E=I*4;w[E+0]=Math.round($[0]),w[E+1]=Math.round($[1]),w[E+2]=Math.round($[2]),w[E+3]=Math.round($[3])}i.width=g,i.height=m;const N=new ImageData(w,g,m);return p.putImageData(N,0,0),r}const RQ={kernelName:sS,backendName:"cpu",kernelFunc:EQ};function jm(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Ye(r,"sum");let o;r.dtype==="bool"?o=xl({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):o=Ca({inputs:{x:r},backend:t});const u=o.shape.length,c=gt(i,o.shape),d=sn(c,u);let p=c,m=o;d!=null&&(m=dr({inputs:{x:o},backend:t,attrs:{perm:d}}),p=mn(p.length,u)),Hn("sum",p,m.shape.length);const[g,x]=Mn(m.shape,p),b=ys(m.dtype,"int32");let v=xx(t,g,b);const w=ce(x),N=t.data.get(v.dataId).values,I=t.data.get(m.dataId).values;for(let $=0;$<N.length;++$){const E=$*w;let D=0;for(let F=0;F<w;++F)D+=I[E+F];N[$]=D}if(a){const $=Dn(v.shape,c),E=v;v=pn({inputs:{x:v},backend:t,attrs:{shape:$}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(o),d!=null&&t.disposeIntermediateTensorInfo(m),v}const AQ={kernelName:wm,backendName:"cpu",kernelFunc:jm};function DQ(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:u}=vb(r,i.length);Sb(a.length,u,i);const{path:c,steps:d}=Cb(o,u),p=d.length;let m=null,g=a.length;const x=[];for(let b=0;b<p;++b){for(const v of d[b]){const{permutationIndices:w,expandDims:N}=wb(g,u[v]);let I;Nb(w)?I=i[v]:(I=dr({inputs:{x:i[v]},backend:t,attrs:{perm:w}}),x.push(I));const $=I.shape.slice();for(let E=0;E<N.length;++E)$.splice(N[E],0,1);xt(I.shape,$)||(I=pn({inputs:{x:I},backend:t,attrs:{shape:$}}),x.push(I)),m===null?m=I:(m=Mb({inputs:{a:I,b:m},backend:t}),x.push(m))}b<p-1&&(c[b]>=0&&(m=jm({inputs:{x:m},backend:t,attrs:{axis:c[b]-(a.length-g),keepDims:!1}}),x.push(m)),g--)}for(const b of x)b!==m&&t.disposeIntermediateTensorInfo(b);return m}const _Q={kernelName:e0,backendName:"cpu",kernelFunc:DQ};function OQ(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;Ye([s,r],"eluGrad");const i=new Float32Array(ce(r.shape)),a=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values;for(let u=0;u<a.length;++u){const c=a[u];c>=0?i[u]=o[u]:i[u]=o[u]*(c+1)}return t.makeTensorInfo(r.shape,"float32",i)}const FQ={kernelName:t0,backendName:"cpu",kernelFunc:OQ};const zQ=fb,LQ=mb,MQ=gb,PQ=yb,BQ=xb,VQ=bb,UQ=Qt(Wh,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+zQ*t);return e*(1-((((VQ*s+BQ)*s+PQ)*s+MQ)*s+LQ)*s*Math.exp(-t*t))}),WQ={kernelName:Wh,backendName:"cpu",kernelFunc:UQ};function wx(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,a=r.shape.length,o=r.shape.slice();let u=i;return i<0&&(B(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+i+1),o.splice(u,0,1),pn({inputs:{x:r},backend:t,attrs:{shape:o}})}const GQ={kernelName:Gf,backendName:"cpu",kernelFunc:wx};const HQ=Bn((n,e)=>n/e),MC=as(Vh,HQ),O2={kernelName:Vh,backendName:"cpu",kernelFunc:MC};function MF(n,e,t){const s=n.shape,r=s[0],i=s[1],a=t.data.get(n.dataId),o=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,c=[r,i],d=ce(c),p=ss("float32",d),m=ss("float32",d);for(let v=0;v<r;v++){const w=Fu({inputs:{x:o},backend:t,attrs:{begin:[v,0],size:[1,i]}}),N=Fu({inputs:{x:u},backend:t,attrs:{begin:[v,0],size:[1,i]}}),I=kr({inputs:{real:w,imag:N},backend:t}),{real:$,imag:E}=jQ(I,e,t),D=Xi($,E);for(let F=0;F<i;F++){const L=aC(D,F);p[v*i+F]=L.real,m[v*i+F]=L.imag}t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(I)}const g=t.makeTensorInfo(c,"float32",p),x=t.makeTensorInfo(c,"float32",m),b=kr({inputs:{real:g,imag:x},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),b}function jQ(n,e,t){const s=ce(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(qQ(s)){const o=F2(i,a,s,e,t),u=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(u,"float32",o.real),d=t.makeTensorInfo(u,"float32",o.imag),p=t.makeTensorInfo([],"float32",wl(s,"float32")),m=Ca({inputs:{x:p},backend:t}),g=O2.kernelFunc({inputs:{a:c,b:p},backend:t}),x=O2.kernelFunc({inputs:{a:d,b:m},backend:t}),b=t.data.get(g.dataId).values,v=t.data.get(x.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),{real:b,imag:v}}return o}else{const o=Xi(i,a),u=XQ(o,s,e);return XA(u)}}function qQ(n){return(n&n-1)===0}function F2(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=Xi(n,e),a=t/2,o=KA(i),u=o.real,c=o.imag,d=[u.length],p=r.makeTensorInfo(d,"float32",u),m=r.makeTensorInfo(d,"float32",c),g=kr({inputs:{real:p,imag:m},backend:r}),x=YA(i),b=x.real,v=x.imag,w=[b.length],N=r.makeTensorInfo(w,"float32",b),I=r.makeTensorInfo(w,"float32",v),$=kr({inputs:{real:N,imag:I},backend:r}),E=F2(u,c,a,s,r),D=E.real,F=E.imag,L=[D.length],z=r.makeTensorInfo(L,"float32",D),M=r.makeTensorInfo(L,"float32",F),O=kr({inputs:{real:z,imag:M},backend:r}),H=F2(b,v,a,s,r),X=H.real,te=H.imag,Z=[X.length],W=r.makeTensorInfo(Z,"float32",X),ee=r.makeTensorInfo(Z,"float32",te),ie=kr({inputs:{real:W,imag:ee},backend:r}),de=ZA(t,s),ge=[de.real.length],G=r.makeTensorInfo(ge,"float32",de.real),re=r.makeTensorInfo(ge,"float32",de.imag),pe=kr({inputs:{real:G,imag:re},backend:r}),ve=Mb({inputs:{a:pe,b:ie},backend:r}),Ne=yh({inputs:{a:O,b:ve},backend:r}),Ee=zC({inputs:{a:O,b:ve},backend:r}),_e=Ou({inputs:{input:Ne},backend:r}),je=Ou({inputs:{input:Ee},backend:r}),Be=xh({inputs:{input:Ne},backend:r}),at=xh({inputs:{input:Ee},backend:r}),ot=bh({inputs:[_e,je],backend:r,attrs:{axis:0}}),Tt=bh({inputs:[Be,at],backend:r,attrs:{axis:0}}),ut=r.data.get(ot.dataId).values,mt=r.data.get(Tt.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo(Ne),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(_e),r.disposeIntermediateTensorInfo(Be),r.disposeIntermediateTensorInfo(je),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(ot),r.disposeIntermediateTensorInfo(Tt),{real:ut,imag:mt}}function XQ(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,a=0;for(let o=0;o<e;o++){const u=JA(r*o,e,t),c=aC(n,o);i+=c.real*u.real-c.imag*u.imag,a+=c.real*u.imag+c.imag*u.real}t&&(i/=e,a/=e),QA(s,i,a,r)}return s}function KQ(n){const{inputs:e,backend:t}=n,{input:s}=e,r=ce(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=pn({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),u=MF(o,!1,t),c=pn({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),c}const YQ={kernelName:n0,backendName:"cpu",kernelFunc:KQ};function PC(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,a=i||Mu(r),o=En(a,ce(s));return ZQ(o,r,a),e.makeTensorInfo(s,a,o)}const QQ={kernelName:s0,backendName:"cpu",kernelFunc:PC};function ZQ(n,e,t){n.fill(e)}const JQ={kernelName:r0,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=ss(s.dtype,ce(s.shape)),[a,o,u,c]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<a;m++){const g=m*u*o*c;for(let x=0;x<o;x++){const b=x*(u*c);for(let v=0;v<u;v++){const w=v*c;for(let N=0;N<c;N++){const I=Math.round(u-v-1),$=g+b+w+N;let E=d[$];if(I>=0&&I<u){const D=I*c,F=g+b+D+N;E=d[F]}i[$]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function eZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s;let b=zF({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:m}});if(a){const v=b;if(d==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const w=pn({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});b=yh({inputs:{a:b,b:w},backend:t}),t.disposeIntermediateTensorInfo(w)}else b=yh({inputs:{a:b,b:a},backend:t});t.disposeIntermediateTensorInfo(v)}if(g){const v=b;if(d==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const w=pn({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});b=vx(t,b,g,w,x),t.disposeIntermediateTensorInfo(w)}else b=vx(t,b,g,o,x);t.disposeIntermediateTensorInfo(v)}return b}const tZ={kernelName:af,backendName:"cpu",kernelFunc:eZ};function nZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s;let b=LF({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:m}});if(a){const v=b;b=yh({inputs:{a:b,b:a},backend:t}),t.disposeIntermediateTensorInfo(v)}if(g){const v=b;b=vx(t,b,g,o,x),t.disposeIntermediateTensorInfo(v)}return b}const sZ={kernelName:of,backendName:"cpu",kernelFunc:nZ};function rZ(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=ce(s.shape),a=r.shape,o=a[a.length-1],[u,c,d,p]=ib(s,r);if(c===0)return t.makeTensorInfo(u,s.dtype,[]);const m=t.data.get(r.dataId).values,g=t.bufferSync(s),x=qO(m,g,s.dtype,c,o,d,p,s.shape,i);return t.makeTensorInfo(u,s.dtype,x.values)}const iZ={kernelName:i0,backendName:"cpu",kernelFunc:rZ};function aZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s;Ye([r,i],"gatherV2");const u=gt(a,r.shape)[0],c=t.data.get(i.dataId).values,d=r.shape[u];for(let $=0;$<c.length;++$){const E=c[$];B(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=o;o==null&&(p=0);const m=ce(i.shape),g=$b(r,i,u,p),x=pn({inputs:{x:r},backend:t,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),b=pn({inputs:{x:i},backend:t,attrs:{shape:[g.batchSize,m/g.batchSize]}}),v=[g.batchSize,g.outerSize,m/g.batchSize,g.sliceSize],w=t.bufferSync(b),N=t.bufferSync(x),I=XO(N,w,v);return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.makeTensorInfo(g.outputShape,I.dtype,I.values)}const oZ={kernelName:jf,backendName:"cpu",kernelFunc:aZ};function lZ(n){const{inputs:e,backend:t}=n,{input:s}=e,r=ce(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=pn({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),u=MF(o,!0,t),c=pn({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),c}const uZ={kernelName:a0,backendName:"cpu",kernelFunc:lZ};const cZ=Qt(Yh,n=>Number.isFinite(n)?1:0,"bool"),hZ={kernelName:Yh,backendName:"cpu",kernelFunc:cZ};const dZ=Qt(Qh,n=>Math.abs(n)===1/0?1:0,"bool"),pZ={kernelName:Qh,backendName:"cpu",kernelFunc:dZ};const fZ=Qt(Zh,n=>Number.isNaN(n)?1:0,"bool"),mZ={kernelName:Zh,backendName:"cpu",kernelFunc:fZ};function gZ(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=JO(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const yZ={kernelName:l0,backendName:"cpu",kernelFunc:gZ};const xZ=Qt(ed,n=>Math.log1p(n)),bZ={kernelName:ed,backendName:"cpu",kernelFunc:xZ};const vZ=Bn((n,e)=>n&&e),wZ=as(Qf,vZ,null,"bool"),SZ={kernelName:Qf,backendName:"cpu",kernelFunc:wZ};const CZ=Qt(Zf,n=>n?0:1,"bool"),NZ={kernelName:Zf,backendName:"cpu",kernelFunc:CZ};const kZ=Bn((n,e)=>n||e),$Z=as(Jf,kZ,null,"bool"),IZ={kernelName:Jf,backendName:"cpu",kernelFunc:$Z};function TZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:u}=s;Ye(r,"LRN");const c=r.shape[3],d=c-1,p=t.data.get(r.dataId).values,m=ce(r.shape),g=new Float32Array(m);function x(b){const v=b%c;let w=b-v+Math.max(0,v-i);const N=b-v+Math.min(v+i,d);let I=0;for(;w<=N;w++){const $=p[w];I+=$*$}return I}for(let b=0;b<m;b++){const v=x(b),w=p[b]*Math.pow(a+o*v,-u);g[b]=w}return t.makeTensorInfo(r.shape,r.dtype,g)}const EZ={kernelName:em,backendName:"cpu",kernelFunc:TZ};function RZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:u,alpha:c,beta:d}=s;Ye(a,"LRNGrad");const p=ce(a.shape),m=a.shape[3],g=t.data.get(a.dataId).values,x=t.data.get(r.dataId).values,b=t.data.get(i.dataId).values,v=new Float32Array(p),w=p;for(let N=0;N<w;N++){const I=N%m,$=N-I+Math.max(0,I-o),E=N-I+Math.min(m,I+o+1);let D=0;for(let F=$;F<E;F++)D+=Math.pow(x[F],2);D=c*D+u;for(let F=$;F<E;F++){let L=-2*c*d*x[F]*b[N]/D;N===F&&(L+=Math.pow(D,-d)),L*=g[N],v[F]+=L}}return t.makeTensorInfo(a.shape,r.dtype,v)}const AZ={kernelName:u0,backendName:"cpu",kernelFunc:RZ};function PF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=t;let u=r.shape;const c=u.length,d=gt(i,u);let p=d;const m=sn(p,c);let g=o.data.get(r.dataId).values;if(m!=null){const $=new Array(c);for(let E=0;E<$.length;E++)$[E]=u[m[E]];g=OC(g,u,r.dtype,m,$),p=mn(p.length,c),u=$}Ye(r,"max"),Hn("max",p,c);const[x,b]=Mn(u,p),v=ce(b),w=tF(g,v,x,r.dtype),N=o.write(w,x,r.dtype);let I=x;return a&&(I=Dn(x,d)),{dataId:N,shape:I,dtype:r.dtype}}const DZ={kernelName:tm,backendName:"cpu",kernelFunc:PF};function _Z(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Ye(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,c=1;B(is(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=zs(r.shape,i,a,c,o,u);let p;if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))p=Ca({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,g=Ze(r.shape),x=LC(m,r.shape,r.dtype,g,d,"max");p=t.makeTensorInfo(d.outShape,r.dtype,x.values)}return p}const OZ={kernelName:nm,backendName:"cpu",kernelFunc:_Z};function FZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:c}=s;Ye(r,"maxPool3d");const d=Qr(r.shape,i,a,1,o,u,c),p=t.data.get(r.dataId).values,m=FF(p,r.shape,r.dtype,Ze(r.shape),d,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const zZ={kernelName:sm,backendName:"cpu",kernelFunc:FZ};function LZ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:u,dimRoundingMode:c}=s;Ye([r,i],"maxPool3DGrad");const d=Qr(i.shape,a,o,1,u,c),p=t.bufferSync(i),m=kY(p,d),g=d.strideDepth,x=d.strideHeight,b=d.strideWidth,v=d.dilationDepth,w=d.dilationHeight,N=d.dilationWidth,I=d.effectiveFilterDepth,$=d.effectiveFilterHeight,E=d.effectiveFilterWidth,D=I-1-d.padInfo.front,F=E-1-d.padInfo.left,L=$-1-d.padInfo.top,z=ft(i.shape,"float32"),M=t.bufferSync(r);for(let O=0;O<d.batchSize;++O)for(let H=0;H<d.inChannels;++H)for(let X=0;X<d.inDepth;++X)for(let te=0;te<d.inHeight;++te)for(let Z=0;Z<d.inWidth;++Z){const W=X-D,ee=te-L,ie=Z-F;let de=0;for(let ge=0;ge<I;ge+=v){const G=(W+ge)/g;if(!(G<0||G>=d.outDepth||Math.floor(G)!==G))for(let re=0;re<$;re+=w){const pe=(ee+re)/x;if(!(pe<0||pe>=d.outHeight||Math.floor(pe)!==pe))for(let ve=0;ve<E;ve+=N){const Ne=(ie+ve)/b;if(Ne<0||Ne>=d.outWidth||Math.floor(Ne)!==Ne)continue;const Ee=I*$*E-1-m.get(O,G,pe,Ne,H),_e=ge*$*E+re*E+ve,je=Ee===_e?1:0;if(je===0)continue;const Be=M.get(O,G,pe,Ne,H);de+=Be*je}}}z.set(de,O,X,te,Z,H)}return t.makeTensorInfo(z.shape,z.dtype,z.values)}const MZ={kernelName:h0,backendName:"cpu",kernelFunc:LZ};function PZ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;Ye([i,a],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=s,m=zs(o.shape,u,c,1,d,p),g=t.data.get(o.dataId).values,x=ft(m.outShape,o.dtype,OF(g,o.shape,o.dtype,m).values),b=m.strideHeight,v=m.strideWidth,w=m.dilationHeight,N=m.dilationWidth,I=m.effectiveFilterHeight,$=m.effectiveFilterWidth,E=$-1-m.padInfo.left,D=I-1-m.padInfo.top,F=ft(o.shape,"float32"),L=t.data.get(r.dataId).values,z=ft(r.shape,"float32",L);for(let M=0;M<m.batchSize;++M)for(let O=0;O<m.inChannels;++O)for(let H=0;H<m.inHeight;++H)for(let X=0;X<m.inWidth;++X){const te=H-D,Z=X-E;let W=0;for(let ee=0;ee<I;ee+=w){const ie=(te+ee)/b;if(!(ie<0||ie>=m.outHeight||Math.floor(ie)!==ie))for(let de=0;de<$;de+=N){const ge=(Z+de)/v;if(ge<0||ge>=m.outWidth||Math.floor(ge)!==ge)continue;const G=I*$-1-x.get(M,ie,ge,O),re=ee*$+de,pe=G===re?1:0;if(pe===0)continue;const ve=z.get(M,ie,ge,O);W+=ve*pe}}F.set(W,M,H,X,O)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const BZ={kernelName:c0,backendName:"cpu",kernelFunc:PZ};function VZ(n,e,t,s,r){const i=Ze(e),a=LC(n,e,t,i,r,"max"),o=OF(n,e,t,r,!0,s);return[a.values,o.values]}const UZ={kernelName:d0,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,u=t;Ye(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,d=zs(s.shape,r,i,[1,1],a),[p,m]=VZ(c,s.shape,s.dtype,o,d),g=u.write(p,d.outShape,s.dtype),x=u.write(m,d.outShape,s.dtype);return[{dataId:g,shape:d.outShape,dtype:s.dtype},{dataId:x,shape:d.outShape,dtype:"int32"}]}};function WZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=gt(i,r.shape),c=Mn(r.shape,o)[1],d=ce(c),p=[],m=t.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const g=xl({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});p.push(g);const x=MC({inputs:{a:g,b:m},backend:t});p.push(x);const b=jm({inputs:{x},backend:t,attrs:{axis:i,keepDims:a}});return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),b}const GZ={kernelName:rm,backendName:"cpu",kernelFunc:WZ};function HZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Ye(r,"min");const o=gt(i,r.shape);let u=o;const c=sn(u,r.shape.length);let d=r;c!=null&&(d=dr({inputs:{x:r},backend:t,attrs:{perm:c}}),u=mn(u.length,r.shape.length)),Hn("min",u,d.shape.length);const[p,m]=Mn(d.shape,u),g=ce(m),x=Ns(ce(p),d.dtype),b=t.data.get(d.dataId).values;for(let w=0;w<x.length;++w){const N=w*g;let I=b[N];for(let $=0;$<g;++$){const E=b[N+$];(Number.isNaN(E)||E<I)&&(I=E)}x[w]=I}c!=null&&t.disposeIntermediateTensorInfo(d);const v=t.makeTensorInfo(p,d.dtype,x);if(a){const w=Dn(p,o),N=pn({inputs:{x:v},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(v),N}return v}const jZ={kernelName:im,backendName:"cpu",kernelFunc:HZ};function qZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:a}=s;Ye(r,"mirrorPad");const o=i.map((I,$)=>I[0]+r.shape[$]+I[1]),u=i.map(I=>I[0]),c=i.map((I,$)=>I[0]+r.shape[$]),d=a==="reflect"?0:1,p=t.data.get(r.dataId).values,m=r.shape.length,g=Ze(r.shape),x=ce(o),b=o.length,v=Ze(o),w=ss(r.dtype,x);for(let I=0;I<x;I++){let $=Th(I,b,v);for(let D=0;D<b;D++)$[D]<u[D]?$[D]=u[D]*2-$[D]-d:$[D]>=c[D]&&($[D]=(c[D]-1)*2-$[D]+d);$=$.map((D,F)=>D-u[F]);const E=ya($,m,g);w[I]=p[E]}return{dataId:t.write(w,o,r.dtype),shape:o,dtype:r.dtype}}const XZ={kernelName:am,backendName:"cpu",kernelFunc:qZ};const KZ=Bn(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),YZ=as(sd,KZ),QZ={kernelName:sd,backendName:"cpu",kernelFunc:YZ};function BF(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=r.shape.length;let o=i;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const u=gt([o],r.shape),c=PF({inputs:{x:r},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),d=Dn(c.shape,u),p=pn({inputs:{x:c},backend:t,attrs:{shape:d}}),m=zC({inputs:{a:r,b:p},backend:t}),g=WO({inputs:{x:m},backend:t}),x=jm({inputs:{x:g},backend:t,attrs:{axis:u,keepDims:!1}}),b=pn({inputs:{x},backend:t,attrs:{shape:d}}),v=MC({inputs:{a:g,b},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),v}const ZZ={kernelName:Nm,backendName:"cpu",kernelFunc:BF};function JZ(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s;Ye(r,"multinomial");const u=o?r:BF({inputs:{logits:r},backend:t,attrs:{dim:-1}}),c=u.shape[0],d=u.shape[1],p=t.data.get(u.dataId).values,m=[c,i],g=Ns(ce(m),"int32");for(let x=0;x<c;++x){const b=x*d,v=new Float32Array(d-1);v[0]=p[b];for(let I=1;I<v.length;++I)v[I]=v[I-1]+p[b+I];const w=q0.alea(a.toString()),N=x*i;for(let I=0;I<i;++I){const $=w();g[N+I]=v.length;for(let E=0;E<v.length;E++)if($<v[E]){g[N+I]=E;break}}}return o||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(m,"int32",g)}const eJ={kernelName:p0,backendName:"cpu",kernelFunc:JZ};const tJ=sb;function nJ(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s;Ye(r,"NonMaxSuppression");const c=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:p}=tJ(c,d,a,o,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const sJ={kernelName:f0,backendName:"cpu",kernelFunc:nJ};const rJ=QS;function iJ(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=s;Ye(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,{selectedIndices:m,validOutputs:g}=rJ(d,p,a,o,u,c);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const aJ={kernelName:rS,backendName:"cpu",kernelFunc:iJ};const oJ=rb;function lJ(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=s;Ye(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,m=a,g=o,x=u,b=c,{selectedIndices:v,selectedScores:w}=oJ(d,p,m,g,x,b);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const uJ={kernelName:m0,backendName:"cpu",kernelFunc:lJ};function cJ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:u}=s;Ye(r,"oneHot");const c=ce(r.shape),d=new Float32Array(c*a);d.fill(u);const p=t.data.get(r.dataId).values;for(let m=0;m<c;++m)p[m]>=0&&p[m]<a&&(d[m*a+p[m]]=o);return t.makeTensorInfo([...r.shape,a],i,d)}const hJ={kernelName:cm,backendName:"cpu",kernelFunc:cJ};function Sx(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ou({inputs:{input:s},backend:t}),i=Sx({inputs:{x:r},backend:t}),a=xh({inputs:{input:s},backend:t}),o=Sx({inputs:{x:a},backend:t}),u=kr({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return PC({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const dJ={kernelName:Im,backendName:"cpu",kernelFunc:Sx};function VF(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ou({inputs:{input:s},backend:t}),i=VF({inputs:{x:r},backend:t}),a=xh({inputs:{input:s},backend:t}),o=Sx({inputs:{x:a},backend:t}),u=kr({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return PC({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const pJ={kernelName:um,backendName:"cpu",kernelFunc:VF};function UF(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return wx({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{pr(i,d.shape,"All tensors passed to stack must have matching shapes"),B(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(d=>{const p=wx({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),c=bh({inputs:u,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const fJ={kernelName:hm,backendName:"cpu",kernelFunc:UF};function mJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;Ye(r,"pad");const o=i.map((N,I)=>N[0]+r.shape[I]+N[1]),u=i.map(N=>N[0]),c=t.data.get(r.dataId).values,d=ce(r.shape),p=r.shape.length,m=Ze(r.shape),g=ce(o),x=o.length,b=Ze(o),v=ss(r.dtype,g);a!==0&&v.fill(a);for(let N=0;N<d;N++){const $=Th(N,p,m).map((D,F)=>D+u[F]),E=ya($,x,b);v[E]=c[N]}return{dataId:t.write(v,o,r.dtype),shape:o,dtype:r.dtype}}const WF={kernelName:dm,backendName:"cpu",kernelFunc:mJ};const gJ=Bn((n,e)=>Math.pow(n,e)),yJ=as(id,gJ),xJ={kernelName:id,backendName:"cpu",kernelFunc:yJ};function bJ(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,u=r.map(w=>t.data.get(w.dataId).values),c=r.map(w=>w.shape),d=t.data.get(i.dataId).values,p=t.data.get(a.dataId).values,[m,g,x]=oF(u,c,d,i.shape,i.dtype,p,a.shape),b=m.map(w=>t.makeTensorInfo([w.length],"int32",w)),v=t.makeTensorInfo(x,i.dtype,g);return b.concat([v])}const vJ={kernelName:iS,backendName:"cpu",kernelFunc:bJ};function wJ(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[c,d]=lF(a,s.shape,s.dtype,o,r.shape,u,i.shape),p=t.makeTensorInfo([c.length],"int32",c),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const SJ={kernelName:aS,backendName:"cpu",kernelFunc:wJ};function CJ(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:u}=s,c=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,p=t.data.get(a.dataId).values,m=o.map(v=>t.data.get(v.dataId).values),g=o.map(v=>v.shape),[x,b]=uF(c,r.shape,d,i.shape,i.dtype,p,a.shape,m,g,u);return t.makeTensorInfo(x,i.dtype,b)}const NJ={kernelName:oS,backendName:"cpu",kernelFunc:CJ};function kJ(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:a}=t,o=cF(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}const $J={kernelName:g0,backendName:"cpu",kernelFunc:kJ};const IJ=Qt(ad,n=>1/n),TJ={kernelName:ad,backendName:"cpu",kernelFunc:IJ};function EJ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;Ye(r,"resizeBilinear");const u=Ze(r.shape),[c,d]=o,[p,m,g,x]=r.shape,b=t.data.get(r.dataId).values,v=new Float32Array(ce([p,c,d,x])),w=[i&&c>1?m-1:m,i&&d>1?g-1:g],N=[i&&c>1?c-1:c,i&&d>1?d-1:d];let I=0;const $=w[0]/N[0],E=w[1]/N[1];for(let D=0;D<p;D++)for(let F=0;F<c;F++){let L;a?L=$*(F+.5)-.5:L=$*F;const z=Math.max(0,Math.floor(L)),M=L-z,O=Math.min(m-1,Math.ceil(L)),H=D*u[0]+z*u[1],X=D*u[0]+O*u[1];for(let te=0;te<d;te++){let Z;a?Z=E*(te+.5)-.5:Z=E*te;const W=Math.max(0,Math.floor(Z)),ee=Z-W,ie=Math.min(g-1,Math.ceil(Z)),de=H+W*u[2],ge=X+W*u[2],G=H+ie*u[2],re=X+ie*u[2];for(let pe=0;pe<x;pe++){const ve=b[de+pe],Ne=b[ge+pe],Ee=b[G+pe],_e=b[re+pe],je=ve+(Ee-ve)*ee,Be=Ne+(_e-Ne)*ee,at=je+(Be-je)*M;v[I++]=at}}}return t.makeTensorInfo([p,c,d,x],"float32",v)}const RJ={kernelName:ym,backendName:"cpu",kernelFunc:EJ};function AJ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;Ye([i,r],"resizeBilinearGrad");const o=Ze(r.shape),[u,c,d,p]=r.shape,[,m,g]=i.shape,x=new Float32Array(u*c*d*p),b=[a&&m>1?c-1:c,a&&g>1?d-1:d],v=[a&&m>1?m-1:m,a&&g>1?g-1:g],w=b[0]/v[0],N=b[1]/v[1],I=t.data.get(i.dataId).values;let $=0;for(let E=0;E<u;E++){const D=E*o[0];for(let F=0;F<m;F++){const L=F*w,z=Math.floor(L),M=Math.min(Math.ceil(L),c-1),O=D+z*o[1],H=D+M*o[1],X=L-z,te=1-X;for(let Z=0;Z<g;Z++){const W=Z*N,ee=Math.floor(W),ie=Math.min(Math.ceil(W),d-1),de=W-ee,ge=1-de,G=O+ee*o[2],re=O+ie*o[2],pe=H+ee*o[2],ve=H+ie*o[2],Ne=te*ge,Ee=te*de,_e=X*ge,je=X*de;for(let Be=0;Be<p;Be++){const at=I[$++];x[G+Be]+=at*Ne,x[re+Be]+=at*Ee,x[pe+Be]+=at*_e,x[ve+Be]+=at*je}}}}return t.makeTensorInfo([u,d,c,p],"float32",x)}const DJ={kernelName:b0,backendName:"cpu",kernelFunc:AJ};function _J(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;Ye(r,"resizeNearestNeighbor");const u=Ze(r.shape),[c,d]=o,[p,m,g,x]=r.shape,b=t.data.get(r.dataId).values,v=new Float32Array(p*c*d*x),w=[i&&c>1?m-1:m,i&&d>1?g-1:g],N=[i&&c>1?c-1:c,i&&d>1?d-1:d],I=w[0]/N[0],$=w[1]/N[1];let E=0;for(let D=0;D<p;D++){const F=D*u[0];for(let L=0;L<c;L++){const z=a?I*(L+.5):I*L;let M=Math.min(m-1,i?Math.round(z):Math.floor(z));a&&(M=Math.max(0,M));const O=F+M*u[1];for(let H=0;H<d;H++){const X=a?$*(H+.5):$*H;let te=Math.min(g-1,i?Math.round(X):Math.floor(X));a&&(te=Math.max(0,te));const Z=O+te*u[2];for(let W=0;W<x;W++){const ee=b[Z+W];v[E++]=ee}}}}return t.makeTensorInfo([p,c,d,x],r.dtype,v)}const OJ={kernelName:gm,backendName:"cpu",kernelFunc:_J};function FJ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;Ye([i,r],"resizeNearestNeighborGrad");const o=Ze(r.shape),u=Ze(i.shape),[c,d,p,m]=r.shape,[,g,x]=i.shape,b=new Float32Array(c*d*p*m),v=t.data.get(i.dataId).values,w=[a&&g>1?d-1:d,a&&x>1?p-1:p],N=[a&&g>1?g-1:g,a&&x>1?x-1:x],I=w[0]/N[0],$=w[1]/N[1],E=1/I,D=1/$,F=Math.ceil(E)*2+2,L=Math.ceil(D)*2+2;for(let z=0;z<c;z++){const M=z*o[0];for(let O=0;O<d;O++){const H=M+O*o[1],X=Math.floor(O*E),te=Math.floor(X-F/2);for(let Z=0;Z<p;Z++){const W=H+Z*o[2],ee=Math.floor(Z*D),ie=Math.floor(ee-L/2);for(let de=0;de<m;de++){let ge=0;for(let G=0;G<F;G++){const re=G+te;if(re<0||re>=g)continue;const pe=M+re*u[1],ve=re*I,Ne=Math.min(d-1,a?Math.round(ve):Math.floor(ve));if(O===Ne)for(let Ee=0;Ee<L;Ee++){const _e=Ee+ie;if(_e<0||_e>=x)continue;const je=pe+_e*u[2],Be=_e*$,at=Math.min(p-1,a?Math.round(Be):Math.floor(Be));Z===at&&(ge+=v[je+de])}}b[W+de]=ge}}}}return t.makeTensorInfo(r.shape,r.dtype,b)}const zJ={kernelName:x0,backendName:"cpu",kernelFunc:FJ};function LJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;Ye(r,"reverse");const a=r.shape.length,o=gt(i,r.shape);if(a===0)return Ca({inputs:{x:r},backend:t});const u=new es(r.shape,r.dtype),c=t.bufferSync(r);for(let d=0;d<u.size;d++){const p=u.indexToLoc(d),m=p.slice();o.forEach(g=>m[g]=r.shape[g]-1-m[g]),u.set(c.get(...m),...p)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}const MJ={kernelName:xm,backendName:"cpu",kernelFunc:LJ};const PJ={kernelName:D0,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,u=ss(s.dtype,ce(s.shape)),[c,d,p,m]=s.shape,[g,x]=hb(a,d,p),b=255,v=Math.sin(r),w=Math.cos(r),N=o.data.get(s.dataId).values;for(let $=0;$<c;$++){const E=$*p*d*m;for(let D=0;D<d;D++){const F=D*(p*m);for(let L=0;L<p;L++){const z=L*m;for(let M=0;M<m;M++){const O=[c,D,L,M],H=O[2],X=O[1];let te=(H-g)*w-(X-x)*v,Z=(H-g)*v+(X-x)*w;te=Math.round(te+g),Z=Math.round(Z+x);let W=i;if(typeof i!="number"&&(M===3?W=b:W=i[M]),te>=0&&te<p&&Z>=0&&Z<d){const ie=Z*(p*m),de=te*m,ge=E+ie+de+M;W=N[ge]}const ee=E+F+z+M;u[ee]=W}}}}return{dataId:o.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const BJ=Qt(ud,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),VJ={kernelName:ud,backendName:"cpu",kernelFunc:BJ};function UJ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Ta(i,r,a),m=!0,g=t.bufferSync(r),x=t.bufferSync(i),b=mu(g,x,a,p,c,u,o,d,0,m);return t.makeTensorInfo(a,b.dtype,b.values)}const WJ={kernelName:v0,backendName:"cpu",kernelFunc:UJ};function GJ(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function HJ(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function jJ(n,e,t,s,r,i){const a=En("int32",t*r);for(let o=0;o<t;++o){const u=n.slice(o*s,(o+1)*s),c=o*r;for(let d=0;d<r;++d)a[c+d]=i==="left"?GJ(u,e[d+c]):HJ(u,e[d+c])}return a}function qJ(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,c=jJ(o,u,r.shape[0],r.shape[1],i.shape[1],a);return t.makeTensorInfo(i.shape,"int32",c)}const XJ={kernelName:S0,backendName:"cpu",kernelFunc:qJ};function KJ(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;Ye([s,r,i],"select");const a=s.shape.length,o=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=ys(r.dtype,i.dtype),p=Ns(ce(r.shape),d);let m=0;const g=a===0||a>1||r.shape.length===1?1:ce(r.shape.slice(1));for(let x=0;x<o.length;x++)for(let b=0;b<g;b++)o[x]===1?p[m++]=u[x]:p[m++]=c[x];return t.makeTensorInfo(r.shape,d,p)}const YJ={kernelName:bm,backendName:"cpu",kernelFunc:KJ};const QJ=zm,ZJ=Lm,JJ=Qt(hd,n=>n>=0?ZJ*n:QJ*(Math.exp(n)-1)),eee={kernelName:hd,backendName:"cpu",kernelFunc:JJ};const tee=Qt(fd,n=>n<0?-1:n>0?1:0),nee={kernelName:fd,backendName:"cpu",kernelFunc:tee};const see=Qt(dd,n=>Math.sin(n)),ree={kernelName:dd,backendName:"cpu",kernelFunc:see};const iee=Qt(pd,n=>Math.sinh(n)),aee={kernelName:pd,backendName:"cpu",kernelFunc:iee};const oee=11920928955078125e-23,JT=Math.log(oee)+2,lee=Qt(gd,n=>{const e=n>-JT,t=n<JT,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),uee={kernelName:gd,backendName:"cpu",kernelFunc:lee};function cee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;Ye([r],"spaceToBatchND");const o=ce(i),u=[[0,0]];u.push(...a);for(let D=1+i.length;D<r.shape.length;++D)u.push([0,0]);const c=WF.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),d=Wu(c.shape,i,o,!1),p=Gu(d.length,i.length,!1),m=Hu(c.shape,i,o,!1),b=pn({inputs:{x:c},backend:t,attrs:{shape:d}}),N=dr({inputs:{x:b},backend:t,attrs:{perm:p}}),E=pn({inputs:{x:N},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(N),E}const hee={kernelName:Sm,backendName:"cpu",kernelFunc:cee};function dee(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values[0],[p,m,g,x,b]=fF(o,s.shape,s.dtype,u,r.dtype,c,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(v=>Number(v)))),t.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const pee={kernelName:lS,backendName:"cpu",kernelFunc:dee};function fee(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.data.get(r.dataId).values),o=t.data.get(s.dataId).values,u=Array.from(t.data.get(i.dataId).values),[c,d,p]=mF(o,s.shape,s.dtype,a,u);return[t.makeTensorInfo(d,s.dtype,c),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const mee={kernelName:uS,backendName:"cpu",kernelFunc:fee};function gee(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[c,d]=FC(a,s.shape,s.dtype,o,u,!0);return t.makeTensorInfo(d,s.dtype,c)}const yee={kernelName:C0,backendName:"cpu",kernelFunc:gee};function xee(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[c,d]=FC(a,s.shape,s.dtype,o,u);return t.makeTensorInfo(d,s.dtype,c)}const bee={kernelName:N0,backendName:"cpu",kernelFunc:xee};function vee(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:m}=Ta(i,r,o),g=!1,x=t.bufferSync(r);let b;switch(i.dtype){case"bool":{const v=t.bufferSync(i),w=!!t.data.get(a.dataId).values[0];b=mu(x,v,o,m,d,c,u,p,w,g);break}case"float32":{const v=t.bufferSync(i),w=t.data.get(a.dataId).values[0];b=mu(x,v,o,m,d,c,u,p,w,g);break}case"int32":{const v=t.bufferSync(i),w=t.data.get(a.dataId).values[0];b=mu(x,v,o,m,d,c,u,p,w,g);break}case"string":{const v=t.bufferSync(i),w=Hi(t.data.get(a.dataId).values[0]);b=mu(x,v,o,m,d,c,u,p,w,g);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(o,b.dtype,b.values)}const wee={kernelName:k0,backendName:"cpu",kernelFunc:vee};function See(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=gt(a,r.shape)[0],u=kb(r,i,o),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return u.map(p=>{const m=[...d];m[o]=p;const g=Fu({inputs:{x:r},backend:t,attrs:{begin:c,size:m}});return c[o]+=p,g})}const Cee={kernelName:Cm,backendName:"cpu",kernelFunc:See};const Nee={kernelName:$0,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Ye(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const u=r[o];i[o]=u*u}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const kee=Qt(Cd,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),$ee={kernelName:Cd,backendName:"cpu",kernelFunc:kee};function Iee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;Ye(r,"stridedSlice");const{finalShapeSparse:g,finalShape:x,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:N,end:I,strides:$}=lb(r.shape,i,a,o,u,c,d,p,m);let E;if(b)E=pn({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||w){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const D=ob(N,I,$),F=Fu({inputs:{x:r},backend:t,attrs:{begin:N,size:D}});E=pn({inputs:{x:F},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(F)}else{const D=t.bufferSync(r),F=xF(g,D,$,N);E=t.makeTensorInfo(x,F.dtype,F.values)}return E}const Tee={kernelName:T0,backendName:"cpu",kernelFunc:Iee};function Eee(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:c}=s,{data:d,dataSplits:p}=e,m=t.data.get(d.dataId).values,g=t.data.get(p.dataId).values,[x,b]=bF(m,g,r,i,a,o,u,c);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(p.shape,"int32",b)]}const Ree={kernelName:E0,backendName:"cpu",kernelFunc:Eee};function Aee(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(i.dataId).values,u=t.data.get(a.dataId).values[0],[c,d,p]=vF(o,u,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",c),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const Dee={kernelName:cS,backendName:"cpu",kernelFunc:Aee};function _ee(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(i.dataId).values,o=wF(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const Oee={kernelName:hS,backendName:"cpu",kernelFunc:_ee};const Fee=Qt(vd,n=>Math.tan(n)),zee={kernelName:vd,backendName:"cpu",kernelFunc:Fee};const Lee=Qt(wd,n=>Math.tanh(n)),Mee={kernelName:wd,backendName:"cpu",kernelFunc:Lee};function Pee(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:a,numUpdates:o,sliceSize:u,strides:c,outputSize:d}=Ta(i,r,s.shape),p=!1,m=t.bufferSync(r),g=t.bufferSync(i),x=t.bufferSync(s),b=mu(m,g,s.shape,d,u,o,a,c,x,p);return t.makeTensorInfo(s.shape,b.dtype,b.values)}const Bee={kernelName:w0,backendName:"cpu",kernelFunc:Pee};function Vee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;Ye(r,"tile");const a=CF(t.bufferSync(r),i);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const Uee={kernelName:Sd,backendName:"cpu",kernelFunc:Vee};function Wee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s;Ye(r,"topk");const o=t.data.get(r.dataId).values,[u,c]=kF(o,r.shape,r.dtype,i,a);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const Gee={kernelName:R0,backendName:"cpu",kernelFunc:Wee};function Hee(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:u,outputShape:c}=t,[d,p,m,g]=r.shape,[x,b]=c??[p,m],v=[d,x,b,g],w=Ze(r.shape),N=w[0],I=w[1],$=w[2],E=Ze(v),D=E[0],F=E[1],L=E[2],z=ss(r.dtype,ce(v));z.fill(u);const M=s.data.get(r.dataId).values,O=s.data.get(i.dataId).values;for(let X=0;X<d;++X){const te=i.shape[0]===1?O:O.subarray(X*8,X*8+8);for(let Z=0;Z<x;++Z)for(let W=0;W<b;++W)for(let ee=0;ee<g;++ee){let ie;const de=te[6]*W+te[7]*Z+1;if(de===0)continue;const ge=(te[0]*W+te[1]*Z+te[2])/de,G=(te[3]*W+te[4]*Z+te[5])/de,re=eE(ge,m,o),pe=eE(G,p,o);switch(a){case"nearest":ie=Qee(M,p,m,N,I,$,X,pe,re,ee,u);break;case"bilinear":ie=Zee(M,p,m,N,I,$,X,pe,re,ee,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const ve=X*D+Z*F+W*L+ee;z[ve]=ie}return s.makeTensorInfo(v,r.dtype,z)}return{dataId:s.write(z,v,r.dtype),shape:r.shape,dtype:r.dtype}}const jee={kernelName:A0,backendName:"cpu",kernelFunc:Hee};function eE(n,e,t){switch(t){case"reflect":return qee(n,e);case"wrap":return Xee(n,e);case"nearest":return Yee(n,e);case"constant":default:return Kee(n)}}function qee(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Su(0,t,e-1)}function Xee(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Su(0,t,e-1)}function Kee(n,e){return n}function Yee(n,e){return Su(0,n,e-1)}function Qp(n,e,t,s,r,i,a,o,u,c,d){const p=a*s+o*r+u*i+c;return 0<=o&&o<e&&0<=u&&u<t?n[p]:d}function Qee(n,e,t,s,r,i,a,o,u,c,d){const p=Math.round(o),m=Math.round(u);return Qp(n,e,t,s,r,i,a,p,m,c,d)}function Zee(n,e,t,s,r,i,a,o,u,c,d){const p=Math.floor(o),m=Math.floor(u),g=p+1,x=m+1,b=(x-u)*Qp(n,e,t,s,r,i,a,p,m,c,d)+(u-m)*Qp(n,e,t,s,r,i,a,p,x,c,d),v=(x-u)*Qp(n,e,t,s,r,i,a,g,m,c,d)+(u-m)*Qp(n,e,t,s,r,i,a,g,x,c,d);return(g-o)*b+(o-p)*v}function Jee(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Ye(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:u,indices:c}=$F(a,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const ete={kernelName:dS,backendName:"cpu",kernelFunc:Jee};function tte(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==i&&(u[c++]=r.shape[g]);const d=new Array(a).fill(0),p=r.shape.slice();p[i]=1;const m=new Array(o);for(let g=0;g<m.length;g++){d[i]=g;const x=Fu({inputs:{x:r},backend:t,attrs:{begin:d,size:p}});m[g]=pn({inputs:{x},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(x)}return m}const nte={kernelName:km,backendName:"cpu",kernelFunc:tte};function ste(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s;Ye(r,"unsortedSegmentSum");const o=r.shape.length,u=i.shape.length,c=[],d=[],p=o-u;let m=i;for(let x=0;x<p;++x){const b=wx({inputs:{input:m},backend:t,attrs:{dim:x+1}});m=b,d.push(b)}for(let x=0;x<a;++x){const b=wl(x,"int32"),v=t.makeTensorInfo([],"int32",b),w=VO({inputs:{a:v,b:m},backend:t}),N=xl({inputs:{x:w},backend:t,attrs:{dtype:"float32"}}),I=Mb({inputs:{a:N,b:r},backend:t}),$=jm({inputs:{x:I},backend:t,attrs:{axis:0,keepDims:!1}});c.push($),d.push(v),d.push(w),d.push(N),d.push(I),d.push($)}const g=UF({inputs:c,backend:t,attrs:{axis:0}});return d.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const rte={kernelName:$m,backendName:"cpu",kernelFunc:ste};const ite=[J9,O7,tY,sY,B7,iY,oY,uY,hY,pY,mY,yY,bY,SY,NY,IY,EY,AY,_Y,Q9,FY,LY,PY,U7,VY,M7,G7,WY,F7,HY,qY,XY,YY,ZY,eQ,nQ,rQ,aQ,lQ,cQ,dQ,fQ,gQ,xQ,bQ,wQ,CQ,kQ,$Q,IQ,TQ,RQ,_Q,G9,FQ,H7,WQ,j7,GQ,X7,YQ,QQ,JQ,Y7,Z7,tZ,sZ,iZ,oZ,e9,n9,z7,uZ,jY,hZ,pZ,mZ,H9,r9,a9,yZ,l9,bZ,SZ,NZ,IZ,EZ,AZ,DZ,c9,OZ,zZ,MZ,BZ,UZ,GZ,jZ,d9,XZ,QZ,eJ,f9,g9,sJ,aJ,uJ,x9,hJ,pJ,fJ,WF,xJ,q9,w9,vJ,SJ,NJ,$J,L7,O2,TJ,X9,K9,Y9,RJ,DJ,OJ,zJ,MJ,PJ,VJ,E9,WJ,XJ,YJ,eee,A9,nee,ree,aee,D9,ZZ,uee,hee,pee,mee,yee,bee,wee,Cee,F9,Nee,L9,P9,$ee,Tee,Ree,Dee,Oee,W9,AQ,zee,Mee,Bee,Uee,Gee,jee,b9,ete,nte,rte,dJ];for(const n of ite)pS(n);const du={},$y={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ate(n,e){du[n]=e}function Zi(n,e){if(!(n in du)||e!=null){const s=lte(n,e);if(s!==null)du[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=du[n];return t==null||t.isContextLost()?(delete du[n],Zi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),du[n])}function ote(n){if(!fe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function lte(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??ote(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete du[n]},!1),fe().getBool("SOFTWARE_WEBGL_ENABLED")&&($y.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",$y)||t.getContext("experimental-webgl",$y):t.getContext("webgl2",$y)}var vf;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(vf||(vf={}));var jr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(jr||(jr={}));var Cs;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Cs||(Cs={}));function qm(n,e){return[e,n]}function ute(n,e){return n*e}function Iy(n){const e=ce(n),t=Math.ceil(e/4);return jw(t)}function Rd(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function cte(n,e){const[t,s]=Rd(n,e);return t*s*4}function BC(n,e){const t=n;let s,r,i,a,o,u,c,d,p,m;return fe().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,a=t.RGBA32F,o=t.RED,c=4,d=1,p=t.HALF_FLOAT,m=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,a=t.RGBA,o=n.RGBA,c=4,d=4,p=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function He(n,e){const t=e();return fe().getBool("DEBUG")&&hte(n),t}function hte(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+mte(n,e))}const dte=596e-10,pte=65504;function fte(n){return!!(fe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||dte<Math.abs(n)&&Math.abs(n)<pte)}function mte(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Ty(n,e){return mo(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function gte(n,e){const t=mo(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(He(n,()=>n.shaderSource(t,e)),He(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function yte(n,e){const t=mo(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(He(n,()=>n.shaderSource(t,e)),He(n,()=>n.compileShader(t)),fe().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw GF(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const xte=/ERROR: [0-9]+:([0-9]+):/g;function GF(n,e){const t=xte.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,a=r.map((p,m)=>rh((m+1).toString(),i)+p);let o=0;for(let p=0;p<a.length;p++)o=Math.max(a[p].length,o);const u=a.slice(0,s-1),c=a.slice(s-1,s),d=a.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${rh(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function bte(n){return mo(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function vte(n,e){if(He(n,()=>n.linkProgram(e)),!fe().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Nw(n,e){if(He(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function wte(n,e){const t=mo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return He(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),He(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Ste(n,e){const t=mo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return He(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),He(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Cte(n){return mo(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Nte(n,e){const t=fe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function kte(n){return mo(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function tE(n,e,t,s,r,i,a){const o=n.getAttribLocation(e,t);return o===-1?!1:(He(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),He(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,i,a)),He(n,()=>n.enableVertexAttribArray(o)),!0)}function $te(n,e,t){Ate(n,t),He(n,()=>n.activeTexture(n.TEXTURE0+t)),He(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Ite(n,e,t){return mo(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Tte(n,e,t){return n.getUniformLocation(e,t)}function Ete(n,e,t,s){He(n,()=>$te(n,e,s)),He(n,()=>n.uniform1i(t,s))}function kw(n,e,t){He(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),He(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function nE(n,e){He(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),He(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ey(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Rte(n,e))}function Rte(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function mo(n,e,t){const s=He(n,()=>e());if(s==null)throw new Error(t);return s}function Ate(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function vh(n,e=2){return ce(n.slice(0,n.length-e))}function wh(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Ry(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[vh(n),...wh(n)]),e}function Dte(n,e=!1){let t=fe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=fe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&fe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,u)=>u>=n.length-2?Z2(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=vl(n).newShape);let r=ce(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const a=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||a)if(e){const o=vh(n);let u=2,c=2;n.length&&([u,c]=wh(n)),r=o*(u/2)*(c/2),i=jw(r).map(d=>d*2)}else i=jw(r);return i}function Ay(n){return n%2===0}function Cx(n,e){if(n=n.slice(-2),e=e.slice(-2),xt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Ay(t)&&Ay(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Ay(n[0])&&Ay(e[0])}let $w,Iw;function _te(n){if($w==null){const e=Zi(n);$w=e.getParameter(e.MAX_TEXTURE_SIZE)}return $w}function Ote(n){if(Iw==null){const e=Zi(n);Iw=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Iw)}function Fte(n){if(n===0)return 0;let e;const t=Zi(n);return wi(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:wi(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function wi(n,e){return n.getExtension(e)!=null}function sE(n){try{if(Zi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function zte(n){if(n===0)return!1;const e=Zi(n);if(n===1){if(!wi(e,"OES_texture_float"))return!1}else if(!wi(e,"EXT_color_buffer_float"))return!1;return z2(e)}function Lte(n){if(n===0)return!1;const e=Zi(n);if(n===1){if(!wi(e,"OES_texture_float")||!wi(e,"WEBGL_color_buffer_float"))return!1}else{if(wi(e,"EXT_color_buffer_float"))return z2(e);const s="EXT_color_buffer_half_float";if(wi(e,s)){const r=e.getExtension(s);return Mte(e,r)}return!1}return z2(e)}function z2(n){const e=BC(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),a}function Mte(n,e){const t=BC(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function Pte(n){return n!==2?!1:Zi(n).fenceSync!=null}function Xm(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const Qe=fe();Qe.registerFlag("HAS_WEBGL",()=>Qe.getNumber("WEBGL_VERSION")>0);Qe.registerFlag("WEBGL_VERSION",()=>sE(2)?2:sE(1)?1:0);Qe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qe.get("WEBGL_VERSION")===2);Qe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qe.registerFlag("WEBGL_PACK",()=>Qe.getBool("HAS_WEBGL"));Qe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_CLIP",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_REDUCE",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_CONV_IM2COL",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Qe.getBool("WEBGL_PACK"));Qe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>_te(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Ote(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Qe.getNumber("WEBGL_VERSION");return n===0?0:Fte(n)});Qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ZR());Qe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>zte(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Lte(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Pte(Qe.getNumber("WEBGL_VERSION")));Qe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Qe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ZR()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Qe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qe.registerFlag("WEBGL_EXP_CONV",()=>!1);Qe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qe.getBool("IS_TEST"));Qe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Zs(){let n,e,t,s,r,i,a,o,u,c;return fe().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o=fe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:u,defineRound:c}}function Xu(n,e,t="index"){const s=Ze(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / ${r}`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${a}; ${o};`}).join("")}function Pb(n,e,t="index"){const s=Ze(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${a}; ${o};`}).join("")}function Bte(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function Vte(n,e,t="index"){const s=n.map((i,a)=>a),r=Bte(s,e);return r.map((i,a)=>{const o=`int ${n[a]} = ${t} / ${r[a]}`,u=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${o}; ${u};`}).join("")}function VC(n){const e=Ze(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function UC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const HF=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:jF}=i5;function Ute(n,e,t){const s=[];if(n.forEach(g=>{const x=ce(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?s.push(`uniform float ${g.name}${x>1?`[${x}]`:""};`):(s.push(`uniform sampler2D ${g.name};`),s.push(`uniform int offset${g.name};`)),t.enableShapeUniforms){const{uniformShape:b}=WC(t.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(b.length){case 1:s.push(`uniform int ${g.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${g.name}Shape;`);break}s.push(`uniform ivec2 ${g.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(g=>{s.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(g=>Wte(g,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=Zs(),u=jte(o);let c,d,p=Kte(o);return e.isPacked?(c=Gte(e.logicalShape,a,t.enableShapeUniforms),d=Xte(o)):(c=Hte(e.logicalShape,a,t.enableShapeUniforms),d=qte(o)),t.packedInputs&&(p+=Jte),[p,u,d,r,c,i,t.userCode].join(`
`)}function Ad(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return hne(n,e);case 1:return pne(n,e);case 2:return mne(n,e);case 3:return yne(n,e);case 4:return bne(n,e);case 5:return vne(n);case 6:return wne(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function qF(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return cne(n);case 1:return dne(n,e);case 2:return fne(n,e);case 3:return gne(n,e);default:return xne(n,e)}}function Wte(n,e,t=!1,s){let r="";t?r+=qF(n,s):r+=Ad(n,s);const i=n.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(t?r+=Sne(n,e):r+=Cne(n,e)),r}function Gte(n,e,t){switch(n.length){case 0:return XF();case 1:return ene(n,e,t);case 2:return lne(n,e,t);case 3:return nne(n,e,t);default:return rne(n,e,t)}}function Hte(n,e,t){switch(n.length){case 0:return XF();case 1:return tne(n,e,t);case 2:return une(n,e,t);case 3:return sne(n,e,t);case 4:return ine(n,e,t);case 5:return ane(n,e);case 6:return one(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function jte(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function qte(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Xte(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Kte(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Yte}
    ${Qte}
    ${Zte}
  `}const Yte=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Qte=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Zte=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Jte=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function XF(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ene(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function tne(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function nne(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function sne(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Pb(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Xu(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function rne(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let a=i,o="",u="b, r, c";for(let c=2;c<n.length-1;c++)a*=n[n.length-c-1],o=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+o,u=`b${c}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function ine(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Pb(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Xu(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function ane(n,e){const t=Xu(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function one(n,e){const t=Xu(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function lne(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(xt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function une(n,e,t){return xt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Ku(n){return`offset${n}`}function cne(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Zs();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function hne(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Ku(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function dne(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Zs();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function pne(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Dd(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],a=r[1];if(a===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Ku(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function fne(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=i[0],o=i[1],u=Zs();if(i!=null&&xt(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function mne(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&xt(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],g=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=vl(t),u=a;if(u.length<t.length){const m=_d(n,u),g=["row","col"];return`
      ${Ad(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${Od(g,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Dd(n)}
      }
    `;const c=i[0],d=i[1],p=Ku(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${c}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function gne(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const m=t.slice(1),g=[1,2],x=_d(n,m),b=["b","row","col"];return`
        ${qF(x,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Od(b,g)});
        }
      `}const o=Zs();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const u=a[0],c=a[1],d=Math.ceil(t[2]/2),p=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${p}, ${d}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function yne(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],a=t[2],{newShape:o,keptDims:u}=vl(t),c=o;if(c.length<t.length){const b=_d(n,c),v=["row","col","depth"];return`
        ${Ad(b,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Od(v,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${Dd(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],g=n.shapeInfo.flatOffset;if(m===i&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===a&&g==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const x=Ku(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${x};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${x};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function xne(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Zs();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,a=i.length,o=n.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=u[0],d=u[1],p=Math.ceil(i[a-1]/2);let m=p*Math.ceil(i[a-2]/2),g="int b, int row, int col",x=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let b=2;b<a-1;b++)g=`int b${b}, `+g,m*=i[a-b-1],x=`b${b} * ${m} + `+x;return`
    vec4 ${s}(${g}) {
      int index = ${x};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function bne(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],a=t[2]*i,o=t[1]*a,{newShape:u,keptDims:c}=vl(t);if(u.length<t.length){const N=_d(n,u),I=["row","col","depth","depth2"];return`
      ${Ad(N,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Od(I,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${i}, 1)));
        ${Dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],g=p[1],x=`int stride2 = ${s}Shape[3];`,b=`int stride1 = ${s}Shape[2] * stride2;`,v=`int stride0 = ${s}Shape[1] * stride1;`;if(g===o&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${x}
        ${b}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(g===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const w=Ku(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${x}
      ${b}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${w});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${g}, index + ${w});
      return sampleTexture(${s}, uv);
    }
  `}function vne(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,a=e[2]*i,o=e[1]*a,{newShape:u,keptDims:c}=vl(e);if(u.length<e.length){const b=_d(n,u),v=["row","col","depth","depth2","depth3"];return`
      ${Ad(b)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Od(v,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${i}, ${r})) +
          depth3;
        ${Dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],g=p[1];if(g===o&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=Ku(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${i} +
          depth2 * ${r} + depth3 + ${x};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function wne(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=vl(e);if(r.length<e.length){const v=_d(n,r),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ad(v)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Od(w,i)});
      }
    `}const a=e[5],o=e[4]*a,u=e[3]*o,c=e[2]*u,d=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${c}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Dd(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,g=m[0],x=m[1];if(x===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(x===a&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=Ku(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} + depth * ${u} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${b};
      vec2 uv = uvFromFlat(${g}, ${x}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Dd(n){const e=n.name,t=ce(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Sne(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=jF(n.shapeInfo.logicalShape,e.logicalShape),u=nn(a),c=a-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":a<2&&o.length>=1?d="coords = 0;":d=o.map(N=>`coords.${p[N+c]} = 0;`).join(`
`);let m="";a<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((N,I)=>`coords.${p[I+c]}`).join(", ");let g="return outputValue;";const b=ce(n.shapeInfo.logicalShape)===1,w=ce(e.logicalShape)===1;if(i===1&&!b&&!w)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(b&&!w)a===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){const N=i-2,I=i-1;o.indexOf(N)>-1&&o.indexOf(I)>-1?g="return vec4(outputValue.x);":o.indexOf(N)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${g}
    }
  `}function Cne(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===u&&n.shapeInfo.flatOffset==null&&xt(a,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=nn(u),d=jF(n.shapeInfo.logicalShape,e.logicalShape),p=u-o;let m;const g=["x","y","z","w","u","v"];o===0?m="":u<2&&d.length>=1?m="coords = 0;":m=d.map(b=>`coords.${g[b+p]} = 0;`).join(`
`);let x="";return u<2&&o>0?x="coords":x=n.shapeInfo.logicalShape.map((b,v)=>`coords.${g[v+p]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${m}
      return get${s}(${x});
    }
  `}function nn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function WC(n,e,t){const{newShape:s,keptDims:r}=vl(e),i=e.length,a=n&&i===3&&e[0]===1,o=a?e.slice(1):s,u=!n&&i>1&&!xt(e,t)&&s.length<i||a;return{useSqueezeShape:u,uniformShape:u?o:e,keptDims:r}}function _d(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Od(n,e){return e.map(t=>n[t]).join(", ")}function Nne(n,e,t,s){const r=t.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=Ute(r,a,e),u=yte(n.gl,o),c=n.createProgram(u);return fe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:i,outShapeInfo:a},KF(n,e,c)))}function KF(n,e,t){const s=[],r=[];let i,a,o,u=null,c=null;c=n.getUniformLocation(t,"NAN",!1),fe().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const p of e.variableNames){const m={name:p,uniform:n.getUniformLocation(t,p,d),offset:n.getUniformLocation(t,`offset${p}`,d)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${p}Shape`,d),m.texShape=n.getUniformLocation(t,`${p}TexShape`,d)),s.push(m)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),o=n.getUniformLocation(t,"outShapeStrides",d),a=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const p of e.customUniforms)r.push(n.getUniformLocation(t,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:a}}function rE(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],a=i.shape;if(!xt(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const o=t.texShape,u=i.isUniform?null:i.texData.texShape;if(!xt(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function kne(n,e,t,s,r){e.program.enableShapeUniforms||(rE(e.inShapeInfos,t),rE([e.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):n.setOutputMatrixTexture(i.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),fe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const c=t[u],{uniform:d,offset:p,shape:m,texShape:g}=e.variablesLocations[u];if(m){const{uniformShape:x}=WC(e.program.packedInputs,c.shape,c.texData.texShape);switch(x.length){case 1:n.gl.uniform1iv(m,new Int32Array(x));break;case 2:n.gl.uniform2iv(m,new Int32Array(x));break;case 3:n.gl.uniform3iv(m,new Int32Array(x));break;case 4:n.gl.uniform4iv(m,new Int32Array(x));break}}if(g&&n.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(ce(c.shape)<2)n.gl.uniform1f(d,c.uniformValues[0]);else{let x=c.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(d,x)}continue}c.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,d,u)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=Ze(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const c=e.program.customUniforms[u],d=e.customUniformLocations[u],p=r[u];if(c.type==="float")n.gl.uniform1fv(d,p);else if(c.type==="vec2")n.gl.uniform2fv(d,p);else if(c.type==="vec3")n.gl.uniform3fv(d,p);else if(c.type==="vec4")n.gl.uniform4fv(d,p);else if(c.type==="int")n.gl.uniform1iv(d,p);else if(c.type==="ivec2")n.gl.uniform2iv(d,p);else if(c.type==="ivec3")n.gl.uniform3iv(d,p);else if(c.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function $ne(n,e,t){let s="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const u=a.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:p}=WC(n.packedInputs,a.shape,u);let m="",g="",x="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)g=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Ze(d);x=`${E[0]===u[1]}_${E[E.length-1]===u[1]}`}const b=a.shape.length,v=d.length===2&&xt(a.shape,u),w=ce(a.shape)===1,N=dl(a.shape,t.shape),I=!n.packedInputs&&b===t.shape.length&&xt(u,t.texData.texShape),$=n.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${b}_${I}_${c?p:""}_${d.length}_${w}_${N}_${v}_${m}_${g}_${x}_${$}_${o}`}else{const u=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${u}_${o}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${fe().getNumber("WEBGL_VERSION")}`,i}function Ms(n){return fe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Ine{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=vf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Zs();this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Pb(["r","c","d"],e):Xu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class Tne{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=vf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Zs();this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Pb(["r","c","d"],e):Xu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class Ene{constructor(e){this.variableNames=["A"],this.outTexUsage=jr.DOWNLOAD;const t=Zs();this.outputShape=e,this.userCode=`
      ${HF}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class Rne{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=jr.DOWNLOAD;const t=Zs();this.outputShape=e,this.userCode=`
      ${HF}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const Ane={R:0,G:1,B:2,A:3};class iE{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Zs();this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const u=s[o];a+=`
          if(offset == ${o}) {
            result = values[${Ane[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?UC():VC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class Dne{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Zs();this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const u=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?UC():VC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function _ne(n){const e=Zs(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return gte(n,t)}function One(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return wte(n,e)}function Fne(n){const e=new Uint16Array([0,1,2,2,1,3]);return Ste(n,e)}function Km(n,e,t,s,r,i){Nte(e,t);const a=Cte(n),o=n.TEXTURE_2D;return He(n,()=>n.bindTexture(o,a)),He(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),He(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),He(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),He(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),fe().getNumber("WEBGL_VERSION")===1?He(n,()=>n.texImage2D(o,0,s,e,t,0,r,i,null)):He(n,()=>n.texStorage2D(o,1,s,e,t)),He(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function YF(n){return n.internalFormatFloat}function zne(n,e,t,s){const[r,i]=qm(e,t);return Km(n,r,i,YF(s),s.textureFormatFloat,n.FLOAT)}function QF(n){return n.internalFormatHalfFloat}function Lne(n,e,t,s){const[r,i]=qm(e,t);return Km(n,r,i,QF(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function ZF(n){return n.downloadTextureFormat}function Mne(n,e,t,s){const[r,i]=qm(e,t);return Km(n,r,i,ZF(s),n.RGBA,n.UNSIGNED_BYTE)}function JF(n){return n.internalFormatPackedFloat}function Pne(n,e,t,s){const[r,i]=Rd(e,t);return Km(n,r,i,JF(s),n.RGBA,n.FLOAT)}function ez(n){return n.internalFormatPackedHalfFloat}function Bne(n,e,t,s){const[r,i]=Rd(e,t);return Km(n,r,i,ez(s),n.RGBA,s.textureTypeHalfFloat)}function Vne(n,e,t){return He(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),tE(n,e,"clipSpacePos",t,3,20,0)&&tE(n,e,"uv",t,2,20,12)}function Une(n,e,t,s,r,i){He(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,o,u;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,u=n.RGBA):(a=new Float32Array(t*s*4),o=n.FLOAT,u=i.internalFormatPackedFloat),a.set(r),fe().getNumber("WEBGL_VERSION")===2?He(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,a)):He(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,o,a)),He(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Wne(n,e,t){He(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?fe().getNumber("WEBGL_VERSION")===2?He(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):He(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):fe().getNumber("WEBGL_VERSION")===2?He(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):He(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),He(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Gne(n,e,t,s){const r=n.createBuffer();He(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=4*4*e*t;return He(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),He(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),He(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function Hne(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function jne(n,e,t,s){const[r,i]=qm(e,t),a=4,o=new Uint8Array(ute(e*t,a));return He(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function qne(n,e,t,s,r,i,a,o){const u=n,c=new Float32Array(cte(i,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function Xne(n,e,t){const s=new Float32Array(e*t*4);return He(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}class Tw{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=fe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,ate(t,e)):this.gl=Zi(t),e=this.gl,fe().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>He(i,()=>i.createVertexArray()),this.bindVertexArray=a=>He(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>He(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>He(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>He(e,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>He(e,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>He(e,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>He(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),fe().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Ty(this.gl,i),wi(this.gl,a))this.textureHalfFloatExtension=Ty(this.gl,a);else if(fe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),wi(this.gl,r))this.colorBufferHalfFloatExtension=Ty(this.gl,r);else if(fe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",wi(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(wi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=One(this.gl),this.indexBuffer=Fne(this.gl),this.framebuffer=kte(this.gl),this.textureConfig=BC(this.gl,this.textureHalfFloatExtension)}get debug(){return fe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;He(e,()=>e.finish()),He(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),He(e,()=>e.deleteFramebuffer(this.framebuffer)),He(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),He(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),He(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),zne(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Lne(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Mne(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Wne(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),Une(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Bne(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Pne(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(nE(this.gl,this.framebuffer),this.outputTexture=null),He(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>jne(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,a){return qne(this.gl,e,t,s,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Hne(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=Gne(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(fe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(i,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=i}else fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Xne(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=_ne(t));const s=bte(t);He(t,()=>t.attachShader(s,this.vertexShader)),He(t,()=>t.attachShader(s,e)),vte(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Nw(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;He(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Vne(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(He(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Nw(this.gl,this.program),He(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Ite(this.gl,e,t):Tte(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),He(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Ete(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Rd(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Nw(this.gl,this.program),Ey(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}He(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),He(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ty(this.gl,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await FI(()=>this.disposed||this.isQueryAvailable(e,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=Kne(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in fe().platform&&(s=fe().platform.setTimeoutCustom.bind(fe().platform)),FI(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),kw(this.gl,e,this.framebuffer),this.debug&&Ey(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(kw(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ey(this.gl)):nE(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;kw(r,e,this.framebuffer),this.debug&&Ey(r),this.outputTexture=e,He(r,()=>r.viewport(0,0,t,s)),He(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),He(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Kne(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:Yne,bincountImpl:tz,bincountReduceImpl:Qne,bitwiseAndImpl:Zne,castImpl:Jne,ceilImpl:ese,concatImpl:tse,equalImpl:nse,expImpl:sse,expm1Impl:rse,floorImpl:ise,gatherNdImpl:ase,gatherV2Impl:ose,greaterImpl:lse,greaterEqualImpl:use,lessImpl:cse,lessEqualImpl:hse,linSpaceImpl:dse,logImpl:pse,maxImpl:fse,maximumImpl:mse,minimumImpl:gse,multiplyImpl:yse,negImpl:xse,notEqualImpl:bse,prodImpl:vse,raggedGatherImpl:wse,raggedRangeImpl:Sse,raggedTensorToTensorImpl:Cse,rangeImpl:Nse,rsqrtImpl:kse,scatterImpl:$se,sigmoidImpl:Ise,simpleAbsImpl:nz,sliceImpl:Tse,sparseFillEmptyRowsImpl:Ese,sparseReshapeImpl:Rse,sparseSegmentReductionImpl:sz,sqrtImpl:Ase,staticRegexReplaceImpl:Dse,stridedSliceImpl:_se,stringNGramsImpl:Ose,stringSplitImpl:Fse,stringToHashBucketFastImpl:zse,subImpl:Lse,tileImpl:Mse,topKImpl:Pse,transposeImpl:GC,uniqueImpl:Bse}=IF;function rz(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function qs(n,e){return e===1?[n]:rz(n,e)}function Vse(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class Use{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ms(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=qs("rc",this.rank),s=nn(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${e[e.length-1-a]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class iz{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Wse(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?UC():VC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Wse(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Vte(["r","c","d"],"inputShape"):Xu(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}let Gse=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=oE(t,s),i=lE(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=aE(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let o;return r===Cs.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Cs.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Cs.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Cs.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Cs.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=oE(s,r),a=lE(t,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const o=aE(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=fe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[a],d=c&&c.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Hse(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function aE(n,e,t,s,r){const i=jse(e,s);let a;if(r){const[u,c]=Rd(n[0],n[1]);a=u*c}else{const[u,c]=qm(n[0],n[1]);a=u*c}const o=Hse(t,i);return a*o}function jse(n,e){switch(n){case Cs.PACKED_2X2_FLOAT32:return JF(e);case Cs.PACKED_2X2_FLOAT16:return ez(e);case Cs.UNPACKED_FLOAT32:return YF(e);case Cs.UNPACKED_FLOAT16:return QF(e);case Cs.PACKED_4X1_UNSIGNED_BYTE:return ZF(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function qse(n){return fe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Cs.PACKED_2X2_FLOAT32:Cs.UNPACKED_FLOAT32:n?Cs.PACKED_2X2_FLOAT16:Cs.UNPACKED_FLOAT16}function oE(n,e){if(n===jr.UPLOAD)return Cs.PACKED_2X2_FLOAT32;if(n===jr.RENDER||n==null)return qse(e);if(n===jr.DOWNLOAD||n===jr.PIXELS)return Cs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function lE(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}let ga=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Ei="if (isnan(x)) return x;",Xse="return x;",uE="return abs(x);",Kse="return (x >= 0.0) ? x : (exp(x) - 1.0);",Yse=Ei+`
  return (x < 0.0) ? 0.0 : x;
`,Qse=Ei+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Zo="return x;",Zse="return 1.0 / (1.0 + exp(-1.0 * x));";const Jse="return x;",ere=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,tre=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nre=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sre="return 1.0 / (1.0 + exp(-1.0 * x));";class nl{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class rre{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length);const t=e.length,s=qs("rc",t),r=nn(t),i=Vse(t,s),a=s.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}const ire=XS,are=1e-7,ore=1e-4,Dy={};function lre(n){return n in Dy||(Dy[n]={}),Dy[n]}const ure=fe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),cre=600;function hre(){return fe().global.screen==null?1024:fe().global.screen.height*fe().global.screen.width*window.devicePixelRatio*cre/1024/1024}class Bb extends Fx{nextDataId(){return Bb.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!fe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Tw)t=e;else{const s=Zi(fe().getNumber("WEBGL_VERSION"),e);t=new Tw(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Zi(fe().getNumber("WEBGL_VERSION"));t=new Tw(s),this.binaryCache=lre(fe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Gse(this.gpgpu),this.numMBBeforeWarning=hre(),this.texData=new Q2(this,Gs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,a){const o=this.makeTensorInfo(t,s),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,i]},u.texShape=[r,i];const c=Ry(t),d=new iE(c,!1,a),p=this.runWebGLProgram(d,[o],s,[[r,i]]);return p.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(o),p.dataId}write(e,t,s){if((fe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||fe().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:jr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(fe().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:jr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:u}=t;if(a!=null){let m;u?m=new nl(o,Zo):m=new ga(o,Zo);const g=this.runWebGLProgram(m,[{dataId:e,shape:o,dtype:r}],r),x=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const c=this.activeTimers!=null;let d;c&&(d=ir());let p;if(r==="complex64"){const m=this.readSync(i.real.dataId),g=this.readSync(i.imag.dataId);p=Xi(m,g)}else p=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=ir()-d),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const x=this.pendingRead.get(e);return new Promise(b=>x.push(b))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:u}=t;if(i!=null){let x;u?x=new nl(r,Zo):x=new ga(r,Zo);const b=this.runWebGLProgram(x,[{dataId:e,shape:r,dtype:a}],a),v=this.read(b.dataId);return this.disposeIntermediateTensorInfo(b),v}if(s!=null)return this.convertAndCacheOnCPU(e);if(fe().getBool("DEBUG")&&!fe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&fe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,d;if(a!=="complex64"&&fe().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const x=this.texData.get(d.dataId);c=this.gpgpu.createBufferFromTexture(x.texture.texture,...Iy(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(a==="complex64"){const x=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),b=x[0],v=x[1];p=Xi(b,v)}else if(c==null)p=this.getValuesFromTexture(e);else{const x=ce(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(c,x)}if(d!=null&&this.disposeIntermediateTensorInfo(d),c!=null){const x=this.gpgpu.gl;He(x,()=>x.deleteBuffer(c))}const m=this.convertAndCacheOnCPU(e,p),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(x=>x(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Gs().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:a,dtype:o,isPacked:u,texture:c}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let g;u?g=new nl(i,Zo):g=new ga(i,Zo);const x=this.runWebGLProgram(g,[{dataId:e,shape:i,dtype:o}],o),b=this.readToGPU(x,t);return this.disposeIntermediateTensorInfo(x),b}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),p=Gs().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Hi(r));return ft(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!fte(s))throw fe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=ce(t);if(fe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),g=this.texData.get(m.dataId),x=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...Iy(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),x}const a=fe().getBool("WEBGL_PACK")&&r===!0,o=a?Ry(t):t,u=a?new Rne(o):new Ene(o),c=this.runWebGLProgram(u,[{shape:o,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),p}timerAvailable(){return fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=lo(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=lo(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(i);o.kernelMs=FR(u),o.getExtraProfileInfo=()=>u.map((c,d)=>({name:a[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ir(),endMs:null}}endTimer(e){return fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ir(),e)}async getQueryTime(e){if(fe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:a,slice:o}=this.texData.get(e),u=o&&o.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=ure){return fe().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&ce(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Hr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return ire(e.shape,t)}packedUnaryOp(e,t,s){const r=new nl(e.shape,t),i=this.compileAndRun(r,[e],s);return Gs().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=nz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(fe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,uE,e.dtype);const t=new ga(e.shape,uE),s=this.compileAndRun(t,[e]);return Gs().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ih(s[0])){const i=s.map(a=>ro(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Gs().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new rre(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Use(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[vh(e.shape),...wh(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[vh(t),...wh(t)],a=new iz(i,s),o=!0,u=[s],c=this.runWebGLProgram(a,[r],e.dtype,u,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:a}=s;if(t!=null){const m=ce(i),g=t[0]*t[1]*4;B(m<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Ry(i);let u;r?u=new Tne(o):u=new Ine(o);const c=!0,d=[t??Iy(o)],p=this.runWebGLProgram(u,[{shape:o,dtype:a,dataId:e}],a,d,c,t);return{dtype:a,shape:i,dataId:p.dataId}}runWebGLProgram(e,t,s,r,i=!1,a){const o=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(o.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===vf.DENSE){const w=a??Iy(e.outputShape);u.texShape=w.map(N=>N*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),ce(o.shape)===0)return u.values=ss(o.dtype,0),o;const c=[],d=t.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let N=this.texData.get(w.dataId);if(N.texture==null){if(!e.packedInputs&&ce(w.shape)<=fe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:N.values};e.packedInputs&&(N.isPacked=!0,N.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!N.isPacked!=!!e.packedInputs)w=N.isPacked?this.unpackTensor(w):this.packTensor(w),c.push(w),N=this.texData.get(w.dataId);else if(N.isPacked&&!Cx(N.shape,w.shape)){const I=w,$=w.shape;w.shape=N.shape,w=this.packedReshape(w,$),c.push(w),N=this.texData.get(w.dataId),I.shape=$}return{shape:w.shape,texData:N,isUniform:!1}});this.uploadToGPU(o.dataId);const p={shape:o.shape,texData:u,isUniform:!1},m=$ne(e,d,p),g=this.getAndSaveBinary(m,()=>Nne(this.gpgpu,e,d,p)),x=this.activeTimers!=null;let b;x&&(b=this.startTimer()),fe().get("ENGINE_COMPILE_ONLY")||kne(this.gpgpu,g,d,p,r),c.forEach(w=>this.disposeIntermediateTensorInfo(w)),x&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const v=fe().getNumber("WEBGL_FLUSH_THRESHOLD");if(v>0){const w=ir();w-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!fe().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){const w=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),w}return o}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(fe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=he(()=>{if(!fe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=fe().getBool("DEBUG");fe().set("DEBUG",!1);const t=this.abs(Je(1e-8)).dataSync()[0];if(fe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?are:ore}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:a,usage:o,isPacked:u}=t;if(a!=null)return;const c=this.activeTimers!=null;let d;c&&(d=ir());let p=t.texShape;if(p==null&&(p=Dte(s,u),t.texShape=p),i!=null){const m=Ry(s);let g,x=p[1],b=p[0];const v=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!v)&&([x,b]=Rd(p[0],p[1])),u?g=new Dne(m,v):g=new iE(m,v);const w=v?[b,x]:p,N=this.makeTensorInfo(w,r),I=this.texData.get(N.dataId);v?I.usage=jr.PIXELS:I.usage=jr.UPLOAD,I.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(N.dataId),x,b,i);const $=[[b,x]],D=this.runWebGLProgram(g,[N],r,$,!0),F=this.texData.get(D.dataId);t.texShape=F.texShape,t.isPacked=F.isPacked,t.usage=F.usage,fe().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(t.texture=F.texture,t.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo(N),c&&(this.uploadWaitMs+=ir()-d)}else{const m=this.acquireTexture(p,o,r,u);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=dre(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Qy(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await WA(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(GF(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:u}=KF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:a,channels:o}=e,u=Gs().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(r,t,s,i,a,o);return Gs().makeTensorFromDataId(c,t,s,u)}}Bb.nextDataId=0;function dre(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}JR()&&fS("webgl",()=>new Bb,2);const HC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let zu=class{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=it(t,s),this.enableShapeUniforms=Ms(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};const Yu=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Fd{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=it(t,s);const i=this.outputShape.length;this.enableShapeUniforms=Ms(i);let a="";if(r)if(i===0||ce(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${nn(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=qs("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}function Rr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const pre={kernelName:Kh,backendName:"webgl",kernelFunc:Rr};function El(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(i.dataId),o=Rr({inputs:{x:s},backend:t}),u=Rr({inputs:{x:r},backend:t});return a.complexTensorInfos={real:o,imag:u},i}const fre={kernelName:Wx,backendName:"webgl",kernelFunc:El};const az="return (a < 0.) ? b * a : a;",oz=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function mre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=t.makeTensorInfo([],"float32",wl(i,"float32")),o=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fd(oz,r.shape,a.shape):new zu(az,r.shape,a.shape),u=t.runWebGLProgram(o,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),u}const gre={kernelName:Xf,backendName:"webgl",kernelFunc:mre};const lz="return (a < 0.) ? b * a : a;",uz=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function yre(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fd(uz,s.shape,r.shape):new zu(lz,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const xre={kernelName:pm,backendName:"webgl",kernelFunc:yre};const zd="if (isnan(x)) return x;";function Mt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,u=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const p=o.texData.get(a.dataId),m=t(p.values,u);return o.makeTensorInfo(a.shape,u,m)}const c=fe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return c?d=new nl(a.shape,e):d=new ga(a.shape,n),o.runWebGLProgram(d,[a],u)}}function Is({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:u,b:c}=a,d=o;if(s&&u.dtype==="complex64"){const x=d.texData.get(u.dataId),b=d.texData.get(c.dataId),[v,w]=[[x.complexTensorInfos.real,b.complexTensorInfos.real],[x.complexTensorInfos.imag,b.complexTensorInfos.imag]].map(I=>{const[$,E]=I,D={dataId:$.dataId,dtype:$.dtype,shape:u.shape},F={dataId:E.dataId,dtype:E.dtype,shape:c.shape},L=new zu(n,u.shape,c.shape);return d.runWebGLProgram(L,[D,F],ys($.dtype,E.dtype))}),N=El({inputs:{real:v,imag:w},backend:d});return d.disposeIntermediateTensorInfo(v),d.disposeIntermediateTensorInfo(w),N}const p=i||ys(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||d.shouldExecuteOnCPU([u,c]))&&r!=null){const x=d.texData.get(u.dataId).values,b=d.texData.get(c.dataId).values,v=u.dtype==="string"?Ki(x):x,w=u.dtype==="string"?Ki(b):b,[N,I]=r(u.shape,c.shape,v,w,p),$=d.makeTensorInfo(I,p),E=d.texData.get($.dataId);return E.values=N,$}const m=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return m?g=new Fd(e,u.shape,c.shape,t):g=new zu(n,u.shape,c.shape),d.runWebGLProgram(g,[u,c],p)}}function wf(n,e=!1){if(n==="linear")return e?Jse:Xse;if(n==="relu")return e?tre:Yse;if(n==="elu")return e?ere:Kse;if(n==="relu6")return e?nre:Qse;if(n==="prelu")return e?uz:lz;if(n==="leakyrelu")return e?oz:az;if(n==="sigmoid")return e?sre:Zse;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}let cz=class{constructor(e,t,s,r=!1,i=!1,a=!1,o=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Ms(this.outputShape.length);const d=r?e[1]:e[2],p=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",g=i?"rc.z, i * 2":"i * 2, rc.z",x=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",w="";o&&(u?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:v=`vec4 activation(vec4 x) {
          ${o}
        }`,w="result = activation(result);");const N=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let I="rc.x",$="rc.x";e[0]<t[0]?I=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&($=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${$};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${x[0]} * ${b[0]});
          result += (${x[1]} * ${b[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${N}

        ${w}

        setOutput(result);
      }
    `}};const cE={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let hE=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=it(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};const dE="return a * b;";function jC(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=ys(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),u=t.texData.get(r.dataId),c=new hE(cE.REAL,s.shape,r.shape),d=new hE(cE.IMAG,s.shape,r.shape),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(c,p,"float32"),g=t.runWebGLProgram(d,p,"float32"),x=El({inputs:{real:m,imag:g},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),x}if(t.shouldExecuteOnCPU([s,r])){const o=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[c,d]=yse(s.shape,r.shape,o.values,u.values,i),p=t.makeTensorInfo(d,i),m=t.texData.get(p.dataId);return m.values=c,p}let a;return fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Fd(dE,s.shape,r.shape):a=new zu(dE,s.shape,r.shape),t.runWebGLProgram(a,[s,r],i)}const bre={kernelName:rd,backendName:"webgl",kernelFunc:jC};function vre(n,e,t){const s=[vh(n.shape),...wh(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[vh(e),...wh(e)],a=new iz(i,s),o=!0,u=[s],c=t.runWebGLProgram(a,[r],n.dtype,u,o);return{dataId:c.dataId,shape:e,dtype:c.dtype}}function Pe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=t,o=ce(r.shape),u=J2(i,o),c=ce(u);B(o===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=a.texData.get(r.dataId);return d.isPacked&&!Cx(r.shape,u)&&!(d.texture!==null&&Cx(d.shape,u))?vre(r,u,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const wre={kernelName:mm,backendName:"webgl",kernelFunc:Pe};class pE{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];const o=Math.floor(s/4)*4,u=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const p=1/t;c=`sumValue += dot(values * ${hh(p)?p.toPrecision(2):p}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}let Sre=class{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let o="0.0",u="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",u="min"):t==="max"&&(o="-1.0 / 1e-20",u="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";t==="all"?(o="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):t==="any"&&(o="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${x}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${c});
      }
    `}};function Cre(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=cb(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Qu(n,e,t,s){const r=Cre(n.shape);let i=n;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:u,outSize:c}=r[a];let d,p;t==="mean"?d=a===0?new pE({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:c},o):new pE({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:c}):d=new Sre({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:c},t),p=i,i=s.runWebGLProgram(d,[i],e),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}let Nre=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=nn(this.rank),i=kre(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function kre(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class $re{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=nn(this.rank),i=rz("rc",this.rank),a=new Array(this.rank);for(let d=0;d<t.length;d++)a[t[d]]=i[d];const o=`vec2(${a.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${u}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${u}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}function Vb(n,e,t){const s=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $re(n.shape,e):new Nre(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function Ire(n,e,t,s){const r=e,i=n.shape.length,a=gt(r,n.shape);let o=a;const u=sn(o,i),c=u!=null;let d=n;c&&(d=Vb(n,u,s),o=mn(o.length,i)),Hn("sum",o,i);const[p,m]=Mn(d.shape,o);let g=p;t&&(g=Dn(p,a));const x=ce(m),v=ce(n.shape)/x,w=Pe({inputs:{x:d},attrs:{shape:[v,x]},backend:s}),N=O0(n.dtype),I=Qu(w,N,"sum",s),$=Pe({inputs:{x:I},attrs:{shape:g},backend:s});return s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(I),c&&s.disposeIntermediateTensorInfo(d),$}function Ub(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return Ire(r,i,a,t)}const Tre={kernelName:wm,backendName:"webgl",kernelFunc:Ub};function Ys(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,o=r.shape.length,u=new Array(o);for(let d=0;d<u.length;d++)u[d]=r.shape[i[d]];let c;if(a.shouldExecuteOnCPU([r])){const p=a.texData.get(r.dataId).values,m=GC(p,r.shape,r.dtype,i,u);c=a.makeTensorInfo(u,r.dtype);const g=a.texData.get(c.dataId);g.values=m}else c=Vb(r,i,a);return c}const Ere={kernelName:yu,backendName:"webgl",kernelFunc:Ys};const hz=1e3;function Nx({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const c=n.shape.length,d=e.shape.length,p=t?n.shape[c-2]:n.shape[c-1],m=s?e.shape[d-1]:e.shape[d-2],g=t?n.shape[c-1]:n.shape[c-2],x=s?e.shape[d-2]:e.shape[d-1],b=n.shape.slice(0,-2),v=e.shape.slice(0,-2),w=ce(b),N=ce(v),$=it(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,x]);B(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[w,p,g]:[w,g,p],D=s?[N,x,m]:[N,m,x],F=Pe({inputs:{x:n},backend:r,attrs:{shape:E}}),L=Pe({inputs:{x:e},backend:r,attrs:{shape:D}}),z=[F,L],M=Math.max(w,N),O=t?F.shape[1]:F.shape[2],H=i!=null,X=a!=null,te=u==="leakyrelu",Z=u!=null?wf(u,!0):null,W=H||X||te||Z!=null;let ee;if((g===1||x===1)&&O>hz&&W===!1){let de=F,ge=L;t&&(de=Ys({inputs:{x:F},backend:r,attrs:{perm:[0,2,1]}}),z.push(de)),s&&(ge=Ys({inputs:{x:L},backend:r,attrs:{perm:[0,2,1]}}),z.push(ge));const G=x!==1,re=x===1;let pe=de;G&&(pe=Pe({inputs:{x:de},backend:r,attrs:{shape:[M,O,1]}}),z.push(pe));const ve=x===1?2:1;let Ne=ge;re&&(Ne=Pe({inputs:{x:ge},backend:r,attrs:{shape:[M,1,O]}}),z.push(Ne));const Ee=jC({inputs:{a:pe,b:Ne},backend:r});ee=Ub({inputs:{x:Ee},backend:r,attrs:{axis:ve,keepDims:!0}}),z.push(Ee)}else{const de=ys(n.dtype,e.dtype),ge=new cz(E,D,[M,g,x],t,s,H,Z,X,te),G=[F,L];if(i!=null&&G.push(i),X&&G.push(a),te){const re=r.makeTensorInfo([],"float32",wl(o,"float32"));G.push(re),z.push(re)}ee=r.runWebGLProgram(ge,G,de)}const ie=Pe({inputs:{x:ee},backend:r,attrs:{shape:$}});z.push(ee);for(const de of z)r.disposeIntermediateTensorInfo(de);return ie}function Rre(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=s;return Nx({a:r,b:i,transposeA:u,transposeB:c,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:p,activation:d})}const Are={kernelName:rf,backendName:"webgl",kernelFunc:Rre};const fE="return abs(x);";function Dre(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),a=nz(i.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return fe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new nl(s.shape,fE):r=new ga(s.shape,fE),t.runWebGLProgram(r,[s],s.dtype)}const _re={kernelName:If,backendName:"webgl",kernelFunc:Dre};const Ore=Ei+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Fre=Mt({opSnippet:Ore}),zre={kernelName:Eh,backendName:"webgl",kernelFunc:Fre};const Lre=Ei+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Mre=Mt({opSnippet:Lre}),Pre={kernelName:Rh,backendName:"webgl",kernelFunc:Mre};const mE="return a + b;",Bre=Is({opSnippet:mE,packedOpSnippet:mE,supportsComplex:!0,cpuKernelImpl:Yne}),Vre={kernelName:Pu,backendName:"webgl",kernelFunc:Bre};class Ure{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}let Wre=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function qy(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Rr({inputs:{x:s[0]},backend:t});if(s.length>fe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),c=qy({inputs:s.slice(0,u),backend:t}),d=qy({inputs:s.slice(u),backend:t});return qy({inputs:[c,d],backend:t})}const r=s.map(u=>u.dtype).reduce((u,c)=>ys(u,c)),i=s.map(u=>u.shape),o=fe().getBool("WEBGL_PACK")?new Wre(s[0].shape,i):new Ure(s[0].shape,i);return t.runWebGLProgram(o,s,r)}const Gre={kernelName:Tf,backendName:"webgl",kernelFunc:qy};function Hre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=gt(i,r.shape);let c=u;const d=sn(c,o);let p=r;d!=null&&(p=Ys({inputs:{x:r},backend:t,attrs:{perm:d}}),c=mn(c.length,o)),Hn("all",c,o);const[m,g]=Mn(p.shape,c),x=ce(g),b=Pe({inputs:{x:p},backend:t,attrs:{shape:[-1,x]}}),v=Qu(b,b.dtype,"all",t);let w;if(a){const N=Dn(m,u);w=Pe({inputs:{x:v},backend:t,attrs:{shape:N}})}else w=Pe({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),d!=null&&t.disposeIntermediateTensorInfo(p),w}const jre={kernelName:zx,backendName:"webgl",kernelFunc:Hre};function qre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=gt(i,r.shape);let c=u;const d=sn(c,o);let p=r;d!=null&&(p=Ys({inputs:{x:r},backend:t,attrs:{perm:d}}),c=mn(c.length,o)),Hn("any",c,o);const[m,g]=Mn(p.shape,c),x=ce(g),b=Pe({inputs:{x:p},backend:t,attrs:{shape:[-1,x]}}),v=Qu(b,b.dtype,"any",t);let w;if(a){const N=Dn(m,u);w=Pe({inputs:{x:v},backend:t,attrs:{shape:N}})}else w=Pe({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),d!=null&&t.disposeIntermediateTensorInfo(p),w}const Xre={kernelName:Lx,backendName:"webgl",kernelFunc:qre};let Kre=class{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const o=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};class Yre{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,B(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],a=Math.ceil(i/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,c=nn(u),d=qs("coords",u);let p,m;if(a===1){m=u+1;const L=nn(m);p=`
        ${L} sourceLocR = ${L}(${d.join()}, 0);
        ++${d[u-1]};
        ${L} sourceLocG = ${L}(${d.join()}, 0);
        ++${d[u-2]};
        ${L} sourceLocA = ${L}(${d.join()}, 0);
        --${d[u-1]};
        ${L} sourceLocB = ${L}(${d.join()}, 0);
        --${d[u-2]};`}else m=u,p=`
        ${c} sourceLocR = coords;
        ++${d[u-1]};
        ${c} sourceLocG = coords;
        ++${d[u-2]};
        ${c} sourceLocA = coords;
        --${d[u-1]};
        ${c} sourceLocB = coords;
        --${d[u-2]};`;const g=["x","y","z","w","u","v"].slice(0,m),x="."+g[m-1],b=g.map(L=>"int "+L),v=qs("sourceLocR",m-1).concat("inIdx.r"),w=qs("sourceLocG",m-1).concat("inIdx.g"),N=qs("sourceLocB",m-1).concat("inIdx.b"),I=qs("sourceLocA",m-1).concat("inIdx.a"),$=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${N.join()}),
                             getBestIndicesAChannel(${I.join()})));`,D=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${N.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,F=r?"":`
      float getBestIndicesAChannel(${b.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${b.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${d[u-1]} < ${o[u-1]-1};
        bool hasNextRow = ${d[u-2]} < ${o[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${x}, sourceLocG${x},
          sourceLocB${x}, sourceLocA${x}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${D};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${D};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function dz(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const a=cb(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},u=new Kre(o,t,s==null),c=[e];s!=null&&c.push(s);const d=n.runWebGLProgram(u,c,"int32");if(d.shape[1]===1)return d;const p=dz(n,e,t,d);return n.disposeIntermediateTensorInfo(d),p}function pz(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],a=cb(i),o=new Yre(r,a,t,s==null),u=s==null?[e]:[e,s],c=n.runWebGLProgram(o,u,"int32");if(c.shape.length===e.shape.length){const d=pz(n,e,t,c);return n.disposeIntermediateTensorInfo(c),d}return c}function fz(n,e,t,s){const r=[t];if(Hn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!fe().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],a=n.texData.get(e.dataId),o=a!==null&&a.isPacked;let u=e;o&&(u=n.unpackTensor(e),i.push(u));const[c,d]=Mn(u.shape,r),p=ce(d),m=Pe({inputs:{x:u},backend:n,attrs:{shape:[-1,p]}});i.push(m);const g=dz(n,m,s);i.push(g);const x=Pe({inputs:{x:g},backend:n,attrs:{shape:c}});return i.forEach(b=>n.disposeIntermediateTensorInfo(b)),x}return pz(n,e,s)}function Qre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=gt(i,r.shape);const o=sn(a,r.shape.length);let u=r;const c=[];o!=null&&(u=Ys({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(u),a=mn(a.length,u.shape.length)),Hn("argMax",[a[0]],u.shape.length);const d=fz(t,u,a[0],"max");return c.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const Zre={kernelName:Ef,backendName:"webgl",kernelFunc:Qre};function Jre(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=gt(i,r.shape);const o=sn(a,r.shape.length);let u=r;const c=[];o!=null&&(u=Ys({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(u),a=mn(a.length,u.shape.length)),Hn("argMin",[a[0]],u.shape.length);const d=fz(t,u,a[0],"min");return c.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const eie={kernelName:Rf,backendName:"webgl",kernelFunc:Jre};const tie=Ei+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,nie=Mt({opSnippet:tie}),sie={kernelName:Ah,backendName:"webgl",kernelFunc:nie};const rie=Ei+"return log(x + sqrt(x * x + 1.0));",iie=Mt({opSnippet:rie}),aie={kernelName:Dh,backendName:"webgl",kernelFunc:iie};const oie=Ei+`
  return atan(x);
`,lie=Mt({opSnippet:oie}),uie={kernelName:_h,backendName:"webgl",kernelFunc:lie};const cie=HC+`
  return atan(a, b);
`,hie=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Yu+`
  return result;
`,die=Is({opSnippet:cie,packedOpSnippet:hie}),pie={kernelName:Fh,backendName:"webgl",kernelFunc:die};const fie=Ei+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,mie=Mt({opSnippet:fie}),gie={kernelName:Oh,backendName:"webgl",kernelFunc:mie};let Sf=class{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let N="0.0";if(b||(N="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${u});
        const ivec2 pads = ivec2(${g}, ${x});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?v:w:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let $=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&($="avgValue / max(count, 1.0)");const E=Math.floor(a/4)*4,D=a%4,F=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${g}, ${x});
      const float initializationValue = ${N};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${N});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${E};
          if (${D===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${$});
      }
    `}},qC=class{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,u=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,g=e.effectiveFilterDepth,x=e.effectiveFilterHeight,b=e.effectiveFilterWidth,v=e.padInfo.front,w=e.padInfo.top,N=e.padInfo.left;this.outputShape=e.outShape;const I=t==="avg";let $="0.0";if(I||($="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${u}, ${c});
        const ivec3 pads = ivec3(${v}, ${w}, ${N});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${x};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${b};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${x} * ${b} +
                      wR * ${b} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let D=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(D="avgValue / max(count, 1.0)");const F=Math.floor(a/4)*4,L=a%4,z=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${u}, ${c});
      const ivec3 pads = ivec3(${v}, ${w}, ${N});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${x};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${z}
            }

            int xC = xCCorner + ${F};
            if (${L===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${L===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${z}
            } else if (${L===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${z}
            }
          }
        }
        setOutput(${D});
      }
    `}};function yie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Xm(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,c=1;B(is(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=zs(r.shape,i,a,c,o,u);if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))return Rr({inputs:{x:r},backend:t});const p=new Sf(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const xie={kernelName:Af,backendName:"webgl",kernelFunc:yie};function bie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:c}=s,d=[1,1,1],p=Qr(r.shape,i,a,d,o,u,c),m=new qC(p,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const vie={kernelName:Df,backendName:"webgl",kernelFunc:bie};let wie=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=u-1-e.padInfo.top,p=c-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Sie=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,g=e.effectiveFilterWidth,x=p-1-e.padInfo.front,b=m-1-e.padInfo.top,v=g-1-e.padInfo.left,w=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${x}, ${b}, ${v});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Cie(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:u,pad:c,dimRoundingMode:d}=s,p=[1,1,1],m=Qr(a.shape,o,u,p,c,d),g=new Sie(m);return t.runWebGLProgram(g,[r],a.dtype)}const Nie={kernelName:Px,backendName:"webgl",kernelFunc:Cie};function kie(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;Xm([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=s,d=zs(a.shape,o,u,1,c),p=new wie(d);return t.runWebGLProgram(p,[r],a.dtype)}const $ie={kernelName:Mx,backendName:"webgl",kernelFunc:kie};function Iie(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return Nx({a:r,b:i,transposeA:a,transposeB:o,backend:t})}const Tie={kernelName:_f,backendName:"webgl",kernelFunc:Iie};let Eie=class{constructor(e,t,s,r,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],it(e,t),it(e,s);let o="0.0";r!=null&&(it(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";i!=null&&(it(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};class Rie{constructor(e,t,s,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],it(e,t),it(e,s);let o="vec4(0.0)";r!=null&&(it(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";i!=null&&(it(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const Aie=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:a,scale:o}=n;B(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const c=[s,r,i];let d=null;a!=null&&(d=a.shape,c.push(a));let p=null;o!=null&&(p=o.shape,c.push(o));const m=fe().getBool("WEBGL_PACK_NORMALIZATION")?new Rie(s.shape,r.shape,i.shape,d,p,u):new Eie(s.shape,r.shape,i.shape,d,p,u);return e.runWebGLProgram(m,c,c[0].dtype)},Die={kernelName:Hf,backendName:"webgl",kernelFunc:Aie};let _ie=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=nn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Oie(this.rank);let r;const i=e.map((a,o)=>`sourceLoc.${L2[o]} = start[${o}] + coords.${L2[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}};const L2=["x","y","z","w","u","v"];function Oie(n){if(n===1)return"sourceLoc";if(n<=6)return L2.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Fie{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=nn(this.rank),s=qs("coords",this.rank),r=qs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,p)=>`start[${p}]`).join()});`:e.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${u}
        setOutput(result);
      }
    `}}function zie(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let o=rC(e,Ze(n.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,u+1),i}function Ld(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[o,u]=Fm(r,i,a);if(ab(r,o,u),ce(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=t.texData.get(r.dataId),m=Tse(p.values,o,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,m)}const{isPacked:c}=t.texData.get(r.dataId),d=sC(r.shape,o,u);if(c||!d){const p=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fie(u):new _ie(u),m=[o];return t.runWebGLProgram(p,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),zie(r,o,u,t)}const Lie={kernelName:vm,backendName:"webgl",kernelFunc:Ld};const Mie=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;B(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((N,I)=>N*I),u=Wu(r.shape,i,o),c=Gu(u.length,i.length),d=Hu(r.shape,i,o),p=db(a,i.length),m=pb(d,a,i.length),g=[],x=Pe({inputs:{x:r},backend:t,attrs:{shape:u}}),b=Ys({inputs:{x},backend:t,attrs:{perm:c}}),v=Pe({inputs:{x:b},backend:t,attrs:{shape:d}}),w=Ld({inputs:{x:v},backend:t,attrs:{begin:p,size:m}});return g.push(x),g.push(b),g.push(v),g.forEach(N=>t.disposeIntermediateTensorInfo(N)),w},Pie={kernelName:Of,backendName:"webgl",kernelFunc:Mie};function Bie(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.readSync(r.dataId),u=t.readSync(i.dataId),c=tz(o,u,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,c)}const Vie={kernelName:Bx,backendName:"webgl",kernelFunc:Bie};const Uie=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Wie=`
  return float(int(a.r) & int(b.r));
`;function Gie(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=fe().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const u=t.texData.get(s.dataId).values,c=t.texData.get(r.dataId).values,[d,p]=Zne(s.shape,r.shape,u,c,s.dtype),m=t.makeTensorInfo(p,s.dtype),g=t.texData.get(m.dataId);return g.values=d,m}let o;return i?o=new Fd(Uie,s.shape,r.shape,!1):o=new zu(Wie,s.shape,r.shape),t.runWebGLProgram(o,[s,r],s.dtype)}const Hie={kernelName:Vx,backendName:"webgl",kernelFunc:Gie};function jie(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),o=it(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const qie={kernelName:Ux,backendName:"webgl",kernelFunc:jie};const Xie="return float(a != b);",mz=Is({opSnippet:Xie,cpuKernelImpl:bse,dtype:"bool"}),Kie={kernelName:lm,backendName:"webgl",kernelFunc:mz};function Ym(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Rr({inputs:{x:r.complexTensorInfos.real},backend:t})}const Yie={kernelName:y0,backendName:"webgl",kernelFunc:Ym};const Qie="return float(int(x));";function Zie(n,e){const t=new ga(n.shape,Qie),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function M2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Rr({inputs:{x:r},backend:t});const a=zn(r.shape),o=M2({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=El({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){const a=Ym({inputs:{input:r},backend:t}),o=M2({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(a),o}if(!eS(r.dtype,i)){const a=Rr({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[o,u,c]=Jne(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,u,c)}if(i==="int32")return Zie(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",ss("bool",1)),u=mz({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Jie={kernelName:zh,backendName:"webgl",kernelFunc:M2};const gE="return ceil(x);",eae=Mt({opSnippet:gE,packedOpSnippet:gE,cpuKernelImpl:ese}),tae={kernelName:Lh,backendName:"webgl",kernelFunc:eae};let nae=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};class sae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function rae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;fe().getBool("WEBGL_PACK_CLIP")?o=new sae(r.shape):o=new nae(r.shape);const u=[[i],[a]];return t.runWebGLProgram(o,[r],r.dtype,u)}const iae={kernelName:Mh,backendName:"webgl",kernelFunc:rae};let aae=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function yE(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function oae(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new aae(s.shape),a=[yE(s,r.complexTensorInfos.real),yE(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,a,a[0].dtype)}const lae={kernelName:Ff,backendName:"webgl",kernelFunc:oae};let uae=class{constructor(e){this.outputShape=[],this.outputShape=lr(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}};class cae{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=lr(e,t);const s=this.outputShape,r=s.length,i=nn(r),a=qs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((b,v)=>`T${v}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let b=1;b<u.length;b++)u[b]=u[b-1]+e[b][t];const c=o[t],d=o.slice(-2),p=o.join();let m=`if (${c} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let b=1;b<u.length;b++){const v=u[b-1];m+=`
        if (${c} < ${u[b]}  && ${c} >= ${u[b-1]}) {
          return getChannel(
            getT${b}(${_y(o,c,v)}),
            vec2(${_y(d,c,v)}));
        }`}const g=u.length,x=u[u.length-1];m+=`
        return getChannel(
          getT${g}(${_y(o,c,x)}),
          vec2(${_y(d,c,x)}));`,this.userCode=`
      float getValue(${o.map(b=>"int "+b)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function _y(n,e,t){const s=n.indexOf(e);return n.map((i,a)=>a===s?`${i} - ${t}`:i).join()}function Wb(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Rr({inputs:{x:r.complexTensorInfos.imag},backend:t})}const hae={kernelName:o0,backendName:"webgl",kernelFunc:Wb};function Zp(n,e,t){const s=n[0].dtype;if(s==="complex64"){const g=n.map(N=>Ym({inputs:{input:N},backend:t})),x=n.map(N=>Wb({inputs:{input:N},backend:t})),b=Zp(g,e,t),v=Zp(x,e,t),w=El({inputs:{real:b,imag:v},backend:t});return g.forEach(N=>t.disposeIntermediateTensorInfo(N)),x.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),w}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const g=n.map($=>{const D=[-1,ce($.shape.slice(e))];return Pe({inputs:{x:$},backend:t,attrs:{shape:D}})}),x=g.map($=>({vals:t.readSync($.dataId),shape:$.shape})),b=lr(g.map($=>$.shape),1),v=g[0].shape[0]===1,w=tse(x,b,s,v),N=lr(n.map($=>$.shape),e),I=t.makeTensorInfo(N,s,w);return g.forEach($=>t.disposeIntermediateTensorInfo($)),I}const i=n.filter(g=>ce(g.shape)>0),a=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const g=a?new ga(n[0].shape,Zo):new nl(n[0].shape,Zo);return t.runWebGLProgram(g,n,s)}const o=fe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){const g=[];for(let b=0;b<i.length;b+=o){const v=i.slice(b,b+o);g.push(Zp(v,e,t))}const x=Zp(g,e,t);for(const b of g)t.disposeIntermediateTensorInfo(b);return x}if(a){const g=new cae(i.map(x=>x.shape),e);return t.runWebGLProgram(g,i,s)}const{tensors2D:u,outShape:c}=dae(i,e,t),d=new uae(u.map(g=>g.shape)),p=t.runWebGLProgram(d,u,s);u.forEach(g=>t.disposeIntermediateTensorInfo(g));const m=Pe({inputs:{x:p},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(p),m}function dae(n,e,t){const s=lr(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Pe({inputs:{x:i},attrs:{shape:[-1,ce(i.shape.slice(e))]},backend:t})),outShape:s}}function gz(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=gt(r,e[0].shape)[0],a=e.map(c=>c.shape);ub(a,i);const o=lr(e.map(c=>c.shape),i);if(ce(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(c=>ce(c.shape)>0);return u.length===1?Rr({inputs:{x:u[0]},backend:t}):Zp(u,i,t)}const pae={kernelName:zf,backendName:"webgl",kernelFunc:gz};class yz{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,u=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,m=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,b=e.inChannels%4,v=e.dataFormat==="channelsLast",w=v?1:2,N=v?2:3,I=v?3:1;let $="",E="";s&&(r?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:$=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const D=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${N}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${x}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${b===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${x}) *
                    getW(wR, wC, ${x}, d2);
              } else {
                dotProd +=
                    getX(batch, ${x}, xR, xC) *
                    getW(wR, wC, ${x}, d2);
              }

            } else if (${b===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${b===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2),
                getW(wR, wC, ${x} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1),
                  getX(batch, xR, xC, ${x} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC),
                  getX(batch, ${x} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${D}
        ${E}
        setOutput(result);
      }
    `}}class fae{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.filterDepth,m=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,b=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${x}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${b===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${x}) *
                  getW(wF, wR, wC, ${x}, d2);
              } else if (${b===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${b===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1),
                  getX(batch, xF, xR, xC, ${x} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2),
                  getW(wF, wR, wC, ${x} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class xz{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ms(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)m+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;m+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<d;v++)m+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(p+1)/2;v++){const w=v*2;if(m+=`
           xC = xCCorner + ${w*u};
           `,o===1){if(w<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }
               `,u===1&&w>0?m+=`
                 xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                   } else {
                     xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xC${w} = xTexelC${w};
                 `,w+1<d)){const N=a%2===0?Z2(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${N};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                     xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${w+1}.zw = vec2(0.0);
                     }
                     xTexelC${w+1}Ready = 1;
                   }
                   `,u>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                     } else {
                      xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                     }
                     `:m+=`
                     xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                     `):N===1?m+=`
                     xC${w+1} = xTexelC${w};
                     `:m+=`
                     xCOffset = xC + ${N};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                       xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${w+1}.zw = vec2(0.0);
                       }
                       xTexelC${w+1}Ready = 1;
                     }

                     xC${w+1} = xTexelC${w+1};
                     `}}else w<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.0);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
               `,w+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(
                   xTexelC${w}.xy, xTexelC${w+1}.xy);
               `,w+1<d&&(m+=`
                   xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                 `)));w<d&&(m+=`
             wTexel = getW(r, ${w}, d1, d2);
             dotProd += xC${w}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${w}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,w+1<d&&(m+=`
               wTexel = getW(r, ${w+1}, d1, d2);
               dotProd += xC${w+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${w+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let g="",x="";s&&(r?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:g=`vec4 activation(vec4 x) {
           ${s}
         }`,x="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${b}
         ${x}
         setOutput(result);
       }
     `}}class mae{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ms(this.outputShape.length);const{dataFormat:s}=t,r=Zs(),i=s==="channelsLast",a=i?1:2,o=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)c+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}function kx(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function bz({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=n.shape,c=s.texData.get(n.dataId),d=t.inChannels,p=u[0]*u[1]*u[2],m=t.outChannels,g=t.dataFormat==="channelsLast",x=!1,b=!1;let v;const w=[];if(i!=null){const $=kx(i.shape,g);$!=null&&(i=Pe({inputs:{x:i},backend:s,attrs:{shape:$}}),w.push(i))}if(r!=null){const $=kx(r.shape,g);$!=null&&(r=Pe({inputs:{x:r},backend:s,attrs:{shape:$}}),w.push(r))}if(!((p===1||m===1)&&d>hz)&&c.isPacked&&g&&c.texture!=null&&u[2]%2!==0&&xt(c.shape.slice(-3),u.slice(-3))){const $=u[0]*u[1]*(u[2]+1),E={dataId:n.dataId,shape:[1,$,t.inChannels],dtype:n.dtype},D=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,B(Cx(c.shape,E.shape),()=>`packed reshape ${c.shape} to ${E.shape} isn't free`);const F=Pe({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});w.push(F);const L=Nx({a:E,b:F,backend:s,transposeA:x,transposeB:b,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),z=s.texData.get(L.dataId);B(z.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=D,z.shape=t.outShape,v=Rr({inputs:{x:L},backend:s}),v.shape=t.outShape,w.push(L)}else{const $=t.outHeight*t.outWidth,E=Pe({inputs:{x:n},backend:s,attrs:{shape:g?[t.batchSize,$,t.inChannels]:[t.batchSize,t.inChannels,$]}}),D=Pe({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),F=Nx({a:g?E:D,b:g?D:E,transposeA:!g,transposeB:b,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});v=Pe({inputs:{x:F},backend:s,attrs:{shape:t.outShape}}),w.push(E),w.push(D),w.push(F)}for(const $ of w)s.disposeIntermediateTensorInfo($);return v}function vz({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:p,outHeight:m,dataFormat:g}=t,x=g==="channelsLast",b=u*c*d,v=m*p,w=[t.batchSize,b,v],N=!0,I=!1,$=[];if(i!=null){const ie=kx(i.shape,x);ie!=null&&(i=Pe({inputs:{x:i},backend:s,attrs:{shape:ie}}),$.push(i))}if(r!=null){const ie=kx(r.shape,x);ie!=null&&(r=Pe({inputs:{x:r},backend:s,attrs:{shape:ie}}),$.push(r))}const E=Pe({inputs:{x:e},backend:s,attrs:{shape:[1,b,ce(e.shape)/b]}});$.push(E);const D=new mae(w,t),F=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],L=s.runWebGLProgram(D,[n],"float32",F),z=Pe({inputs:{x:L},backend:s,attrs:{shape:w}});$.push(L),$.push(z);const M=r!=null,O=i!=null,H=o==="leakyrelu",X=o?wf(o,!0):null,te=new cz(x?z.shape:E.shape,x?E.shape:z.shape,x?[t.batchSize,v,t.outChannels]:[t.batchSize,t.outChannels,v],N,I,M,X,O,H),Z=x?[z,E]:[E,z];if(r&&Z.push(r),O&&Z.push(i),H){const ie=s.makeTensorInfo([],"float32",wl(a,"float32"));Z.push(ie),$.push(ie)}const W=s.runWebGLProgram(te,Z,"float32"),ee=Pe({inputs:{x:W},backend:s,attrs:{shape:t.outShape}});$.push(W);for(const ie of $)s.disposeIntermediateTensorInfo(ie);return ee}function gae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:u,dilations:c,dimRoundingMode:d}=s,p=Dr(u),m=fn(r.shape,i.shape,a,c,o,d,!1,p);let g;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=bz({x:r,filter:i,convInfo:m,backend:t});else if(m.strideWidth<=2&&p==="channelsLast"&&fe().getBool("WEBGL_EXP_CONV")){const b=new xz(m),v=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];g=t.runWebGLProgram(b,[r,i],"float32",v)}else if(fe().getBool("WEBGL_CONV_IM2COL"))g=vz({x:r,filter:i,convInfo:m,backend:t});else{const b=new yz(m);g=t.runWebGLProgram(b,[r,i],"float32")}const x=Pe({inputs:{x:g},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(g),x}const yae={kernelName:Lf,backendName:"webgl",kernelFunc:gae};let xae=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},bae=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,u=s-1-e.padInfo.left,c=a?1:2,d=a?2:3,p=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},vae=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},wae=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,u=t-1-e.padInfo.front,c=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Sae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:d}=s,p=Dr(u),m=fn(r.shape,d,a,1,o,c,!1,p),g=new xae(m);return t.runWebGLProgram(g,[r,i],"float32")}const Cae={kernelName:Gx,backendName:"webgl",kernelFunc:Sae};class Nae{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ms(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function kae(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:u,dataFormat:c,dimRoundingMode:d}=s,p=Dr(c),m=fn(a,i.shape,o,1,u,d,!1,p);if(fe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const g=[[m.strideHeight,m.strideWidth]],x=new Nae(m);return t.runWebGLProgram(x,[r,i],"float32",g)}else{const g=new bae(m);return t.runWebGLProgram(g,[r,i],"float32")}}const $ae={kernelName:Mf,backendName:"webgl",kernelFunc:kae};function Iae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s,c=ea(r.shape,i.shape,a,u,o),d=new fae(c);return t.runWebGLProgram(d,[r,i],"float32")}const Tae={kernelName:Pf,backendName:"webgl",kernelFunc:Iae};function Eae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:u}=s,c=ea(r.shape,u,a,1,o),d=new vae(c);return t.runWebGLProgram(d,[r,i],"float32")}const Rae={kernelName:Hx,backendName:"webgl",kernelFunc:Eae};function Aae(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:u}=s,c=ea(u,i.shape,o,1,a),d=new wae(c);return t.runWebGLProgram(d,[r,i],"float32")}const Dae={kernelName:jx,backendName:"webgl",kernelFunc:Aae};const _ae=zd+`
  return cos(x);
`,Oae=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Yu}
  return result;
`,Fae=Mt({opSnippet:_ae,packedOpSnippet:Oae}),zae={kernelName:Ph,backendName:"webgl",kernelFunc:Fae};const Lae=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Mae=Mt({opSnippet:Lae}),Pae={kernelName:Bh,backendName:"webgl",kernelFunc:Mae};let Bae=class{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,u,c]=e,[d]=t,[p,m]=s;this.outputShape=[d,p,m,c];const g=r==="bilinear"?1:0,[x,b]=[`${o-1}.0`,`${u-1}.0`],[v,w,N]=p>1?[`${(o-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[I,$,E]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${b} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${b}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${$};

        float in_y = ${N};
        if( in_y < 0.0 || in_y > ${x} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${b} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};const Vae=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:u,extrapolationValue:c}=s,d=new Bae(r.shape,i.shape,o,u,c);return t.runWebGLProgram(d,[r,i,a],"float32")},Uae={kernelName:Xx,backendName:"webgl",kernelFunc:Vae};var Cf;(function(n){n.Prod="*",n.Sum="+"})(Cf||(Cf={}));let xE=class{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===Cf.Prod?"1.0":"0.0",o=s?a:`getX(${bE(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",d="";s?(c=r?`end != ${u-1}`:"end != 0",d=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${u}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${nn(i)} coords = getOutputCoords();
        int end = ${vE(i,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${d};
          ${vE(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${bE(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function bE(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function vE(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function wz(n,e,t,s,r,i){const a=e.shape.length,o=sn([s],a);let u=e;o!=null&&(u=Ys({inputs:{x:e},backend:t,attrs:{perm:o}}));const c=mn(1,a)[0];if(c!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=u.shape[c];let p=Rr({inputs:{x:u},backend:t});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const g=new xE(n,u.shape,!1,i),x=[[m]],b=p;p=t.runWebGLProgram(g,[p],p.dtype,x),t.disposeIntermediateTensorInfo(b)}if(r){const m=new xE(n,u.shape,r,i),g=p;p=t.runWebGLProgram(m,[p],p.dtype),t.disposeIntermediateTensorInfo(g)}if(o!=null){const m=$a(o),g=Ys({inputs:{x:p},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(u),g}return p}function Wae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return wz(Cf.Prod,r,t,i,a,o)}const Gae={kernelName:qx,backendName:"webgl",kernelFunc:Wae};function Hae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return wz(Cf.Sum,r,t,i,a,o)}const jae={kernelName:Bf,backendName:"webgl",kernelFunc:Hae};function qae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),c=t.readSync(i.dataId),d=tz(u,c,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const u=t.bufferSync(r),c=t.bufferSync(i),d=Qne(u,c,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Xae={kernelName:Kx,backendName:"webgl",kernelFunc:qae};let Kae=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Yae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,o=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],c=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],p=u*i,m=c*i,g=d/(i*i),x=a==="NHWC"?[o,p,m,g]:[o,g,p,m],b=new Kae(x,i,a);return t.runWebGLProgram(b,[r],r.dtype)}const Qae={kernelName:Yx,backendName:"webgl",kernelFunc:Yae};let Sz=class{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ms(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,u=e.outChannels/e.inChannels;let c="",d="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}};class Cz{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ms(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,u=e.strideWidth,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,m=p;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<p;w++)g+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;g+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let w=0;w<p;w++)g+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(m+1)/2;w++){const N=w*2;if(g+=`
          xC = xCCorner + ${N*c};
          `,u===1){if(N<p&&(o%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {
                  xTexelC${N} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${N}.zw = vec2(0.0);
                  }
                  xTexelC${N}Ready = 1;
                }
              `,c===1&&N>0?g+=`
                xC${N} = vec4(xTexelC${N-2}.zw, xTexelC${N}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${N} = vec4(previous.zw, xTexelC${N}.xy);
                  } else {
                    xC${N} = vec4(0.0, 0.0, xTexelC${N}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {
                  xTexelC${N} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${N}.zw = vec2(0.0);
                  }
                  xTexelC${N}Ready = 1;
                }

                xC${N} = xTexelC${N};
                `,N+1<p)){const I=o%2===0?Z2(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {
                    xTexelC${N+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${N+1}.zw = vec2(0.0);
                    }
                    xTexelC${N+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${N+1} = vec4(previous.zw, xTexelC${N+1}.xy);
                    } else {
                     xC${N+1} = vec4(0.0, 0.0, xTexelC${N+1}.xy);
                    }
                    `:g+=`
                    xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.xy);
                    `):I===1?g+=`
                    xC${N+1} = xTexelC${N};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {
                      xTexelC${N+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${N+1}.zw = vec2(0.0);
                      }
                      xTexelC${N+1}Ready = 1;
                    }

                    xC${N+1} = xTexelC${N+1};
                    `}}else N<p&&(o%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {
                  xTexelC${N} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${N}.zw = vec2(0.0);
                  }
                  xTexelC${N}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${N+1}Ready == 0) {
                  xTexelC${N+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${N+1}.zw = vec2(0.0);
                  }
                  xTexelC${N+1}Ready = 1;
                }

                xC${N} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);
              `,N+1<p&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${N+1} = vec4(xTexelC${N+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {
                  xTexelC${N} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${N}.zw = vec2(0.0);
                  }
                  xTexelC${N}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {
                  xTexelC${N+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${N+1}.zw = vec2(0.);
                  }
                  xTexelC${N+1}Ready = 1;
                }

                xC${N} = vec4(
                  xTexelC${N}.xy, xTexelC${N+1}.xy);
              `,N+1<p&&(g+=`
                  xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);
                `)));N<p&&(g+=`
            wTexel = getW(r, ${N}, d1, q);
            dotProd += xC${N} * vec4(wTexel.xz, wTexel.xz);
          `,N+1<p&&(g+=`
              wTexel = getW(r, ${N+1}, d1, q);
              dotProd += xC${N+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let x="",b="";s&&(r?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`vec4 activation(vec4 x) {
          ${s}
        }`,b="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${b}
        setOutput(result);
      }
    `}}function Zae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u,dimRoundingMode:c}=s;let d=u;d==null&&(d=[1,1]),B(is(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=fn(r.shape,i.shape,a,d,o,c,!0);let m;fe().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new Cz(p):m=new Sz(p);const g=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(m,[r,i],"float32",g)}const Jae={kernelName:Vf,backendName:"webgl",kernelFunc:Zae};let eoe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},toe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,o=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function noe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:c,filterShape:d}=s,p=fn(r.shape,d,a,o,u,c,!0),m=new eoe(p);return t.runWebGLProgram(m,[r,i],"float32")}const soe={kernelName:Qx,backendName:"webgl",kernelFunc:noe};function roe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:c,inputShape:d}=s,p=fn(d,i.shape,a,o,u,c,!0),m=new toe(p);return t.runWebGLProgram(m,[r,i],"float32")}const ioe={kernelName:Zx,backendName:"webgl",kernelFunc:roe};let aoe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function ooe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=ce(s.shape),a=Pe({inputs:{x:s},backend:t,attrs:{shape:[i]}}),o=new aoe(i),u=t.runWebGLProgram(o,[a],a.dtype),c=Pe({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),c}const loe={kernelName:Jx,backendName:"webgl",kernelFunc:ooe};let uoe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:u,dilationHeight:c,dilationWidth:d}=e,{top:p,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function coe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s,c=Nl(r.shape,i.shape,a,o,"NHWC",u);let d;const p=new uoe(c);d=t.runWebGLProgram(p,[r,i],"float32");const m=Pe({inputs:{x:d},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(d),m}const hoe={kernelName:Uf,backendName:"webgl",kernelFunc:coe};function doe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:u}=vb(r,i.length);Sb(a.length,u,i);const{path:c,steps:d}=Cb(o,u),p=d.length;let m=null,g=a.length;const x=[];for(let b=0;b<p;++b){for(const v of d[b]){const{permutationIndices:w,expandDims:N}=wb(g,u[v]);let I;Nb(w)?I=i[v]:(I=Ys({inputs:{x:i[v]},backend:t,attrs:{perm:w}}),x.push(I));const $=I.shape.slice();for(let E=0;E<N.length;++E)$.splice(N[E],0,1);xt(I.shape,$)||(I=Pe({inputs:{x:I},backend:t,attrs:{shape:$}}),x.push(I)),m===null?m=I:(m=jC({inputs:{a:I,b:m},backend:t}),x.push(m))}b<p-1&&(c[b]>=0&&(m=Ub({inputs:{x:m},backend:t,attrs:{axis:c[b]-(a.length-g),keepDims:!1}}),x.push(m)),g--)}for(const b of x)b!==m&&t.disposeIntermediateTensorInfo(b);return m}const poe={kernelName:e0,backendName:"webgl",kernelFunc:doe};const foe="return (x >= 0.0) ? x : (exp(x) - 1.0);",moe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,goe=Mt({opSnippet:foe,packedOpSnippet:moe}),yoe={kernelName:Uh,backendName:"webgl",kernelFunc:goe};const xoe="return (b >= 0.0) ? a : a * (b + 1.0);",boe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,voe=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=fe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fd(boe,s.shape,r.shape):new zu(xoe,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},woe={kernelName:t0,backendName:"webgl",kernelFunc:voe};const Soe=`
  return vec4(equal(a, b));
`,Coe="return float(a == b);",Noe=Is({opSnippet:Coe,packedOpSnippet:Soe,dtype:"bool",cpuKernelImpl:nse}),koe={kernelName:Wf,backendName:"webgl",kernelFunc:Noe};const $oe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${fb};
  float a1 = ${mb};
  float a2 = ${gb};
  float a3 = ${yb};
  float a4 = ${xb};
  float a5 = ${bb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Ioe=Mt({opSnippet:$oe}),Toe={kernelName:Wh,backendName:"webgl",kernelFunc:Ioe};const Eoe=zd+`
  return exp(x);
`,Roe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Nz=Mt({opSnippet:Eoe,packedOpSnippet:Roe,cpuKernelImpl:sse,dtype:"float32"}),Aoe={kernelName:Gh,backendName:"webgl",kernelFunc:Nz};function P2(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,o=i.shape.slice();let u=r;return r<0&&(B(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),o.splice(u,0,1),Pe({inputs:{x:i},backend:s,attrs:{shape:o}})}const Doe={kernelName:Gf,backendName:"webgl",kernelFunc:P2};const wE="return exp(x) - 1.0;",_oe=Mt({opSnippet:wE,packedOpSnippet:wE,cpuKernelImpl:rse}),Ooe={kernelName:Hh,backendName:"webgl",kernelFunc:_oe};let SE=class{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function kz(n,e,t){const s=t.texData.get(n.dataId),r=ce(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=Pe({inputs:{x:n},backend:t,attrs:{shape:[a,i]}}),u=o.shape,c=new SE("real",u,e),d=new SE("imag",u,e),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(c,p,"float32"),g=t.runWebGLProgram(d,p,"float32"),x=El({inputs:{real:m,imag:g},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g);const b=Pe({inputs:{x},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(x),b}function Foe(n){const{inputs:e,backend:t}=n,{input:s}=e;return kz(s,!1,t)}const zoe={kernelName:n0,backendName:"webgl",kernelFunc:Foe};let Loe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Qm(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||Mu(r),i==="string"){const a=En(i,ce(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new Loe(s,r),o=[[r]];return e.runWebGLProgram(a,[],i,o)}}const Moe={kernelName:s0,backendName:"webgl",kernelFunc:Qm};let Poe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};const Boe={kernelName:r0,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Poe(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const CE="return floor(x);",Voe=Mt({opSnippet:CE,packedOpSnippet:CE,cpuKernelImpl:ise}),Uoe={kernelName:jh,backendName:"webgl",kernelFunc:Voe};const Woe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Goe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Hoe=Is({opSnippet:Woe,packedOpSnippet:Goe,dtype:"int32"}),joe={kernelName:qh,backendName:"webgl",kernelFunc:Hoe};let qoe=class{constructor(e){this.variableNames=["A"];const t=Zs(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};class Xoe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Zs(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const Koe={kernelName:ex,backendName:"webgl",kernelFunc:Yoe};let Xc,Ew=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Yoe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,c]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[c,u],p=[c,u,i];if(o||a){const b=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Xc==null||b!==Ew)&&(Ew=b,Xc=document.createElement("canvas").getContext("2d",{willReadFrequently:Ew})),Xc.canvas.width=u,Xc.canvas.height=c,Xc.drawImage(r,0,0,u,c),r=Xc.canvas}const m=t.makeTensorInfo(d,"int32");t.texData.get(m.dataId).usage=jr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const g=fe().getBool("WEBGL_PACK")?new Xoe(p):new qoe(p),x=t.runWebGLProgram(g,[m],"int32");return t.disposeData(m.dataId),x}function Qoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s,b=Dr(d),v=fn(r.shape,i.shape,u,p,c,m,!1,b);let w;const N=[],I=a!=null,$=o!=null,E=g==="leakyrelu",D=()=>{const L=[r,i],z=(M,O)=>{if(O==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const H=Pe({inputs:{x:M},backend:t,attrs:{shape:[M.shape[0],1,1]}});return N.push(H),H}return M};if(I&&L.push(z(a,d)),$&&L.push(z(o,d)),E){const M=t.makeTensorInfo([],"float32",wl(x,"float32"));L.push(M),N.push(M)}return L};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))w=bz({x:r,filter:i,convInfo:v,backend:t,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else if(v.strideWidth<=2&&b==="channelsLast"&&fe().getBool("WEBGL_EXP_CONV")){const L=g?wf(g,!0):null,z=new xz(v,I,L,$,E),M=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],O=D();w=t.runWebGLProgram(z,O,"float32",M)}else if(fe().getBool("WEBGL_CONV_IM2COL"))w=vz({x:r,filter:i,convInfo:v,backend:t,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else{const L=g?wf(g,!1):null,z=new yz(v,I,L,$,E),M=D();w=t.runWebGLProgram(z,M,"float32")}const F=Pe({inputs:{x:w},backend:t,attrs:{shape:v.outShape}});return N.push(w),N.forEach(L=>t.disposeIntermediateTensorInfo(L)),F}const Zoe={kernelName:af,backendName:"webgl",kernelFunc:Qoe};function Joe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:c,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=s,x=[];let b=d;b==null&&(b=[1,1]),B(is(u,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${b}'`);const v=fn(r.shape,i.shape,u,b,c,p,!0),w=fe().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,N=m?wf(m,w):null,I=[r,i],$=a!=null,E=o!=null,D=m==="leakyrelu";if($&&I.push(a),E&&I.push(o),D){const M=t.makeTensorInfo([],"float32",wl(g,"float32"));I.push(M),x.push(M)}let F;w?F=new Cz(v,$,N,E,D):F=new Sz(v,$,N,E,D);const L=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],z=t.runWebGLProgram(F,I,"float32",L);return x.forEach(M=>t.disposeIntermediateTensorInfo(M)),z}const ele={kernelName:of,backendName:"webgl",kernelFunc:Joe};let tle=class{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=nn(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function nle(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=ce(s.shape),[u,c,d,p]=ib(s,r),m=Pe({inputs:{x:r},backend:t,attrs:{shape:[c,a]}}),g=Pe({inputs:{x:s},backend:t,attrs:{shape:[ce(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const w=t.readSync(r.dataId),N=t.bufferSync(s),I=ase(w,N,s.dtype,c,a,d,p,s.shape,o);return t.makeTensorInfo(u,s.dtype,I.values)}const x=new tle(a,p,[c,d],s.shape),b=t.runWebGLProgram(x,[g,m],g.dtype),v=Pe({inputs:{x:b},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),v}const sle={kernelName:i0,backendName:"webgl",kernelFunc:nle};let rle=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=nn(this.rank),r=ile(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function ile(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function $z(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,u=gt(a,r.shape)[0];if(fe().get("DEBUG")){const N=t.readSync(i.dataId),I=r.shape[u];for(let $=0;$<N.length;++$){const E=N[$];B(E<=I-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${I-1}]`)}}const c=$b(r,i,u,o),d=ce(i.shape),p=[],m=Pe({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Pe({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,d/c.batchSize]}});p.push(m),p.push(g);const x=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const N=t.bufferSync(g),I=t.bufferSync(m),$=ose(I,N,x);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(c.outputShape,$.dtype,$.values)}const b=new rle(m.shape,x),v=t.runWebGLProgram(b,[m,g],m.dtype);p.push(v);const w=Pe({inputs:{x:v},backend:t,attrs:{shape:c.outputShape}});return p.forEach(N=>t.disposeIntermediateTensorInfo(N)),w}const ale={kernelName:jf,backendName:"webgl",kernelFunc:$z};const ole="return float(a > b);",lle=`
  return vec4(greaterThan(a, b));
`,ule=Is({opSnippet:ole,packedOpSnippet:lle,cpuKernelImpl:lse,dtype:"bool"}),cle={kernelName:qf,backendName:"webgl",kernelFunc:ule};const hle="return float(a >= b);",dle=`
  return vec4(greaterThanEqual(a, b));
`,ple=Is({opSnippet:hle,packedOpSnippet:dle,dtype:"bool",cpuKernelImpl:use}),fle={kernelName:Xh,backendName:"webgl",kernelFunc:ple};function mle(n){const{inputs:e,backend:t}=n,{input:s}=e;return kz(s,!0,t)}const gle={kernelName:a0,backendName:"webgl",kernelFunc:mle};const yle="return float(!isnan(x) && !isinf(x));",xle=Mt({opSnippet:yle,dtype:"bool"}),ble={kernelName:Yh,backendName:"webgl",kernelFunc:xle};const vle="return float(isinf(x));",wle=Mt({opSnippet:vle,dtype:"bool"}),Sle={kernelName:Qh,backendName:"webgl",kernelFunc:wle};const Cle="return float(isnan(x));",Nle=Mt({opSnippet:Cle,dtype:"bool"}),kle={kernelName:Zh,backendName:"webgl",kernelFunc:Nle};const $le="return float(a < b);",Ile=`
  return vec4(lessThan(a, b));
`,Tle=Is({opSnippet:$le,packedOpSnippet:Ile,cpuKernelImpl:cse,dtype:"bool"}),Ele={kernelName:Kf,backendName:"webgl",kernelFunc:Tle};const Rle="return float(a <= b);",Ale=`
  return vec4(lessThanEqual(a, b));
`,Dle=Is({opSnippet:Rle,packedOpSnippet:Ale,cpuKernelImpl:hse,dtype:"bool"}),_le={kernelName:Yf,backendName:"webgl",kernelFunc:Dle};function Ole(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=dse(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const Fle={kernelName:l0,backendName:"webgl",kernelFunc:Ole};const zle=zd+`
  return x < 0.0 ? 0./0. : log(x);
`,Lle=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Mle=Mt({opSnippet:zle,packedOpSnippet:Lle,cpuKernelImpl:pse}),Ple={kernelName:Jh,backendName:"webgl",kernelFunc:Mle};const Ble=zd+`
  return log(1.0 + x);
`,Vle=Mt({opSnippet:Ble}),Ule={kernelName:ed,backendName:"webgl",kernelFunc:Vle};const Wle="return float(a >= 1.0 && b >= 1.0);",Gle=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Hle=Is({opSnippet:Wle,packedOpSnippet:Gle,dtype:"bool"}),jle={kernelName:Qf,backendName:"webgl",kernelFunc:Hle};const qle="return float(!(x >= 1.0));",Xle=Mt({opSnippet:qle}),Kle={kernelName:Zf,backendName:"webgl",kernelFunc:Xle};const Yle="return float(a >= 1.0 || b >= 1.0);",Qle=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Zle=Is({opSnippet:Yle,packedOpSnippet:Qle,dtype:"bool"}),Jle={kernelName:Jf,backendName:"webgl",kernelFunc:Zle};let eue=class{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let u;const c=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${c})`:i===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};class tue{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let u;const c=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${c})`:i===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}const nue=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:u}=s,c=fe().getBool("WEBGL_PACK_NORMALIZATION")?new tue(r.shape,i,a,o,u):new eue(r.shape,i,a,o,u);return t.runWebGLProgram(c,[r],r.dtype)},sue={kernelName:em,backendName:"webgl",kernelFunc:nue};let rue=class{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};const iue=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:u,alpha:c,beta:d}=s,p=new rue(r.shape,o,u,c,d);return t.runWebGLProgram(p,[r,i,a],r.dtype)},aue={kernelName:u0,backendName:"webgl",kernelFunc:iue};function oue(n,e,t,s){const r=ce(e),a=ce(n.shape)/r,o=Pe({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Qu(o,n.dtype,"max",s),c=Pe({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),c}function Iz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,u=gt(i,r.shape);let c=u;const d=sn(c,o),p=d!=null,m=t.shouldExecuteOnCPU([r]);let g=r;if(p){if(m){const I=t.texData.get(g.dataId).values,$=new Array(o);for(let F=0;F<$.length;F++)$[F]=r.shape[d[F]];const E=GC(I,r.shape,r.dtype,d,$);g=t.makeTensorInfo($,r.dtype);const D=t.texData.get(g.dataId);D.values=E}else g=Vb(r,d,t);c=mn(c.length,o)}Hn("max",c,o);const[x,b]=Mn(g.shape,c);let v=x;a&&(v=Dn(x,u));let w;if(m){const I=t.texData.get(g.dataId).values,$=fse(I,ce(b),v,r.dtype);w=t.makeTensorInfo(v,r.dtype);const E=t.texData.get(w.dataId);E.values=$}else w=oue(g,b,v,t);return p&&t.disposeIntermediateTensorInfo(g),w}const lue={kernelName:tm,backendName:"webgl",kernelFunc:Iz};const uue=HC+`
  return max(a, b);
`,cue=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Yu+`
  return result;
`,hue=Is({opSnippet:uue,packedOpSnippet:cue,cpuKernelImpl:mse}),due={kernelName:td,backendName:"webgl",kernelFunc:hue};function pue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Xm(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,c=1;B(is(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=zs(r.shape,i,a,c,o,u);if(d.filterWidth===1&&d.filterHeight===1&&xt(d.inShape,d.outShape))return Rr({inputs:{x:r},backend:t});const p=new Sf(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const fue={kernelName:nm,backendName:"webgl",kernelFunc:pue};function mue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:c}=s,d=[1,1,1],p=Qr(r.shape,i,a,d,o,c,u),m=new qC(p,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const gue={kernelName:sm,backendName:"webgl",kernelFunc:mue};let yue=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=i-1-e.padInfo.top,u=a-1-e.padInfo.left,c=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},xue=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,m=c-1-e.padInfo.top,g=d-1-e.padInfo.left,x=u*c*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${x} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function bue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:u,pad:c,dimRoundingMode:d}=s,p=[1,1,1],m=Qr(a.shape,o,u,p,c,d),g=new qC(m,"max",!0),x=t.runWebGLProgram(g,[a],a.dtype),b=new xue(m),v=t.runWebGLProgram(b,[r,x],a.dtype);return t.disposeIntermediateTensorInfo(x),v}const vue={kernelName:h0,backendName:"webgl",kernelFunc:bue};function wue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;Xm([i,a],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=s,m=zs(o.shape,u,c,1,d,p),g=!0,x=new Sf(m,"max",g),b=t.runWebGLProgram(x,[o],o.dtype),v=new yue(m),w=t.runWebGLProgram(v,[r,b],o.dtype);return t.disposeIntermediateTensorInfo(b),w}const Sue={kernelName:c0,backendName:"webgl",kernelFunc:wue};function Cue(n,e,t,s){let r=new Sf(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new Sf(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[i,a]}const Nue={kernelName:d0,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,u=t;B(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];B(is(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=zs(s.shape,r,i,c,a),[p,m]=Cue(s,o,d,u);return[p,m]}};function kue(n,e,t,s){const r=ce(e),a=ce(n.shape)/r,o=Pe({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Qu(o,"float32","mean",s),c=Pe({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),c}const $ue={kernelName:rm,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,a=t,o=s.shape.length,u=gt(i,s.shape);let c=u;const d=sn(c,o),p=d!=null,m=a.shouldExecuteOnCPU([s]),g=[];let x=s;if(p){if(m){const $=a.texData.get(x.dataId).values,E=new Array(o);for(let L=0;L<E.length;L++)E[L]=s.shape[d[L]];const D=GC($,s.shape,s.dtype,d,E);x=a.makeTensorInfo(E,s.dtype);const F=a.texData.get(x.dataId);F.values=D}else x=Vb(s,d,a);g.push(x),c=mn(c.length,o)}Hn("sum",c,o);const[b,v]=Mn(x.shape,c);let w=b;r&&(w=Dn(b,u));const N=kue(x,v,w,a);for(const I of g)a.disposeIntermediateTensorInfo(I);return N}};function Iue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=gt(i,r.shape);let c=u;const d=sn(c,o);let p=r;d!=null&&(p=Ys({inputs:{x:r},backend:t,attrs:{perm:d}}),c=mn(c.length,r.shape.length)),Hn("min",c,o);const[m,g]=Mn(p.shape,c),x=ce(g),b=Pe({inputs:{x:p},backend:t,attrs:{shape:[-1,x]}}),v=Qu(b,b.dtype,"min",t);let w;if(a){const N=Dn(m,u);w=Pe({inputs:{x:v},backend:t,attrs:{shape:N}})}else w=Pe({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),d!=null&&t.disposeIntermediateTensorInfo(p),w}const Tue={kernelName:im,backendName:"webgl",kernelFunc:Iue};const Eue=HC+`
  return min(a, b);
`,Rue=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Yu+`
  return result;
`,Aue=Is({opSnippet:Eue,packedOpSnippet:Rue,cpuKernelImpl:gse}),Due={kernelName:nd,backendName:"webgl",kernelFunc:Aue};let _ue=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,p)=>d[0]+e[p]+d[1]);const r=e.length,i=nn(r),a=t.map(d=>d[0]).join(","),o=t.map((d,p)=>d[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};class Oue{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((x,b)=>x[0]+e[b]+x[1]);const r=e.length,i=nn(r),a=t.map(x=>x[0]).join(","),o=t.map((x,b)=>x[0]+e[b]).join(","),u=qs("rc",r),c=qs("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${c.slice(-2).join()})`,m=s==="reflect"?0:1;let g="";if(r===1){const x=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;g=`
        ${i} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${u[r-1]} += 1;
        if(${d}) {
          ${x}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
      `}else{const x=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;g=`
        ${i} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${u[r-1]} += 1;
        if(${d}) {
          ${x}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${x}
          result[2] = getChannel(getX(${c.join()}), ${p});
          ${u[r-1]} += 1;
          if(${d}) {
            ${x}
            result[3] = getChannel(getX(${c.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}const Fue=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,a=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Oue(s.shape,r,i):new _ue(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)},zue={kernelName:am,backendName:"webgl",kernelFunc:Fue};const Lue=`if (b == 0.0) return NAN;
  return mod(a, b);`,Mue=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Yu+`
  return result;
`,Pue=Is({opSnippet:Lue,packedOpSnippet:Mue}),Bue={kernelName:sd,backendName:"webgl",kernelFunc:Pue};let Vue=class{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};const Uue=`
if (a == b) {
  return 1.0;
};
return a / b;`,Wue=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Tz=Is({opSnippet:Uue,packedOpSnippet:Wue,checkOutOfBounds:!0}),Gue={kernelName:Vh,backendName:"webgl",kernelFunc:Tz};const NE="return a - b;",Ez=Is({opSnippet:NE,packedOpSnippet:NE,supportsComplex:!0,cpuKernelImpl:Lse}),Hue={kernelName:bd,backendName:"webgl",kernelFunc:Ez};function Rz(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=gt([i],r.shape),o=Iz({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=Dn(o.shape,a),c=Pe({inputs:{x:o},backend:t,attrs:{shape:u}}),d=Ez({inputs:{a:r,b:c},backend:t}),p=Nz({inputs:{x:d},backend:t}),m=Ub({inputs:{x:p},backend:t,attrs:{axis:a,keepDims:!1}}),g=Pe({inputs:{x:m},backend:t,attrs:{shape:u}}),x=Tz({inputs:{a:p,b:g},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),x}const jue={kernelName:Nm,backendName:"webgl",kernelFunc:Rz};function que(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,u=o?r:Rz({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=u.shape[0],d=u.shape[1],p=new Vue(c,d,i),m=[[a]],g=t.runWebGLProgram(p,[u],"int32",m);return o||t.disposeIntermediateTensorInfo(u),g}const Xue={kernelName:p0,backendName:"webgl",kernelFunc:que};const Kue=Ei+`
  return -x;
`,Yue=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Que(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[a,o]=xse(i.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}let r;return fe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new nl(s.shape,Yue):r=new ga(s.shape,Kue),t.runWebGLProgram(r,[s],s.dtype)}const Zue={kernelName:om,backendName:"webgl",kernelFunc:Que};const Jue=sb;function ece(n){Hr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s,c=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:p}=Jue(c,d,a,o,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const tce={kernelName:f0,backendName:"webgl",kernelFunc:ece};const nce=QS;function sce(n){Hr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),{selectedIndices:m,validOutputs:g}=nce(d,p,a,o,u,c);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const rce={kernelName:rS,backendName:"webgl",kernelFunc:sce};const ice=rb;function ace(n){Hr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),m=a,g=o,x=u,b=c,{selectedIndices:v,selectedScores:w}=ice(d,p,m,g,x,b);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const oce={kernelName:m0,backendName:"webgl",kernelFunc:ace};let lce=class{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}};const uce=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:u}=s,c=ce(r.shape),d=new lce(c,a,o,u),p=Pe({inputs:{x:r},backend:t,attrs:{shape:[c]}}),m=t.runWebGLProgram(d,[p],i);t.disposeIntermediateTensorInfo(p);const g=[...r.shape,a],x=Pe({inputs:{x:m},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(m),x},cce={kernelName:cm,backendName:"webgl",kernelFunc:uce};function $x(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Ym({inputs:{input:s},backend:t}),i=$x({inputs:{x:r},backend:t}),a=Wb({inputs:{input:s},backend:t}),o=$x({inputs:{x:a},backend:t}),u=El({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return Qm({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const hce={kernelName:Im,backendName:"webgl",kernelFunc:$x};function Az(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Ym({inputs:{input:s},backend:t}),i=Az({inputs:{x:r},backend:t}),a=Wb({inputs:{input:s},backend:t}),o=$x({inputs:{x:a},backend:t}),u=El({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return Qm({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const dce={kernelName:um,backendName:"webgl",kernelFunc:Az};function pce(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return P2({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{pr(i,d.shape,"All tensors passed to stack must have matching shapes"),B(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(d=>{const p=P2({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),c=gz({inputs:u,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const fce={kernelName:hm,backendName:"webgl",kernelFunc:pce};let mce=class{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,d)=>c[0]+e[d]+c[1]);const r=e.length,i=nn(r),a=t.map(c=>c[0]).join(","),o=t.map((c,d)=>c[0]+e[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};class gce{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((b,v)=>b[0]+e[v]+b[1]);const r=e.length,i=nn(r),a=t.map(b=>b[0]).join(","),o=t.map((b,v)=>b[0]+e[v]).join(","),u=qs("rc",r),c=qs("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${c.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${d}) {`],g=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let b=0,v=r===1?2:4;b<v;b++)x+=`
        ${m[b]}
        if (${g}) {
          result[${b}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${b}] = getChannel(getX(${c.join()}), ${p});
        }
      `;x+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${x}
        setOutput(result);
      }
    `}}const Dz=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(ce(r.shape)===0){const c=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return Qm({backend:t,attrs:{shape:c,value:a,dtype:r.dtype}})}const o=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gce(r.shape,i,a):new mce(r.shape,i,a),u=[[a]];return t.runWebGLProgram(o,[r],r.dtype,u)},yce={kernelName:dm,backendName:"webgl",kernelFunc:Dz};const xce=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,bce=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Yu+`
  return result;
`,vce=Is({opSnippet:xce,packedOpSnippet:bce}),wce={kernelName:id,backendName:"webgl",kernelFunc:vce};function Sce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=[],c=gt(i,r.shape);let d=c;const p=sn(d,o);let m=r;p!=null&&(m=Ys({inputs:{x:r},backend:t,attrs:{perm:p}}),d=mn(d.length,o),u.push(m)),Hn("prod",d,o);let g;if(t.shouldExecuteOnCPU([m])){const x=t.texData.get(m.dataId).values,{outVals:b,outShape:v,outDtype:w}=vse(m.shape,m.dtype,x,d);g=t.makeTensorInfo(v,w,b)}else{const[x,b]=Mn(m.shape,d),v=ce(b),w=Pe({inputs:{x:m},backend:t,attrs:{shape:[-1,v]}}),N=O0(r.dtype),I=Qu(w,N,"prod",t);g=Pe({inputs:{x:I},backend:t,attrs:{shape:x}}),u.push(w),u.push(I)}if(a){u.push(g);const x=Dn(g.shape,c);g=Pe({inputs:{x:g},backend:t,attrs:{shape:x}})}return u.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const Cce={kernelName:fm,backendName:"webgl",kernelFunc:Sce};function Nce(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,u=r.map(w=>t.readSync(w.dataId)),c=r.map(w=>w.shape),d=t.readSync(i.dataId),p=t.readSync(a.dataId),[m,g,x]=wse(u,c,d,i.shape,i.dtype,p,a.shape,o),b=m.map(w=>t.makeTensorInfo([w.length],"int32",w)),v=t.makeTensorInfo(x,i.dtype,g);return b.concat([v])}const kce={kernelName:iS,backendName:"webgl",kernelFunc:Nce};function $ce(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.readSync(s.dataId),o=t.readSync(r.dataId),u=t.readSync(i.dataId),[c,d]=Sse(a,s.shape,s.dtype,o,r.shape,u,i.shape),p=t.makeTensorInfo([c.length],"int32",c),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Ice={kernelName:aS,backendName:"webgl",kernelFunc:$ce};function Tce(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:u}=s,c=t.readSync(r.dataId),d=t.readSync(i.dataId),p=t.readSync(a.dataId),m=o.map(v=>t.readSync(v.dataId)),g=o.map(v=>v.shape),[x,b]=Cse(c,r.shape,d,i.shape,i.dtype,p,a.shape,m,g,u);return t.makeTensorInfo(x,i.dtype,b)}const Ece={kernelName:oS,backendName:"webgl",kernelFunc:Tce};const _z=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,o=Nse(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},Rce={kernelName:g0,backendName:"webgl",kernelFunc:_z};const Ace="return 1.0 / x;",Dce=Mt({opSnippet:Ace}),_ce={kernelName:ad,backendName:"webgl",kernelFunc:Dce};const Oce=Ei+`
  return (x < 0.0) ? 0.0 : x;
`,Fce=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zce=Mt({opSnippet:Oce,packedOpSnippet:Fce}),Lce={kernelName:od,backendName:"webgl",kernelFunc:zce};const Mce=Ei+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Pce=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bce=Mt({opSnippet:Mce,packedOpSnippet:Pce}),Vce={kernelName:ld,backendName:"webgl",kernelFunc:Bce};let Uce=class{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,u,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};class Wce{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,u,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function Gce(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,c]=o,d=fe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Wce(r.shape,u,c,i,a):new Uce(r.shape,u,c,i,a);return t.runWebGLProgram(d,[r],"float32")}const Hce={kernelName:ym,backendName:"webgl",kernelFunc:Gce};let jce=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,u=[s&&a>1?r-1:r,s&&o>1?i-1:i],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=u[0]/c[0],p=u[1]/c[1],m=1/d,g=1/p,x=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function qce(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new jce(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const Xce={kernelName:b0,backendName:"webgl",kernelFunc:qce};let Kce=class{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,u,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let g;i?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};class Yce{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,u,c]=e;this.outputShape=[a,t,s,c];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let g;i?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function Qce(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,c]=o,d=fe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Yce(r.shape,u,c,i,a):new Kce(r.shape,u,c,i,a);return t.runWebGLProgram(d,[r],r.dtype)}const Zce={kernelName:gm,backendName:"webgl",kernelFunc:Qce};let Jce=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,u=[s&&a>1?r-1:r,s&&o>1?i-1:i],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=u[0]/c[0],p=u[1]/c[1],m=1/d,g=1/p,x=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function ehe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new Jce(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const the={kernelName:x0,backendName:"webgl",kernelFunc:ehe};let nhe=class{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,i=e.map((o,u)=>r(u)).join(","),a=nn(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};class she{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=qs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=nn(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${a}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(x){return m(x)}function c(x){return x[s-1]="("+x[s-1]+" + 1)",m(x)}function d(x){return x[s-2]="("+x[s-2]+" + 1)",m(x)}function p(x){return x[s-1]="("+x[s-1]+" + 1)",x[s-2]="("+x[s-2]+" + 1)",m(x)}function m(x){const b=e.map((N,I)=>g(I,x)),v=b.join(","),w=b.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${w}))`}function g(x,b){return t.indexOf(x)!==-1&&e[x]!==1?`${e[x]} - ${b[x]} - 1`:`${b[x]}`}}}function rhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length,o=gt(i,r.shape);if(a===0)return Rr({inputs:{x:r},backend:t});const u=fe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new she(r.shape,o):new nhe(r.shape,o);return t.runWebGLProgram(u,[r],r.dtype)}const ihe={kernelName:xm,backendName:"webgl",kernelFunc:rhe};let ahe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};const ohe={kernelName:D0,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,u=new ahe(s.shape,i),[c,d]=hb(a,s.shape[1],s.shape[2]),p=[[c,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[s],s.dtype,p)}};const lhe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,uhe=Mt({opSnippet:lhe}),che={kernelName:ud,backendName:"webgl",kernelFunc:uhe};const hhe="return inversesqrt(x);",dhe=Mt({opSnippet:hhe,cpuKernelImpl:kse}),phe={kernelName:cd,backendName:"webgl",kernelFunc:dhe};let XC=class{constructor(e,t,s,r,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const c=nn(i.length),d=nn(a.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let b="";u&&(b="coords[0], coords[1]");const v=`getDefaultValue(${b})`,w=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${w};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${x};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}};class fhe{constructor(e,t,s,r,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const c=nn(i.length),d=nn(a.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let g="";r===1?g="i":r===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let b="";u&&(b="coords[0], coords[1]");const v=`getDefaultValue(${b})`,w=t>1?"strides[j]":"strides",N=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${w};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${N};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${x};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}}function mhe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Ta(i,r,a),m=[p/c,c];if(p===0)return t.makeTensorInfo(a,r.dtype);const g=Pe({inputs:{x:r},backend:t,attrs:{shape:[u,o]}}),x=Pe({inputs:{x:i},backend:t,attrs:{shape:[u,c]}}),b=t.makeTensorInfo([],"float32",new Float32Array([0]));let v;fe().getBool("WEBGL_PACK")?v=new fhe(u,o,g.shape.length,x.shape.length,d,m):v=new XC(u,o,g.shape.length,x.shape.length,d,m);const w=t.runWebGLProgram(v,[x,g,b],x.dtype),N=Pe({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(b),N}const ghe={kernelName:v0,backendName:"webgl",kernelFunc:mhe};let yhe=class{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=fe().getNumber("WEBGL_VERSION")===2?i:a,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function xhe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=new yhe(r.shape[0],r.shape[1],i.shape[1],a),u=[[r.shape[1]]];return t.runWebGLProgram(o,[r,i],"int32",u)}const bhe={kernelName:S0,backendName:"webgl",kernelFunc:xhe};let vhe=class{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let d=0;d<t.length;d++)c.push(`${o[d]}`),d<e&&u.push(`${o[d]}`);r=u.join(),i=c.join()}const a=nn(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};function whe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new vhe(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,i],ys(r.dtype,i.dtype))}const She={kernelName:bm,backendName:"webgl",kernelFunc:whe};const Che=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${zm};
  float scale = ${Lm};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Nhe=Mt({opSnippet:Che}),khe={kernelName:hd,backendName:"webgl",kernelFunc:Nhe};const $he=zd+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Ihe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,The=Mt({opSnippet:$he,packedOpSnippet:Ihe,cpuKernelImpl:Ise}),Ehe={kernelName:md,backendName:"webgl",kernelFunc:The};const Rhe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ahe=Mt({opSnippet:Rhe}),Dhe={kernelName:fd,backendName:"webgl",kernelFunc:Ahe};const _he=zd+`
  return sin(x);
`,Ohe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Yu}
  return result;
`,Fhe=Mt({opSnippet:_he,packedOpSnippet:Ohe}),zhe={kernelName:dd,backendName:"webgl",kernelFunc:Fhe};const Lhe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Mhe=Mt({opSnippet:Lhe}),Phe={kernelName:pd,backendName:"webgl",kernelFunc:Mhe};const Bhe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Vhe=Mt({opSnippet:Bhe}),Uhe={kernelName:gd,backendName:"webgl",kernelFunc:Vhe};const Whe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;B(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((w,N)=>w*N),u=[[0,0]];u.push(...a);for(let w=1+i.length;w<r.shape.length;++w)u.push([0,0]);const c=[],d=Dz({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),p=Wu(d.shape,i,o,!1),m=Gu(p.length,i.length,!1),g=Hu(d.shape,i,o,!1),x=Pe({inputs:{x:d},backend:t,attrs:{shape:p}}),b=Ys({inputs:{x},backend:t,attrs:{perm:m}}),v=Pe({inputs:{x:b},backend:t,attrs:{shape:g}});return c.push(d),c.push(x),c.push(b),c.forEach(w=>t.disposeIntermediateTensorInfo(w)),v},Ghe={kernelName:Sm,backendName:"webgl",kernelFunc:Whe};function Hhe(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(s.dataId),u=t.readSync(r.dataId),c=t.readSync(i.dataId),d=t.readSync(a.dataId)[0],[p,m,g,x,b]=Ese(o,s.shape,s.dtype,u,r.dtype,c,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(v=>Number(v)))),t.makeTensorInfo([b.length],s.dtype,new Int32Array(b))]}const jhe={kernelName:lS,backendName:"webgl",kernelFunc:Hhe};function qhe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.readSync(r.dataId)),o=t.readSync(s.dataId),u=Array.from(t.readSync(i.dataId)),[c,d,p]=Rse(o,s.shape,s.dtype,a,u);return[t.makeTensorInfo(d,s.dtype,c),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const Xhe={kernelName:uS,backendName:"webgl",kernelFunc:qhe};function Khe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),u=t.readSync(i.dataId),[c,d]=sz(a,s.shape,s.dtype,o,u,!0);return t.makeTensorInfo(d,s.dtype,c)}const Yhe={kernelName:C0,backendName:"webgl",kernelFunc:Khe};function Qhe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),u=t.readSync(i.dataId),[c,d]=sz(a,s.shape,s.dtype,o,u);return t.makeTensorInfo(d,s.dtype,c)}const Zhe={kernelName:N0,backendName:"webgl",kernelFunc:Qhe};function Jhe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:m}=Ta(i,r,o),g=!1;if(i.dtype==="string"){const w=t.bufferSync(r),N=t.bufferSync(i),I=Hi(t.readSync(a.dataId)[0]),$=$se(w,N,o,m,d,c,u,p,I,g);return t.makeTensorInfo(o,$.dtype,$.values)}const x=new XC(c,u,r.shape.length,i.shape.length,p,[m,1],g),b=t.runWebGLProgram(x,[i,r,a],i.dtype),v=Pe({inputs:{x:b},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(b),v}const ede={kernelName:k0,backendName:"webgl",kernelFunc:Jhe};function tde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=gt(a,r.shape)[0],u=kb(r,i,o),c=r.shape.length,d=new Array(c).fill(0),p=r.shape.slice();return u.map(m=>{const g=[...p];g[o]=m;const x=Ld({inputs:{x:r},backend:t,attrs:{begin:d,size:g}});return d[o]+=m,x})}const nde={kernelName:Cm,backendName:"webgl",kernelFunc:tde};const kE="return sqrt(x);",sde=Mt({opSnippet:kE,packedOpSnippet:kE,cpuKernelImpl:Ase}),rde={kernelName:yd,backendName:"webgl",kernelFunc:sde};const ide="return x * x;",ade=Mt({opSnippet:ide}),ode={kernelName:$0,backendName:"webgl",kernelFunc:ade};const $E="return (a - b) * (a - b);",lde=Is({opSnippet:$E,packedOpSnippet:$E}),ude={kernelName:xd,backendName:"webgl",kernelFunc:lde};function cde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),a=Ki(i),o=Dse(a,"string",s);return t.makeTensorInfo(r.shape,"string",o)}const hde={kernelName:I0,backendName:"webgl",kernelFunc:cde};function dde({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Ei+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new ga(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const pde={kernelName:Cd,backendName:"webgl",kernelFunc:dde};let fde=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=nn(s.length),a=nn(s.length);let o="";if(r===1)o="coords * strides + begin";else{let u=0;o=s.map((c,d)=>(u++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};function mde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:g,finalShape:x,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:N,end:I,strides:$}=lb(r.shape,i,a,o,u,c,d,p,m);let E;if(b)E=Pe({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||w){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const F=ob(N,I,$),L=Ld({inputs:{x:r},backend:t,attrs:{begin:N,size:F}});E=Pe({inputs:{x:L},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(L)}else if(t.shouldExecuteOnCPU([r])){const L=t.readSync(r.dataId),z=ft(r.shape,r.dtype,L),M=_se(g,z,$,N);E=t.makeTensorInfo(x,r.dtype,M.values)}else{const L=new fde(N,$,g);E=t.runWebGLProgram(L,[r],r.dtype)}const D=Pe({inputs:{x:E},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(E),D}const gde={kernelName:T0,backendName:"webgl",kernelFunc:mde};function yde(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:c}=s,{data:d,dataSplits:p}=e,m=t.readSync(d.dataId),g=t.readSync(p.dataId),[x,b]=Ose(m,g,r,i,a,o,u,c);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(p.shape,"int32",b)]}const xde={kernelName:E0,backendName:"webgl",kernelFunc:yde};function bde(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(i.dataId),u=t.readSync(a.dataId)[0],[c,d,p]=Fse(o,u,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",c),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const vde={kernelName:cS,backendName:"webgl",kernelFunc:bde};function wde(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(i.dataId),o=zse(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const Sde={kernelName:hS,backendName:"webgl",kernelFunc:wde};const Cde="return tan(x);",Nde=Mt({opSnippet:Cde}),kde={kernelName:vd,backendName:"webgl",kernelFunc:Nde};const $de=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Ide=Mt({opSnippet:$de}),Tde={kernelName:wd,backendName:"webgl",kernelFunc:Ide};function Ede(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Ta(a,i,r.shape),m=[p/c,c];if(p===0)return t.makeTensorInfo(r.shape,i.dtype);const g=Pe({inputs:{x:i},backend:t,attrs:{shape:[u,o]}}),x=Pe({inputs:{x:a},backend:t,attrs:{shape:[u,c]}}),b=Pe({inputs:{x:r},backend:t,attrs:{shape:m}}),v=new XC(u,o,g.shape.length,x.shape.length,d,m,!1,!0),w=t.runWebGLProgram(v,[x,g,b],b.dtype),N=Pe({inputs:{x:w},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),N}const Rde={kernelName:w0,backendName:"webgl",kernelFunc:Ede};let Ade=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=nn(this.rank),i=Dde(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function Dde(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function Oz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),c=r.dtype==="string"?u.map(m=>Hi(m)):u,d=ft(r.shape,r.dtype,c),p=Mse(d,i);return t.makeTensorInfo(p.shape,p.dtype,p.values)}const a=new Ade(r.shape,i);return t.runWebGLProgram(a,[r],r.dtype)}const _de={kernelName:Sd,backendName:"webgl",kernelFunc:Oz};let Ode=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Fde=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function au(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function IE(n){let e=1;for(;e<n;)e*=2;return e}function zde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,o=fe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=fe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,d=c[c.length-1];if(t.shouldExecuteOnCPU([r])||d<o||i>u){const M=t.readSync(r.dataId),[O,H]=Pse(M,c,r.dtype,i,a);return[t.makeTensorInfo(O.shape,O.dtype,O.values),t.makeTensorInfo(H.shape,H.dtype,H.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(d===1)return[r,Qm({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const p=t.texData.get(r.dataId),m=p!==null&&p.isPacked,g=m?t.unpackTensor(r):r,b=ce(c)/d,v=Pe({inputs:{x:g},attrs:{shape:[b,d]},backend:t});m&&au(t,g);const w=IE(i),N=IE(d);let I=null;const $=()=>I===null?[v,v]:[v,I],E=(M,O,H)=>{const X=$(),te=new Ode(H),W=[[d],[I===null?1:0],[Number.NEGATIVE_INFINITY],[M],[O]],ee=I;I=t.runWebGLProgram(te,X,"int32",W),au(t,ee)};for(let M=1;M<w;M*=2){const O=M*2;for(let H=M;H>=1;H/=2)E(O,H,[b,N])}for(let M=N;M>w;M/=2){const O=$(),H=new Fde([b,M/2]),te=[[d],[I===null?1:0],[w]],Z=I;I=t.runWebGLProgram(H,O,"int32",te),au(t,Z);const W=w/2,ee=W*2;for(let ie=W;ie>=1;ie/=2)E(ee,ie,I.shape)}let D=I;I=Ld({inputs:{x:I},backend:t,attrs:{begin:0,size:[b,i]}}),au(t,D);let F=$z({inputs:{x:v,indices:I},backend:t,attrs:{axis:1,batchDims:1}});au(t,v);const L=c.slice(0,-1);L.push(i),D=I,I=Pe({inputs:{x:I},attrs:{shape:L},backend:t}),au(t,D);const z=F;return F=Pe({inputs:{x:F},attrs:{shape:L},backend:t}),au(t,z),[F,I]}const Lde={kernelName:R0,backendName:"webgl",kernelFunc:zde};let Mde=class{constructor(e,t,s,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Pde(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:u,outputShape:c}=s,[d,p,m,g]=r.shape,[x,b]=c??[p,m],v=[d,x,b,g],w=new Mde(p,m,a,o,u,v);return t.runWebGLProgram(w,[r,i],"float32")}const Bde={kernelName:A0,backendName:"webgl",kernelFunc:Pde};function Vde(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Xm(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:u,indices:c}=Bse(a,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const Ude={kernelName:dS,backendName:"webgl",kernelFunc:Vde};function Wde(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,u=r.shape[i],c=new Array(o-1);let d=0;for(let b=0;b<o;b++)b!==i&&(c[d++]=a.shape[b]);const p=[],m=new Array(o).fill(0),g=a.shape.slice();g[i]=1;const x=new Array(u);for(let b=0;b<x.length;b++){m[i]=b;const v=Ld({inputs:{x:a},backend:t,attrs:{begin:m,size:g}}),w=Pe({inputs:{x:v},backend:t,attrs:{shape:c}});x[b]=w,p.push(v)}return p.forEach(b=>t.disposeIntermediateTensorInfo(b)),x}const Gde={kernelName:km,backendName:"webgl",kernelFunc:Wde};class Hde{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,o=a*Math.ceil(i/s);this.outputShape=[r,o];const u="0.0",c="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let g="";i%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${x}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${c});
      }
    `}}function jde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,u=[];let c=0;const d=sn([c],o);let p=r;d!=null&&(p=Ys({inputs:{x:r},backend:t,attrs:{perm:d}}),u.push(p),c=mn(1,o)[0]);const m=oC(p.shape,c,a),g=ce([p.shape[c]]),x=Pe({inputs:{x:p},backend:t,attrs:{shape:[-1,g]}});u.push(x);const b=O0(r.dtype),v=($,E,D,F,L)=>{const z=$.shape[0],M=$.shape[1],O=hD(M,L),H={windowSize:O,inSize:M,batchSize:z,numSegments:L},X=new Hde(H,E),te=t.compileAndRun(X,[$,D],F);if(u.push(te),te.shape[1]===L)return te;const Z=_z({backend:t,attrs:{start:0,stop:L,step:1,dtype:"float32"}}),W=Oz({inputs:{x:Z},backend:t,attrs:{reps:[M/O]}});return u.push(Z),u.push(W),v(te,E,W,F,L)},w=v(x,"unsortedSegmentSum",i,b,a),N=Pe({inputs:{x:w},backend:t,attrs:{shape:m}});let I=N;if(d!=null){u.push(N);const $=$a(d);I=Ys({inputs:{x:I},backend:t,attrs:{perm:$}})}return u.forEach($=>t.disposeIntermediateTensorInfo($)),I}const qde={kernelName:$m,backendName:"webgl",kernelFunc:jde};const Xde=[Are,_re,zre,Pre,Vre,Gre,jre,Xre,Zre,eie,sie,aie,uie,pie,gie,xie,vie,Nie,$ie,Tie,Die,Pie,Vie,Hie,qie,Jie,tae,iae,fre,lae,pae,yae,Cae,$ae,Tae,Rae,Dae,zae,Pae,Uae,Gae,jae,Xae,Qae,Jae,soe,ioe,loe,hoe,poe,yoe,woe,koe,Toe,Aoe,Doe,Ooe,zoe,Moe,Boe,Uoe,joe,Koe,Zoe,ele,sle,ale,cle,fle,pre,gle,hae,ble,Sle,kle,gre,Ele,_le,Fle,Ple,Ule,jle,Kle,Jle,sue,aue,lue,due,fue,gue,vue,Sue,Nue,$ue,Tue,Due,zue,Bue,Xue,bre,Zue,tce,rce,oce,Kie,cce,dce,fce,yce,wce,xre,Cce,kce,Ice,Ece,Rce,Yie,Gue,_ce,Lce,Vce,wre,Hce,Xce,Zce,the,ihe,ohe,che,phe,ghe,bhe,She,khe,Ehe,Dhe,zhe,Phe,Lie,jue,Uhe,Ghe,jhe,Xhe,Yhe,Zhe,ede,nde,rde,ode,ude,hde,pde,gde,xde,vde,Sde,Hue,Tre,kde,Tde,Rde,_de,Lde,Bde,Ere,Ude,Gde,qde,hce];for(const n of Xde)pS(n);var Rw={},TE;function Kde(){return TE||(TE=1,(function(){var n;function e(C){var T=0;return function(){return T<C.length?{done:!1,value:C[T++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(C,T,A){return C==Array.prototype||C==Object.prototype||(C[T]=A.value),C};function s(C){C=[typeof globalThis=="object"&&globalThis,C,typeof window=="object"&&window,typeof self=="object"&&self,typeof pI=="object"&&pI];for(var T=0;T<C.length;++T){var A=C[T];if(A&&A.Math==Math)return A}throw Error("Cannot find global object")}var r=s(this);function i(C,T){if(T)e:{var A=r;C=C.split(".");for(var P=0;P<C.length-1;P++){var j=C[P];if(!(j in A))break e;A=A[j]}C=C[C.length-1],P=A[C],T=T(P),T!=P&&T!=null&&t(A,C,{configurable:!0,writable:!0,value:T})}}i("Symbol",function(C){function T(Y){if(this instanceof T)throw new TypeError("Symbol is not a constructor");return new A(P+(Y||"")+"_"+j++,Y)}function A(Y,K){this.h=Y,t(this,"description",{configurable:!0,writable:!0,value:K})}if(C)return C;A.prototype.toString=function(){return this.h};var P="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",j=0;return T}),i("Symbol.iterator",function(C){if(C)return C;C=Symbol("Symbol.iterator");for(var T="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),A=0;A<T.length;A++){var P=r[T[A]];typeof P=="function"&&typeof P.prototype[C]!="function"&&t(P.prototype,C,{configurable:!0,writable:!0,value:function(){return a(e(this))}})}return C});function a(C){return C={next:C},C[Symbol.iterator]=function(){return this},C}function o(C){var T=typeof Symbol<"u"&&Symbol.iterator&&C[Symbol.iterator];return T?T.call(C):{next:e(C)}}function u(C){if(!(C instanceof Array)){C=o(C);for(var T,A=[];!(T=C.next()).done;)A.push(T.value);C=A}return C}var c=typeof Object.assign=="function"?Object.assign:function(C,T){for(var A=1;A<arguments.length;A++){var P=arguments[A];if(P)for(var j in P)Object.prototype.hasOwnProperty.call(P,j)&&(C[j]=P[j])}return C};i("Object.assign",function(C){return C||c});var d=typeof Object.create=="function"?Object.create:function(C){function T(){}return T.prototype=C,new T},p;if(typeof Object.setPrototypeOf=="function")p=Object.setPrototypeOf;else{var m;e:{var g={a:!0},x={};try{x.__proto__=g,m=x.a;break e}catch{}m=!1}p=m?function(C,T){if(C.__proto__=T,C.__proto__!==T)throw new TypeError(C+" is not extensible");return C}:null}var b=p;function v(C,T){if(C.prototype=d(T.prototype),C.prototype.constructor=C,b)b(C,T);else for(var A in T)if(A!="prototype")if(Object.defineProperties){var P=Object.getOwnPropertyDescriptor(T,A);P&&Object.defineProperty(C,A,P)}else C[A]=T[A];C.za=T.prototype}function w(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function N(C){if(C.m)throw new TypeError("Generator is already running");C.m=!0}w.prototype.u=function(C){this.i=C};function I(C,T){C.l={ma:T,na:!0},C.h=C.s||C.v}w.prototype.return=function(C){this.l={return:C},this.h=this.v};function $(C,T,A){return C.h=A,{value:T}}function E(C){this.h=new w,this.i=C}function D(C,T){N(C.h);var A=C.h.j;return A?F(C,"return"in A?A.return:function(P){return{value:P,done:!0}},T,C.h.return):(C.h.return(T),L(C))}function F(C,T,A,P){try{var j=T.call(C.h.j,A);if(!(j instanceof Object))throw new TypeError("Iterator result "+j+" is not an object");if(!j.done)return C.h.m=!1,j;var Y=j.value}catch(K){return C.h.j=null,I(C.h,K),L(C)}return C.h.j=null,P.call(C.h,Y),L(C)}function L(C){for(;C.h.h;)try{var T=C.i(C.h);if(T)return C.h.m=!1,{value:T.value,done:!1}}catch(A){C.h.i=void 0,I(C.h,A)}if(C.h.m=!1,C.h.l){if(T=C.h.l,C.h.l=null,T.na)throw T.ma;return{value:T.return,done:!0}}return{value:void 0,done:!0}}function z(C){this.next=function(T){return N(C.h),C.h.j?T=F(C,C.h.j.next,T,C.h.u):(C.h.u(T),T=L(C)),T},this.throw=function(T){return N(C.h),C.h.j?T=F(C,C.h.j.throw,T,C.h.u):(I(C.h,T),T=L(C)),T},this.return=function(T){return D(C,T)},this[Symbol.iterator]=function(){return this}}function M(C){function T(P){return C.next(P)}function A(P){return C.throw(P)}return new Promise(function(P,j){function Y(K){K.done?P(K.value):Promise.resolve(K.value).then(T,A).then(Y,j)}Y(C.next())})}function O(C){return M(new z(new E(C)))}i("Promise",function(C){function T(K){this.i=0,this.j=void 0,this.h=[],this.u=!1;var ue=this.l();try{K(ue.resolve,ue.reject)}catch(we){ue.reject(we)}}function A(){this.h=null}function P(K){return K instanceof T?K:new T(function(ue){ue(K)})}if(C)return C;A.prototype.i=function(K){if(this.h==null){this.h=[];var ue=this;this.j(function(){ue.m()})}this.h.push(K)};var j=r.setTimeout;A.prototype.j=function(K){j(K,0)},A.prototype.m=function(){for(;this.h&&this.h.length;){var K=this.h;this.h=[];for(var ue=0;ue<K.length;++ue){var we=K[ue];K[ue]=null;try{we()}catch(De){this.l(De)}}}this.h=null},A.prototype.l=function(K){this.j(function(){throw K})},T.prototype.l=function(){function K(De){return function(Me){we||(we=!0,De.call(ue,Me))}}var ue=this,we=!1;return{resolve:K(this.I),reject:K(this.m)}},T.prototype.I=function(K){if(K===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(K instanceof T)this.L(K);else{e:switch(typeof K){case"object":var ue=K!=null;break e;case"function":ue=!0;break e;default:ue=!1}ue?this.F(K):this.s(K)}},T.prototype.F=function(K){var ue=void 0;try{ue=K.then}catch(we){this.m(we);return}typeof ue=="function"?this.M(ue,K):this.s(K)},T.prototype.m=function(K){this.v(2,K)},T.prototype.s=function(K){this.v(1,K)},T.prototype.v=function(K,ue){if(this.i!=0)throw Error("Cannot settle("+K+", "+ue+"): Promise already settled in state"+this.i);this.i=K,this.j=ue,this.i===2&&this.K(),this.H()},T.prototype.K=function(){var K=this;j(function(){if(K.D()){var ue=r.console;typeof ue<"u"&&ue.error(K.j)}},1)},T.prototype.D=function(){if(this.u)return!1;var K=r.CustomEvent,ue=r.Event,we=r.dispatchEvent;return typeof we>"u"?!0:(typeof K=="function"?K=new K("unhandledrejection",{cancelable:!0}):typeof ue=="function"?K=new ue("unhandledrejection",{cancelable:!0}):(K=r.document.createEvent("CustomEvent"),K.initCustomEvent("unhandledrejection",!1,!0,K)),K.promise=this,K.reason=this.j,we(K))},T.prototype.H=function(){if(this.h!=null){for(var K=0;K<this.h.length;++K)Y.i(this.h[K]);this.h=null}};var Y=new A;return T.prototype.L=function(K){var ue=this.l();K.T(ue.resolve,ue.reject)},T.prototype.M=function(K,ue){var we=this.l();try{K.call(ue,we.resolve,we.reject)}catch(De){we.reject(De)}},T.prototype.then=function(K,ue){function we(tt,Ge){return typeof tt=="function"?function(ct){try{De(tt(ct))}catch(bt){Me(bt)}}:Ge}var De,Me,nt=new T(function(tt,Ge){De=tt,Me=Ge});return this.T(we(K,De),we(ue,Me)),nt},T.prototype.catch=function(K){return this.then(void 0,K)},T.prototype.T=function(K,ue){function we(){switch(De.i){case 1:K(De.j);break;case 2:ue(De.j);break;default:throw Error("Unexpected state: "+De.i)}}var De=this;this.h==null?Y.i(we):this.h.push(we),this.u=!0},T.resolve=P,T.reject=function(K){return new T(function(ue,we){we(K)})},T.race=function(K){return new T(function(ue,we){for(var De=o(K),Me=De.next();!Me.done;Me=De.next())P(Me.value).T(ue,we)})},T.all=function(K){var ue=o(K),we=ue.next();return we.done?P([]):new T(function(De,Me){function nt(ct){return function(bt){tt[ct]=bt,Ge--,Ge==0&&De(tt)}}var tt=[],Ge=0;do tt.push(void 0),Ge++,P(we.value).T(nt(tt.length-1),Me),we=ue.next();while(!we.done)})},T});function H(C,T){C instanceof String&&(C+="");var A=0,P=!1,j={next:function(){if(!P&&A<C.length){var Y=A++;return{value:T(Y,C[Y]),done:!1}}return P=!0,{done:!0,value:void 0}}};return j[Symbol.iterator]=function(){return j},j}i("Array.prototype.keys",function(C){return C||function(){return H(this,function(T){return T})}}),i("Array.prototype.fill",function(C){return C||function(T,A,P){var j=this.length||0;for(0>A&&(A=Math.max(0,j+A)),(P==null||P>j)&&(P=j),P=Number(P),0>P&&(P=Math.max(0,j+P)),A=Number(A||0);A<P;A++)this[A]=T;return this}});function X(C){return C||Array.prototype.fill}i("Int8Array.prototype.fill",X),i("Uint8Array.prototype.fill",X),i("Uint8ClampedArray.prototype.fill",X),i("Int16Array.prototype.fill",X),i("Uint16Array.prototype.fill",X),i("Int32Array.prototype.fill",X),i("Uint32Array.prototype.fill",X),i("Float32Array.prototype.fill",X),i("Float64Array.prototype.fill",X),i("Object.is",function(C){return C||function(T,A){return T===A?T!==0||1/T===1/A:T!==T&&A!==A}}),i("Array.prototype.includes",function(C){return C||function(T,A){var P=this;P instanceof String&&(P=String(P));var j=P.length;for(A=A||0,0>A&&(A=Math.max(A+j,0));A<j;A++){var Y=P[A];if(Y===T||Object.is(Y,T))return!0}return!1}}),i("String.prototype.includes",function(C){return C||function(T,A){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(T instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(T,A||0)!==-1}});var te=this||self;function Z(C,T){C=C.split(".");var A=te;C[0]in A||typeof A.execScript>"u"||A.execScript("var "+C[0]);for(var P;C.length&&(P=C.shift());)C.length||T===void 0?A[P]&&A[P]!==Object.prototype[P]?A=A[P]:A=A[P]={}:A[P]=T}function W(C){var T;e:{if((T=te.navigator)&&(T=T.userAgent))break e;T=""}return T.indexOf(C)!=-1}var ee=Array.prototype.map?function(C,T){return Array.prototype.map.call(C,T,void 0)}:function(C,T){for(var A=C.length,P=Array(A),j=typeof C=="string"?C.split(""):C,Y=0;Y<A;Y++)Y in j&&(P[Y]=T.call(void 0,j[Y],Y,C));return P},ie={},de=null;function ge(C){var T=C.length,A=3*T/4;A%3?A=Math.floor(A):"=.".indexOf(C[T-1])!=-1&&(A="=.".indexOf(C[T-2])!=-1?A-2:A-1);var P=new Uint8Array(A),j=0;return G(C,function(Y){P[j++]=Y}),j!==A?P.subarray(0,j):P}function G(C,T){function A(we){for(;P<C.length;){var De=C.charAt(P++),Me=de[De];if(Me!=null)return Me;if(!/^[\s\xa0]*$/.test(De))throw Error("Unknown base64 encoding at char: "+De)}return we}re();for(var P=0;;){var j=A(-1),Y=A(0),K=A(64),ue=A(64);if(ue===64&&j===-1)break;T(j<<2|Y>>4),K!=64&&(T(Y<<4&240|K>>2),ue!=64&&T(K<<6&192|ue))}}function re(){if(!de){de={};for(var C="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),T=["+/=","+/","-_=","-_.","-_"],A=0;5>A;A++){var P=C.concat(T[A].split(""));ie[A]=P;for(var j=0;j<P.length;j++){var Y=P[j];de[Y]===void 0&&(de[Y]=j)}}}}var pe=typeof Uint8Array<"u",ve=!(W("Trident")||W("MSIE"))&&typeof te.btoa=="function";function Ne(C){if(!ve){var T;T===void 0&&(T=0),re(),T=ie[T];for(var A=Array(Math.floor(C.length/3)),P=T[64]||"",j=0,Y=0;j<C.length-2;j+=3){var K=C[j],ue=C[j+1],we=C[j+2],De=T[K>>2];K=T[(K&3)<<4|ue>>4],ue=T[(ue&15)<<2|we>>6],we=T[we&63],A[Y++]=De+K+ue+we}switch(De=0,we=P,C.length-j){case 2:De=C[j+1],we=T[(De&15)<<2]||P;case 1:C=C[j],A[Y]=T[C>>2]+T[(C&3)<<4|De>>4]+we+P}return A.join("")}for(T="";10240<C.length;)T+=String.fromCharCode.apply(null,C.subarray(0,10240)),C=C.subarray(10240);return T+=String.fromCharCode.apply(null,C),btoa(T)}var Ee=RegExp("[-_.]","g");function _e(C){switch(C){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function je(C){if(!ve)return ge(C);Ee.test(C)&&(C=C.replace(Ee,_e)),C=atob(C);for(var T=new Uint8Array(C.length),A=0;A<C.length;A++)T[A]=C.charCodeAt(A);return T}var Be;function at(){return Be||(Be=new Uint8Array(0))}var ot={},Tt=typeof Uint8Array.prototype.slice=="function",ut=0,mt=0;function Bt(C){var T=0>C;C=Math.abs(C);var A=C>>>0;C=Math.floor((C-A)/4294967296),T&&(A=o(Zt(A,C)),T=A.next().value,C=A.next().value,A=T),ut=A>>>0,mt=C>>>0}var Ft=typeof BigInt=="function";function Zt(C,T){return T=~T,C?C=~C+1:T+=1,[C,T]}function qt(C,T){this.i=C>>>0,this.h=T>>>0}function Ps(C){if(!C)return yn||(yn=new qt(0,0));if(!/^-?\d+$/.test(C))return null;if(16>C.length)Bt(Number(C));else if(Ft)C=BigInt(C),ut=Number(C&BigInt(4294967295))>>>0,mt=Number(C>>BigInt(32)&BigInt(4294967295));else{var T=+(C[0]==="-");mt=ut=0;for(var A=C.length,P=T,j=(A-T)%6+T;j<=A;P=j,j+=6)P=Number(C.slice(P,j)),mt*=1e6,ut=1e6*ut+P,4294967296<=ut&&(mt+=ut/4294967296|0,ut%=4294967296);T&&(T=o(Zt(ut,mt)),C=T.next().value,T=T.next().value,ut=C,mt=T)}return new qt(ut,mt)}var yn;function Js(C,T){return Error("Invalid wire type: "+C+" (at position "+T+")")}function os(){return Error("Failed to read varint, encoding is invalid.")}function ei(C,T){return Error("Tried to read past the end of the data "+T+" > "+C)}function Ut(){throw Error("Invalid UTF8")}function fr(C,T){return T=String.fromCharCode.apply(null,T),C==null?T:C+T}var Bs=void 0,er,tr=typeof TextDecoder<"u",na,yo=typeof TextEncoder<"u",xo;function tc(C){if(C!==ot)throw Error("illegal external caller")}function Vs(C,T){if(tc(T),this.V=C,C!=null&&C.length===0)throw Error("ByteString should be constructed with non-empty values")}function ls(){return xo||(xo=new Vs(null,ot))}function Or(C){tc(ot);var T=C.V;return T=T==null||pe&&T!=null&&T instanceof Uint8Array?T:typeof T=="string"?je(T):null,T==null?T:C.V=T}function nr(C){if(typeof C=="string")return{buffer:je(C),C:!1};if(Array.isArray(C))return{buffer:new Uint8Array(C),C:!1};if(C.constructor===Uint8Array)return{buffer:C,C:!1};if(C.constructor===ArrayBuffer)return{buffer:new Uint8Array(C),C:!1};if(C.constructor===Vs)return{buffer:Or(C)||at(),C:!0};if(C instanceof Uint8Array)return{buffer:new Uint8Array(C.buffer,C.byteOffset,C.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Jm(C,T){this.i=null,this.m=!1,this.h=this.j=this.l=0,Vd(this,C,T)}function Vd(C,T,A){A=A===void 0?{}:A,C.S=A.S===void 0?!1:A.S,T&&(T=nr(T),C.i=T.buffer,C.m=T.C,C.l=0,C.j=C.i.length,C.h=C.l)}Jm.prototype.reset=function(){this.h=this.l};function Ra(C,T){if(C.h=T,T>C.j)throw ei(C.j,T)}function sa(C){var T=C.i,A=C.h,P=T[A++],j=P&127;if(P&128&&(P=T[A++],j|=(P&127)<<7,P&128&&(P=T[A++],j|=(P&127)<<14,P&128&&(P=T[A++],j|=(P&127)<<21,P&128&&(P=T[A++],j|=P<<28,P&128&&T[A++]&128&&T[A++]&128&&T[A++]&128&&T[A++]&128&&T[A++]&128)))))throw os();return Ra(C,A),j}function Al(C,T){if(0>T)throw Error("Tried to read a negative byte length: "+T);var A=C.h,P=A+T;if(P>C.j)throw ei(T,C.j-A);return C.h=P,A}var Dl=[];function Ri(){this.h=[]}Ri.prototype.length=function(){return this.h.length},Ri.prototype.end=function(){var C=this.h;return this.h=[],C};function _l(C,T,A){for(;0<A||127<T;)C.h.push(T&127|128),T=(T>>>7|A<<25)>>>0,A>>>=7;C.h.push(T)}function Fr(C,T){for(;127<T;)C.h.push(T&127|128),T>>>=7;C.h.push(T)}function Ud(C,T){if(Dl.length){var A=Dl.pop();Vd(A,C,T),C=A}else C=new Jm(C,T);this.h=C,this.j=this.h.h,this.i=this.l=-1,this.setOptions(T)}Ud.prototype.setOptions=function(C){C=C===void 0?{}:C,this.ca=C.ca===void 0?!1:C.ca},Ud.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Wd(C){var T=C.h;if(T.h==T.j)return!1;C.j=C.h.h;var A=sa(C.h)>>>0;if(T=A>>>3,A&=7,!(0<=A&&5>=A))throw Js(A,C.j);if(1>T)throw Error("Invalid field number: "+T+" (at position "+C.j+")");return C.l=T,C.i=A,!0}function bo(C){switch(C.i){case 0:if(C.i!=0)bo(C);else e:{C=C.h;for(var T=C.h,A=T+10,P=C.i;T<A;)if((P[T++]&128)===0){Ra(C,T);break e}throw os()}break;case 1:C=C.h,Ra(C,C.h+8);break;case 2:C.i!=2?bo(C):(T=sa(C.h)>>>0,C=C.h,Ra(C,C.h+T));break;case 5:C=C.h,Ra(C,C.h+4);break;case 3:T=C.l;do{if(!Wd(C))throw Error("Unmatched start-group tag: stream EOF");if(C.i==4){if(C.l!=T)throw Error("Unmatched end-group tag");break}bo(C)}while(!0);break;default:throw Js(C.i,C.j)}}var ra=[];function Xb(){this.j=[],this.i=0,this.h=new Ri}function Aa(C,T){T.length!==0&&(C.j.push(T),C.i+=T.length)}function eg(C,T){if(T=T.R){Aa(C,C.h.end());for(var A=0;A<T.length;A++)Aa(C,Or(T[A])||at())}}var ti=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Ai(C,T){return ti?C[ti]|=T:C.A!==void 0?C.A|=T:(Object.defineProperties(C,{A:{value:T,configurable:!0,writable:!0,enumerable:!1}}),T)}function nc(C,T){ti?C[ti]&&(C[ti]&=~T):C.A!==void 0&&(C.A&=~T)}function Sn(C){var T;return ti?T=C[ti]:T=C.A,T??0}function zr(C,T){ti?C[ti]=T:C.A!==void 0?C.A=T:Object.defineProperties(C,{A:{value:T,configurable:!0,writable:!0,enumerable:!1}})}function ni(C){return Ai(C,1),C}function us(C,T){zr(T,(C|0)&-51)}function cs(C,T){zr(T,(C|18)&-41)}var ia={};function vo(C){return C!==null&&typeof C=="object"&&!Array.isArray(C)&&C.constructor===Object}var Ol,tg=[];zr(tg,23),Ol=Object.freeze(tg);function sc(C){if(Sn(C.o)&2)throw Error("Cannot mutate an immutable Message")}function Da(C){var T=C.length;(T=T?C[T-1]:void 0)&&vo(T)?T.g=1:(T={},C.push((T.g=1,T)))}function rc(C){var T=C.i+C.G;return C.B||(C.B=C.o[T]={})}function bs(C,T){return T===-1?null:T>=C.i?C.B?C.B[T]:void 0:C.o[T+C.G]}function Ts(C,T,A,P){sc(C),Di(C,T,A,P)}function Di(C,T,A,P){C.j&&(C.j=void 0),T>=C.i||P?rc(C)[T]=A:(C.o[T+C.G]=A,(C=C.B)&&T in C&&delete C[T])}function aa(C,T,A,P){var j=bs(C,T);Array.isArray(j)||(j=Ol);var Y=Sn(j);if(Y&1||ni(j),P)Y&2||Ai(j,2),A&1||Object.freeze(j);else{P=!(A&2);var K=Y&2;A&1||!K?P&&Y&16&&!K&&nc(j,16):(j=ni(Array.prototype.slice.call(j)),Di(C,T,j))}return j}function _n(C,T){var A=bs(C,T),P=A==null?A:typeof A=="number"||A==="NaN"||A==="Infinity"||A==="-Infinity"?Number(A):void 0;return P!=null&&P!==A&&Di(C,T,P),P}function Gd(C,T,A,P,j){C.h||(C.h={});var Y=C.h[A],K=aa(C,A,3,j);if(!Y){var ue=K;Y=[];var we=!!(Sn(C.o)&16);K=!!(Sn(ue)&2);var De=ue;!j&&K&&(ue=Array.prototype.slice.call(ue));for(var Me=K,nt=0;nt<ue.length;nt++){var tt=ue[nt],Ge=T,ct=!1;if(ct=ct===void 0?!1:ct,tt=Array.isArray(tt)?new Ge(tt):ct?new Ge:void 0,tt!==void 0){Ge=tt.o;var bt=ct=Sn(Ge);K&&(bt|=2),we&&(bt|=16),bt!=ct&&zr(Ge,bt),Ge=bt,Me=Me||!!(2&Ge),Y.push(tt)}}return C.h[A]=Y,we=Sn(ue),T=we|33,T=Me?T&-9:T|8,we!=T&&(Me=ue,Object.isFrozen(Me)&&(Me=Array.prototype.slice.call(Me)),zr(Me,T),ue=Me),De!==ue&&Di(C,A,ue),(j||P&&K)&&Ai(Y,2),P&&Object.freeze(Y),Y}return j||(j=Object.isFrozen(Y),P&&!j?Object.freeze(Y):!P&&j&&(Y=Array.prototype.slice.call(Y),C.h[A]=Y)),Y}function ic(C,T,A){var P=!!(Sn(C.o)&2);if(T=Gd(C,T,A,P,P),C=aa(C,A,3,P),!(P||Sn(C)&8)){for(P=0;P<T.length;P++){if(A=T[P],Sn(A.o)&2){var j=jd(A,!1);j.j=A}else j=A;A!==j&&(T[P]=j,C[P]=j.o)}Ai(C,8)}return T}function vs(C,T,A){if(A!=null&&typeof A!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof A+": "+A);Ts(C,T,A)}function _a(C,T,A,P,j){sc(C);var Y=Gd(C,A,T,!1,!1);return A=P??new A,C=aa(C,T,2,!1),j!=null?(Y.splice(j,0,A),C.splice(j,0,A.o)):(Y.push(A),C.push(A.o)),A.C()&&nc(C,8),A}function ac(C,T){return C??T}function Lr(C,T,A){return A=A===void 0?0:A,ac(_n(C,T),A)}var Fl;function Kb(C){switch(typeof C){case"number":return isFinite(C)?C:String(C);case"object":if(C)if(Array.isArray(C)){if((Sn(C)&128)!==0)return C=Array.prototype.slice.call(C),Da(C),C}else{if(pe&&C!=null&&C instanceof Uint8Array)return Ne(C);if(C instanceof Vs){var T=C.V;return T==null?"":typeof T=="string"?T:C.V=Ne(T)}}}return C}function zl(C,T,A,P){if(C!=null){if(Array.isArray(C))C=wo(C,T,A,P!==void 0);else if(vo(C)){var j={},Y;for(Y in C)j[Y]=zl(C[Y],T,A,P);C=j}else C=T(C,P);return C}}function wo(C,T,A,P){var j=Sn(C);P=P?!!(j&16):void 0,C=Array.prototype.slice.call(C);for(var Y=0;Y<C.length;Y++)C[Y]=zl(C[Y],T,A,P);return A(j,C),C}function _i(C){return C.ja===ia?C.toJSON():Kb(C)}function mr(C,T){C&128&&Da(T)}function Hd(C,T,A){if(A=A===void 0?cs:A,C!=null){if(pe&&C instanceof Uint8Array)return C.length?new Vs(new Uint8Array(C),ot):ls();if(Array.isArray(C)){var P=Sn(C);return P&2?C:T&&!(P&32)&&(P&16||P===0)?(zr(C,P|2),C):(C=wo(C,Hd,P&4?cs:A,!0),T=Sn(C),T&4&&T&2&&Object.freeze(C),C)}return C.ja===ia?oc(C):C}}function ng(C,T,A,P,j,Y,K){if(C=C.h&&C.h[A]){if(P=Sn(C),P&2?P=C:(Y=ee(C,oc),cs(P,Y),Object.freeze(Y),P=Y),sc(T),K=P==null?Ol:ni([]),P!=null){for(Y=!!P.length,C=0;C<P.length;C++){var ue=P[C];Y=Y&&!(Sn(ue.o)&2),K[C]=ue.o}Y=(Y?8:0)|1,C=Sn(K),(C&Y)!==Y&&(Object.isFrozen(K)&&(K=Array.prototype.slice.call(K)),zr(K,C|Y)),T.h||(T.h={}),T.h[A]=P}else T.h&&(T.h[A]=void 0);Di(T,A,K,j)}else Ts(T,A,Hd(P,Y,K),j)}function oc(C){return Sn(C.o)&2||(C=jd(C,!0),Ai(C.o,2)),C}function jd(C,T){var A=C.o,P=[];Ai(P,16);var j=C.constructor.h;if(j&&P.push(j),j=C.B,j){P.length=A.length,P.fill(void 0,P.length,A.length);var Y={};P[P.length-1]=Y}(Sn(A)&128)!==0&&Da(P),T=T||C.C()?cs:us,Y=C.constructor,Fl=P,P=new Y(P),Fl=void 0,C.R&&(P.R=C.R.slice()),Y=!!(Sn(A)&16);for(var K=j?A.length-1:A.length,ue=0;ue<K;ue++)ng(C,P,ue-C.G,A[ue],!1,Y,T);if(j)for(var we in j)ng(C,P,+we,j[we],!0,Y,T);return P}function hs(C,T,A){C==null&&(C=Fl),Fl=void 0;var P=this.constructor.i||0,j=0<P,Y=this.constructor.h,K=!1;if(C==null){C=Y?[Y]:[];var ue=48,we=!0;j&&(P=0,ue|=128),zr(C,ue)}else{if(!Array.isArray(C)||Y&&Y!==C[0])throw Error();var De=ue=Ai(C,0);if((we=(16&De)!==0)&&((K=(32&De)!==0)||(De|=32)),j){if(128&De)P=0;else if(0<C.length){var Me=C[C.length-1];if(vo(Me)&&"g"in Me){P=0,De|=128,delete Me.g;var nt=!0,tt;for(tt in Me){nt=!1;break}nt&&C.pop()}}}else if(128&De)throw Error();ue!==De&&zr(C,De)}this.G=(Y?0:-1)-P,this.h=void 0,this.o=C;e:{if(Y=this.o.length,P=Y-1,Y&&(Y=this.o[P],vo(Y))){this.B=Y,this.i=P-this.G;break e}T!==void 0&&-1<T?(this.i=Math.max(T,P+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!j&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(A){T=we&&!K&&!0,j=this.i;var Ge;for(we=0;we<A.length;we++)K=A[we],K<j?(K+=this.G,(P=C[K])?sg(P,T):C[K]=Ol):(Ge||(Ge=rc(this)),(P=Ge[K])?sg(P,T):Ge[K]=Ol)}}hs.prototype.toJSON=function(){return wo(this.o,_i,mr)},hs.prototype.C=function(){return!!(Sn(this.o)&2)};function sg(C,T){if(Array.isArray(C)){var A=Sn(C),P=1;!T||A&2||(P|=16),(A&P)!==P&&zr(C,A|P)}}hs.prototype.ja=ia,hs.prototype.toString=function(){return this.o.toString()};function sr(C,T,A){if(A){var P={},j;for(j in A){var Y=A[j],K=Y.ra;K||(P.J=Y.xa||Y.oa.W,Y.ia?(P.aa=Kd(Y.ia),K=(function(ue){return function(we,De,Me){return ue.J(we,De,Me,ue.aa)}})(P)):Y.ka?(P.Z=Yd(Y.da.P,Y.ka),K=(function(ue){return function(we,De,Me){return ue.J(we,De,Me,ue.Z)}})(P)):K=P.J,Y.ra=K),K(T,C,Y.da),P={J:P.J,aa:P.aa,Z:P.Z}}}eg(T,C)}var So=Symbol();function qd(C,T,A){return C[So]||(C[So]=function(P,j){return T(P,j,A)})}function lc(C){var T=C[So];if(!T){var A=hc(C);T=function(P,j){return $o(P,j,A)},C[So]=T}return T}function Co(C){var T=C.ia;if(T)return lc(T);if(T=C.wa)return qd(C.da.P,T,C.ka)}function rg(C){var T=Co(C),A=C.da,P=C.oa.U;return T?function(j,Y){return P(j,Y,A,T)}:function(j,Y){return P(j,Y,A)}}function Xd(C,T){var A=C[T];return typeof A=="function"&&A.length===0&&(A=A(),C[T]=A),Array.isArray(A)&&(za in A||Fa in A||0<A.length&&typeof A[0]=="function")?A:void 0}function Oa(C,T,A,P,j,Y){T.P=C[0];var K=1;if(C.length>K&&typeof C[K]!="number"){var ue=C[K++];A(T,ue)}for(;K<C.length;){A=C[K++];for(var we=K+1;we<C.length&&typeof C[we]!="number";)we++;switch(ue=C[K++],we-=K,we){case 0:P(T,A,ue);break;case 1:(we=Xd(C,K))?(K++,j(T,A,ue,we)):P(T,A,ue,C[K++]);break;case 2:we=K++,we=Xd(C,we),j(T,A,ue,we,C[K++]);break;case 3:Y(T,A,ue,C[K++],C[K++],C[K++]);break;case 4:Y(T,A,ue,C[K++],C[K++],C[K++],C[K++]);break;default:throw Error("unexpected number of binary field arguments: "+we)}}return T}var uc=Symbol();function Kd(C){var T=C[uc];if(!T){var A=Ll(C);T=function(P,j){return si(P,j,A)},C[uc]=T}return T}function Yd(C,T){var A=C[uc];return A||(A=function(P,j){return sr(P,j,T)},C[uc]=A),A}var Fa=Symbol();function Yb(C,T){C.push(T)}function Qb(C,T,A){C.push(T,A.W)}function cc(C,T,A,P){var j=Kd(P),Y=Ll(P).P,K=A.W;C.push(T,function(ue,we,De){return K(ue,we,De,Y,j)})}function Oi(C,T,A,P,j,Y){var K=Yd(P,Y),ue=A.W;C.push(T,function(we,De,Me){return ue(we,De,Me,P,K)})}function Ll(C){var T=C[Fa];return T||(T=Oa(C,C[Fa]=[],Yb,Qb,cc,Oi),za in C&&Fa in C&&(C.length=0),T)}var za=Symbol();function No(C,T){C[0]=T}function ko(C,T,A,P){var j=A.U;C[T]=P?function(Y,K,ue){return j(Y,K,ue,P)}:j}function ig(C,T,A,P,j){var Y=A.U,K=lc(P),ue=hc(P).P;C[T]=function(we,De,Me){return Y(we,De,Me,ue,K,j)}}function Qd(C,T,A,P,j,Y,K){var ue=A.U,we=qd(P,j,Y);C[T]=function(De,Me,nt){return ue(De,Me,nt,P,we,K)}}function hc(C){var T=C[za];return T||(T=Oa(C,C[za]={},No,ko,ig,Qd),za in C&&Fa in C&&(C.length=0),T)}function $o(C,T,A){for(;Wd(T)&&T.i!=4;){var P=T.l,j=A[P];if(!j){var Y=A[0];Y&&(Y=Y[P])&&(j=A[P]=rg(Y))}if(!j||!j(T,C,P)){j=T,P=C,Y=j.j,bo(j);var K=j;if(!K.ca){if(j=K.h.h-Y,K.h.h=Y,K=K.h,j==0)j=ls();else{if(Y=Al(K,j),K.S&&K.m)j=K.i.subarray(Y,Y+j);else{K=K.i;var ue=Y;j=Y+j,j=ue===j?at():Tt?K.slice(ue,j):new Uint8Array(K.subarray(ue,j))}j=j.length==0?ls():new Vs(j,ot)}(Y=P.R)?Y.push(j):P.R=[j]}}}return C}function si(C,T,A){for(var P=A.length,j=P%2==1,Y=j?1:0;Y<P;Y+=2)(0,A[Y+1])(T,C,A[Y]);sr(C,T,j?A[0]:void 0)}function La(C,T){return{U:C,W:T}}var Es=La(function(C,T,A){if(C.i!==5)return!1;C=C.h;var P=C.i,j=C.h,Y=P[j],K=P[j+1],ue=P[j+2];return P=P[j+3],Ra(C,C.h+4),K=(Y<<0|K<<8|ue<<16|P<<24)>>>0,C=2*(K>>31)+1,Y=K>>>23&255,K&=8388607,Ts(T,A,Y==255?K?NaN:1/0*C:Y==0?C*Math.pow(2,-149)*K:C*Math.pow(2,Y-150)*(K+Math.pow(2,23))),!0},function(C,T,A){if(T=_n(T,A),T!=null){Fr(C.h,8*A+5),C=C.h;var P=+T;P===0?0<1/P?ut=mt=0:(mt=0,ut=2147483648):isNaN(P)?(mt=0,ut=2147483647):(P=(A=0>P?-2147483648:0)?-P:P,34028234663852886e22<P?(mt=0,ut=(A|2139095040)>>>0):11754943508222875e-54>P?(P=Math.round(P/Math.pow(2,-149)),mt=0,ut=(A|P)>>>0):(T=Math.floor(Math.log(P)/Math.LN2),P*=Math.pow(2,-T),P=Math.round(8388608*P),16777216<=P&&++T,mt=0,ut=(A|T+127<<23|P&8388607)>>>0)),A=ut,C.h.push(A>>>0&255),C.h.push(A>>>8&255),C.h.push(A>>>16&255),C.h.push(A>>>24&255)}}),oa=La(function(C,T,A){if(C.i!==0)return!1;var P=C.h,j=0,Y=C=0,K=P.i,ue=P.h;do{var we=K[ue++];j|=(we&127)<<Y,Y+=7}while(32>Y&&we&128);for(32<Y&&(C|=(we&127)>>4),Y=3;32>Y&&we&128;Y+=7)we=K[ue++],C|=(we&127)<<Y;if(Ra(P,ue),128>we)P=j>>>0,we=C>>>0,(C=we&2147483648)&&(P=~P+1>>>0,we=~we>>>0,P==0&&(we=we+1>>>0)),P=4294967296*we+(P>>>0);else throw os();return Ts(T,A,C?-P:P),!0},function(C,T,A){T=bs(T,A),T!=null&&(typeof T=="string"&&Ps(T),T!=null&&(Fr(C.h,8*A),typeof T=="number"?(C=C.h,Bt(T),_l(C,ut,mt)):(A=Ps(T),_l(C.h,A.i,A.h))))}),Zd=La(function(C,T,A){return C.i!==0?!1:(Ts(T,A,sa(C.h)),!0)},function(C,T,A){if(T=bs(T,A),T!=null&&T!=null)if(Fr(C.h,8*A),C=C.h,A=T,0<=A)Fr(C,A);else{for(T=0;9>T;T++)C.h.push(A&127|128),A>>=7;C.h.push(1)}}),Ml=La(function(C,T,A){if(C.i!==2)return!1;var P=sa(C.h)>>>0;C=C.h;var j=Al(C,P);if(C=C.i,tr){var Y=C,K;(K=er)||(K=er=new TextDecoder("utf-8",{fatal:!0})),C=j+P,Y=j===0&&C===Y.length?Y:Y.subarray(j,C);try{var ue=K.decode(Y)}catch(nt){if(Bs===void 0){try{K.decode(new Uint8Array([128]))}catch{}try{K.decode(new Uint8Array([97])),Bs=!0}catch{Bs=!1}}throw!Bs&&(er=void 0),nt}}else{ue=j,P=ue+P,j=[];for(var we=null,De,Me;ue<P;)De=C[ue++],128>De?j.push(De):224>De?ue>=P?Ut():(Me=C[ue++],194>De||(Me&192)!==128?(ue--,Ut()):j.push((De&31)<<6|Me&63)):240>De?ue>=P-1?Ut():(Me=C[ue++],(Me&192)!==128||De===224&&160>Me||De===237&&160<=Me||((Y=C[ue++])&192)!==128?(ue--,Ut()):j.push((De&15)<<12|(Me&63)<<6|Y&63)):244>=De?ue>=P-2?Ut():(Me=C[ue++],(Me&192)!==128||(De<<28)+(Me-144)>>30!==0||((Y=C[ue++])&192)!==128||((K=C[ue++])&192)!==128?(ue--,Ut()):(De=(De&7)<<18|(Me&63)<<12|(Y&63)<<6|K&63,De-=65536,j.push((De>>10&1023)+55296,(De&1023)+56320))):Ut(),8192<=j.length&&(we=fr(we,j),j.length=0);ue=fr(we,j)}return Ts(T,A,ue),!0},function(C,T,A){if(T=bs(T,A),T!=null){var P=!1;if(P=P===void 0?!1:P,yo){if(P&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(T))throw Error("Found an unpaired surrogate");T=(na||(na=new TextEncoder)).encode(T)}else{for(var j=0,Y=new Uint8Array(3*T.length),K=0;K<T.length;K++){var ue=T.charCodeAt(K);if(128>ue)Y[j++]=ue;else{if(2048>ue)Y[j++]=ue>>6|192;else{if(55296<=ue&&57343>=ue){if(56319>=ue&&K<T.length){var we=T.charCodeAt(++K);if(56320<=we&&57343>=we){ue=1024*(ue-55296)+we-56320+65536,Y[j++]=ue>>18|240,Y[j++]=ue>>12&63|128,Y[j++]=ue>>6&63|128,Y[j++]=ue&63|128;continue}else K--}if(P)throw Error("Found an unpaired surrogate");ue=65533}Y[j++]=ue>>12|224,Y[j++]=ue>>6&63|128}Y[j++]=ue&63|128}}T=j===Y.length?Y:Y.subarray(0,j)}Fr(C.h,8*A+2),Fr(C.h,T.length),Aa(C,C.h.end()),Aa(C,T)}}),Jd=La(function(C,T,A,P,j){if(C.i!==2)return!1;T=_a(T,A,P),A=C.h.j,P=sa(C.h)>>>0;var Y=C.h.h+P,K=Y-A;if(0>=K&&(C.h.j=Y,j(T,C,void 0,void 0,void 0),K=Y-C.h.h),K)throw Error("Message parsing ended unexpectedly. Expected to read "+(P+" bytes, instead read "+(P-K)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return C.h.h=Y,C.h.j=A,!0},function(C,T,A,P,j){if(T=ic(T,P,A),T!=null)for(P=0;P<T.length;P++){var Y=C;Fr(Y.h,8*A+2);var K=Y.h.end();Aa(Y,K),K.push(Y.i),Y=K,j(T[P],C),K=C;var ue=Y.pop();for(ue=K.i+K.h.length()-ue;127<ue;)Y.push(ue&127|128),ue>>>=7,K.i++;Y.push(ue),K.i++}});function Io(C){return function(T,A){e:{if(ra.length){var P=ra.pop();P.setOptions(A),Vd(P.h,T,A),T=P}else T=new Ud(T,A);try{var j=hc(C),Y=$o(new j.P,T,j);break e}finally{j=T.h,j.i=null,j.m=!1,j.l=0,j.j=0,j.h=0,j.S=!1,T.l=-1,T.i=-1,100>ra.length&&ra.push(T)}Y=void 0}return Y}}function To(C){return function(){var T=new Xb;si(this,T,Ll(C)),Aa(T,T.h.end());for(var A=new Uint8Array(T.i),P=T.j,j=P.length,Y=0,K=0;K<j;K++){var ue=P[K];A.set(ue,Y),Y+=ue.length}return T.j=[A],A}}function Ma(C){hs.call(this,C)}v(Ma,hs);var Rs=[Ma,1,Zd,2,Es,3,Ml,4,Ml];Ma.prototype.l=To(Rs);function Fi(C){hs.call(this,C,-1,dc)}v(Fi,hs),Fi.prototype.addClassification=function(C,T){return _a(this,1,Ma,C,T),this};var dc=[1],Pl=Io([Fi,1,Jd,Rs]);function Bl(C){hs.call(this,C)}v(Bl,hs);var pc=[Bl,1,Es,2,Es,3,Es,4,Es,5,Es];Bl.prototype.l=To(pc);function fc(C){hs.call(this,C,-1,Vl)}v(fc,hs);var Vl=[1],mc=Io([fc,1,Jd,pc]);function Ul(C){hs.call(this,C)}v(Ul,hs);var ag=[Ul,1,Es,2,Es,3,Es,4,Es,5,Es,6,oa],Zb=Io(ag);Ul.prototype.l=To(ag);function og(C,T,A){if(A=C.createShader(A===0?C.VERTEX_SHADER:C.FRAGMENT_SHADER),C.shaderSource(A,T),C.compileShader(A),!C.getShaderParameter(A,C.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+C.getShaderInfoLog(A));return A}function ep(C){return ic(C,Ma,1).map(function(T){var A=bs(T,1);return{index:A??0,qa:Lr(T,2),label:bs(T,3)!=null?ac(bs(T,3),""):void 0,displayName:bs(T,4)!=null?ac(bs(T,4),""):void 0}})}function Jb(C){return{x:Lr(C,1),y:Lr(C,2),z:Lr(C,3),visibility:_n(C,4)!=null?Lr(C,4):void 0}}function tp(C){return ic(mc(C),Bl,1).map(Jb)}function np(C,T){this.i=C,this.h=T,this.m=0}function lg(C,T,A){return e1(C,T),typeof C.h.canvas.transferToImageBitmap=="function"?Promise.resolve(C.h.canvas.transferToImageBitmap()):A?Promise.resolve(C.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(C.h.canvas):(C.j===void 0&&(C.j=document.createElement("canvas")),new Promise(function(P){C.j.height=C.h.canvas.height,C.j.width=C.h.canvas.width,C.j.getContext("2d",{}).drawImage(C.h.canvas,0,0,C.h.canvas.width,C.h.canvas.height),P(C.j)}))}function e1(C,T){var A=C.h;if(C.s===void 0){var P=og(A,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),j=og(A,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),Y=A.createProgram();if(A.attachShader(Y,P),A.attachShader(Y,j),A.linkProgram(Y),!A.getProgramParameter(Y,A.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+A.getProgramInfoLog(Y));P=C.s=Y,A.useProgram(P),j=A.getUniformLocation(P,"sampler0"),C.l={O:A.getAttribLocation(P,"aVertex"),N:A.getAttribLocation(P,"aTex"),ya:j},C.v=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,C.v),A.enableVertexAttribArray(C.l.O),A.vertexAttribPointer(C.l.O,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),C.u=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,C.u),A.enableVertexAttribArray(C.l.N),A.vertexAttribPointer(C.l.N,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),A.uniform1i(j,0)}P=C.l,A.useProgram(C.s),A.canvas.width=T.width,A.canvas.height=T.height,A.viewport(0,0,T.width,T.height),A.activeTexture(A.TEXTURE0),C.i.bindTexture2d(T.glName),A.enableVertexAttribArray(P.O),A.bindBuffer(A.ARRAY_BUFFER,C.v),A.vertexAttribPointer(P.O,2,A.FLOAT,!1,0,0),A.enableVertexAttribArray(P.N),A.bindBuffer(A.ARRAY_BUFFER,C.u),A.vertexAttribPointer(P.N,2,A.FLOAT,!1,0,0),A.bindFramebuffer(A.DRAW_FRAMEBUFFER?A.DRAW_FRAMEBUFFER:A.FRAMEBUFFER,null),A.clearColor(0,0,0,0),A.clear(A.COLOR_BUFFER_BIT),A.colorMask(!0,!0,!0,!0),A.drawArrays(A.TRIANGLE_FAN,0,4),A.disableVertexAttribArray(P.O),A.disableVertexAttribArray(P.N),A.bindBuffer(A.ARRAY_BUFFER,null),C.i.bindTexture2d(0)}function ug(C){this.h=C}var t1=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function n1(C,T){return T+C}function cg(C,T){window[C]=T}function s1(C){var T=document.createElement("script");return T.setAttribute("src",C),T.setAttribute("crossorigin","anonymous"),new Promise(function(A){T.addEventListener("load",function(){A()},!1),T.addEventListener("error",function(){A()},!1),document.body.appendChild(T)})}function sp(){return O(function(C){switch(C.h){case 1:return C.s=2,$(C,WebAssembly.instantiate(t1),4);case 4:C.h=3,C.s=0;break;case 2:return C.s=0,C.l=null,C.return(!1);case 3:return C.return(!0)}})}function rp(C){if(this.h=C,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=C&&C.locateFile||n1,typeof window=="object")var T=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")T=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=T,C.options){T=o(Object.keys(C.options));for(var A=T.next();!A.done;A=T.next()){A=A.value;var P=C.options[A].default;P!==void 0&&(this.l[A]=typeof P=="function"?P():P)}}}n=rp.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function r1(C){var T,A,P,j,Y,K,ue,we,De,Me,nt;return O(function(tt){switch(tt.h){case 1:return C.ga?(T=C.h.files===void 0?[]:typeof C.h.files=="function"?C.h.files(C.l):C.h.files,$(tt,sp(),2)):tt.return();case 2:if(A=tt.i,typeof window=="object")return cg("createMediapipeSolutionsWasm",{locateFile:C.locateFile}),cg("createMediapipeSolutionsPackedAssets",{locateFile:C.locateFile}),K=T.filter(function(Ge){return Ge.data!==void 0}),ue=T.filter(function(Ge){return Ge.data===void 0}),we=Promise.all(K.map(function(Ge){var ct=gc(C,Ge.url);if(Ge.path!==void 0){var bt=Ge.path;ct=ct.then(function(rn){return C.overrideFile(bt,rn),Promise.resolve(rn)})}return ct})),De=Promise.all(ue.map(function(Ge){return Ge.simd===void 0||Ge.simd&&A||!Ge.simd&&!A?s1(C.locateFile(Ge.url,C.ha)):Promise.resolve()})).then(function(){var Ge,ct,bt;return O(function(rn){if(rn.h==1)return Ge=window.createMediapipeSolutionsWasm,ct=window.createMediapipeSolutionsPackedAssets,bt=C,$(rn,Ge(ct),2);bt.i=rn.i,rn.h=0})}),Me=(function(){return O(function(Ge){return C.h.graph&&C.h.graph.url?Ge=$(Ge,gc(C,C.h.graph.url),0):(Ge.h=0,Ge=void 0),Ge})})(),$(tt,Promise.all([De,we,Me]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return P=T.filter(function(Ge){return Ge.simd===void 0||Ge.simd&&A||!Ge.simd&&!A}).map(function(Ge){return C.locateFile(Ge.url,C.ha)}),importScripts.apply(null,u(P)),j=C,$(tt,createMediapipeSolutionsWasm(Module),6);case 6:j.i=tt.i,C.m=new OffscreenCanvas(1,1),C.i.canvas=C.m,Y=C.i.GL.createContext(C.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),C.i.GL.makeContextCurrent(Y),tt.h=4;break;case 7:if(C.m=document.createElement("canvas"),nt=C.m.getContext("webgl2",{}),!nt&&(nt=C.m.getContext("webgl",{}),!nt))return alert("Failed to create WebGL canvas context when passing video frame."),tt.return();C.K=nt,C.i.canvas=C.m,C.i.createContext(C.m,!0,!0,{});case 4:C.j=new C.i.SolutionWasm,C.ga=!1,tt.h=0}})}function i1(C){var T,A,P,j,Y,K,ue,we;return O(function(De){if(De.h==1){if(C.h.graph&&C.h.graph.url&&C.fa===C.h.graph.url)return De.return();if(C.u=!0,!C.h.graph||!C.h.graph.url){De.h=2;return}return C.fa=C.h.graph.url,$(De,gc(C,C.h.graph.url),3)}for(De.h!=2&&(T=De.i,C.j.loadGraph(T)),A=o(Object.keys(C.D)),P=A.next();!P.done;P=A.next())j=P.value,C.j.overrideFile(j,C.D[j]);if(C.D={},C.h.listeners)for(Y=o(C.h.listeners),K=Y.next();!K.done;K=Y.next())ue=K.value,l1(C,ue);we=C.l,C.l={},C.setOptions(we),De.h=0})}n.reset=function(){var C=this;return O(function(T){C.j&&(C.j.reset(),C.s={},C.v={}),T.h=0})},n.setOptions=function(C,T){var A=this;if(T=T||this.h.options){for(var P=[],j=[],Y={},K=o(Object.keys(C)),ue=K.next();!ue.done;Y={X:Y.X,Y:Y.Y},ue=K.next())if(ue=ue.value,!(ue in this.l&&this.l[ue]===C[ue])){this.l[ue]=C[ue];var we=T[ue];we!==void 0&&(we.onChange&&(Y.X=we.onChange,Y.Y=C[ue],P.push((function(De){return function(){var Me;return O(function(nt){if(nt.h==1)return $(nt,De.X(De.Y),2);Me=nt.i,Me===!0&&(A.u=!0),nt.h=0})}})(Y))),we.graphOptionXref&&(ue=Object.assign({},{calculatorName:"",calculatorIndex:0},we.graphOptionXref,{valueNumber:we.type===1?C[ue]:0,valueBoolean:we.type===0?C[ue]:!1,valueString:we.type===2?C[ue]:""}),j.push(ue)))}(P.length!==0||j.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(j),this.F=(this.F===void 0?[]:this.F).concat(P))}};function hg(C){var T,A,P,j,Y,K,ue;return O(function(we){switch(we.h){case 1:if(!C.u)return we.return();if(!C.F){we.h=2;break}T=o(C.F),A=T.next();case 3:if(A.done){we.h=5;break}return P=A.value,$(we,P(),4);case 4:A=T.next(),we.h=3;break;case 5:C.F=void 0;case 2:if(C.H){for(j=new C.i.GraphOptionChangeRequestList,Y=o(C.H),K=Y.next();!K.done;K=Y.next())ue=K.value,j.push_back(ue);C.j.changeOptions(j),j.delete(),C.H=void 0}C.u=!1,we.h=0}})}n.initialize=function(){var C=this;return O(function(T){return T.h==1?$(T,r1(C),2):T.h!=3?$(T,i1(C),3):$(T,hg(C),0)})};function gc(C,T){var A,P;return O(function(j){return T in C.L?j.return(C.L[T]):(A=C.locateFile(T,""),P=fetch(A).then(function(Y){return Y.arrayBuffer()}),C.L[T]=P,j.return(P))})}n.overrideFile=function(C,T){this.j?this.j.overrideFile(C,T):this.D[C]=T},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(C,T){var A=this,P,j,Y,K,ue,we,De,Me,nt;return O(function(tt){switch(tt.h){case 1:return A.h.inputs?(P=1e3*(T??performance.now()),$(tt,A.I,2)):tt.return();case 2:return $(tt,A.initialize(),3);case 3:for(j=new A.i.PacketDataList,Y=o(Object.keys(C)),K=Y.next();!K.done;K=Y.next())if(ue=K.value,we=A.h.inputs[ue]){e:{var Ge=C[ue];switch(we.type){case"video":var ct=A.s[we.stream];if(ct||(ct=new np(A.i,A.K),A.s[we.stream]=ct),ct.m===0&&(ct.m=ct.i.createTexture()),typeof HTMLVideoElement<"u"&&Ge instanceof HTMLVideoElement)var bt=Ge.videoWidth,rn=Ge.videoHeight;else typeof HTMLImageElement<"u"&&Ge instanceof HTMLImageElement?(bt=Ge.naturalWidth,rn=Ge.naturalHeight):(bt=Ge.width,rn=Ge.height);rn={glName:ct.m,width:bt,height:rn},bt=ct.h,bt.canvas.width=rn.width,bt.canvas.height=rn.height,bt.activeTexture(bt.TEXTURE0),ct.i.bindTexture2d(ct.m),bt.texImage2D(bt.TEXTURE_2D,0,bt.RGBA,bt.RGBA,bt.UNSIGNED_BYTE,Ge),ct.i.bindTexture2d(0),ct=rn;break e;case"detections":for(ct=A.s[we.stream],ct||(ct=new ug(A.i),A.s[we.stream]=ct),ct.data||(ct.data=new ct.h.DetectionListData),ct.data.reset(Ge.length),rn=0;rn<Ge.length;++rn){bt=Ge[rn];var Gt=ct.data,In=Gt.setBoundingBox,gr=rn,ds=bt.la,zt=new Ul;if(vs(zt,1,ds.sa),vs(zt,2,ds.ta),vs(zt,3,ds.height),vs(zt,4,ds.width),vs(zt,5,ds.rotation),Ts(zt,6,ds.pa),ds=zt.l(),In.call(Gt,gr,ds),bt.ea)for(Gt=0;Gt<bt.ea.length;++Gt){zt=bt.ea[Gt],In=ct.data,gr=In.addNormalizedLandmark,ds=rn,zt=Object.assign({},zt,{visibility:zt.visibility?zt.visibility:0});var jn=new Bl;vs(jn,1,zt.x),vs(jn,2,zt.y),vs(jn,3,zt.z),zt.visibility&&vs(jn,4,zt.visibility),zt=jn.l(),gr.call(In,ds,zt)}if(bt.ba)for(Gt=0;Gt<bt.ba.length;++Gt)In=ct.data,gr=In.addClassification,ds=rn,zt=bt.ba[Gt],jn=new Ma,vs(jn,2,zt.qa),zt.index&&Ts(jn,1,zt.index),zt.label&&Ts(jn,3,zt.label),zt.displayName&&Ts(jn,4,zt.displayName),zt=jn.l(),gr.call(In,ds,zt)}ct=ct.data;break e;default:ct={}}}switch(De=ct,Me=we.stream,we.type){case"video":j.pushTexture2d(Object.assign({},De,{stream:Me,timestamp:P}));break;case"detections":nt=De,nt.stream=Me,nt.timestamp=P,j.pushDetectionList(nt);break;default:throw Error("Unknown input config type: '"+we.type+"'")}}return A.j.send(j),$(tt,A.I,4);case 4:j.delete(),tt.h=0}})};function a1(C,T,A){var P,j,Y,K,ue,we,De,Me,nt,tt,Ge,ct,bt,rn;return O(function(Gt){switch(Gt.h){case 1:if(!A)return Gt.return(T);for(P={},j=0,Y=o(Object.keys(A)),K=Y.next();!K.done;K=Y.next())ue=K.value,we=A[ue],typeof we!="string"&&we.type==="texture"&&T[we.stream]!==void 0&&++j;1<j&&(C.M=!1),De=o(Object.keys(A)),K=De.next();case 2:if(K.done){Gt.h=4;break}if(Me=K.value,nt=A[Me],typeof nt=="string")return bt=P,rn=Me,$(Gt,o1(C,Me,T[nt]),14);if(tt=T[nt.stream],nt.type==="detection_list"){if(tt){for(var In=tt.getRectList(),gr=tt.getLandmarksList(),ds=tt.getClassificationsList(),zt=[],jn=0;jn<In.size();++jn){var ri=Zb(In.get(jn)),ip=Lr(ri,1),fg=Lr(ri,2),mg=Lr(ri,3),gg=Lr(ri,4),u1=Lr(ri,5,0),yc=void 0;yc=yc===void 0?0:yc,ri={la:{sa:ip,ta:fg,height:mg,width:gg,rotation:u1,pa:ac(bs(ri,6),yc)},ea:tp(gr.get(jn)),ba:ep(Pl(ds.get(jn)))},zt.push(ri)}In=zt}else In=[];P[Me]=In,Gt.h=7;break}if(nt.type==="proto_list"){if(tt){for(In=Array(tt.size()),gr=0;gr<tt.size();gr++)In[gr]=tt.get(gr);tt.delete()}else In=[];P[Me]=In,Gt.h=7;break}if(tt===void 0){Gt.h=3;break}if(nt.type==="float_list"){P[Me]=tt,Gt.h=7;break}if(nt.type==="proto"){P[Me]=tt,Gt.h=7;break}if(nt.type!=="texture")throw Error("Unknown output config type: '"+nt.type+"'");return Ge=C.v[Me],Ge||(Ge=new np(C.i,C.K),C.v[Me]=Ge),$(Gt,lg(Ge,tt,C.M),13);case 13:ct=Gt.i,P[Me]=ct;case 7:nt.transform&&P[Me]&&(P[Me]=nt.transform(P[Me])),Gt.h=3;break;case 14:bt[rn]=Gt.i;case 3:K=De.next(),Gt.h=2;break;case 4:return Gt.return(P)}})}function o1(C,T,A){var P;return O(function(j){return typeof A=="number"||A instanceof Uint8Array||A instanceof C.i.Uint8BlobList?j.return(A):A instanceof C.i.Texture2dDataOut?(P=C.v[T],P||(P=new np(C.i,C.K),C.v[T]=P),j.return(lg(P,A,C.M))):j.return(void 0)})}function l1(C,T){for(var A=T.name||"$",P=[].concat(u(T.wants)),j=new C.i.StringList,Y=o(T.wants),K=Y.next();!K.done;K=Y.next())j.push_back(K.value);Y=C.i.PacketListener.implement({onResults:function(ue){for(var we={},De=0;De<T.wants.length;++De)we[P[De]]=ue.get(De);var Me=C.listeners[A];Me&&(C.I=a1(C,we,T.outs).then(function(nt){nt=Me(nt);for(var tt=0;tt<T.wants.length;++tt){var Ge=we[P[tt]];typeof Ge=="object"&&Ge.hasOwnProperty&&Ge.hasOwnProperty("delete")&&Ge.delete()}nt&&(C.I=nt)}))}}),C.j.attachMultiListener(j,Y),j.delete()}n.onResults=function(C,T){this.listeners[T||"$"]=C},Z("Solution",rp),Z("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function dg(C){switch(C===void 0&&(C=0),C){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function pg(C){var T=this;C=C||{},this.h=new rp({locateFile:C.locateFile,files:function(A){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:dg(A.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:tp},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:tp},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(A){var P,j,Y;return O(function(K){return K.h==1?(P=dg(A),j="third_party/mediapipe/modules/pose_landmark/"+P,$(K,gc(T.h,P),2)):(Y=K.i,T.h.overrideFile(j,Y),K.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=pg.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(C){this.h.onResults(C)},n.initialize=function(){var C=this;return O(function(T){return $(T,C.h.initialize(),0)})},n.send=function(C,T){var A=this;return O(function(P){return $(P,A.h.send(C,T),0)})},n.setOptions=function(C){this.h.setOptions(C)},Z("Pose",pg),Z("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),Z("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),Z("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),Z("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),Z("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),Z("VERSION","0.5.1675469404")}).call(Rw)),Rw}var Yde=Kde();const Jr=fe();Jr.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Jr.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Jr.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Jr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Jr.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Jr.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Jr.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Jr.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Jr.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Jr.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Jr.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Jr.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Jr.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);class Qde{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}class Zde{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,r=!0){let i;const a=EE(e,t);return r?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(i=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,r=e.usage,i=EE(s,r),a=this.usedBuffers.get(i),o=a.indexOf(e);if(o<0)throw new Error("Cannot find the buffer in buffer manager");a[o]=a[a.length-1],a.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function EE(n,e){return`${n}_${e}`}class Jde{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,r){const i=AE(s),a=e*t*i,o=RE(e,t,s,r);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;const c=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(c),c}this.numBytesAllocated+=a;const u=this.device.createTexture({size:[e,t],format:s,usage:r});return this.usedTextures.get(o).push(u),u}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,r=e.format,i=e.usage,a=RE(t,s,r,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(a),u=o.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(u,1);const c=AE(r),d=t*s*c;this.numBytesUsed-=d}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function RE(n,e,t,s){return`${n}_${e}_${t}_${s}`}function AE(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}function epe(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",r=n.map(a=>`${e}.${s[a]}`),i=new Array(t-1);i[t-2]=r[t-1];for(let a=t-3;a>=0;--a)i[a]=`(${i[a+1]} * ${r[a+1]})`;return i}const Rl=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;var Sh;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Sh||(Sh={}));const tpe=(n,e,t,s,r)=>{const i={dtype:s.dtype,shape:s.shape},a=spe(t,i,e),o=n.createShaderModule({code:a,label:e.constructor.name});let u=fe().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const c=u.split(",");(u==="all"||c.some(d=>e.shaderKey.toLowerCase().includes(d)))&&(console.group(e.shaderKey),console.debug(a),console.groupEnd())}return r?n.createComputePipelineAsync({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},wt=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Ln(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function oo(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function ze(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function DE(n,e){let t;return t=`
     ${npe(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function npe(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function spe(n,e,t){const s=[],r=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${Fz(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const x=t.pixelsOpType===Sh.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${pu(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${pu(n[0].dtype,t.outputComponent)}>;`,b=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${b},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${x}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const v=OE(t);return[_E,s.join(`
`),Xy(e.shape),t.getUserCode(),DE(v,t)].join(`
`)}let i,a,o="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((x,b)=>{const v=Ln(n[b].shape.length);o+=`${x.charAt(0).toLowerCase()+x.slice(1)}Shape : ${v}, `,i=n[b].shape.length-1,a=Ln(i),o+=`${x.charAt(0).toLowerCase()+x.slice(1)}ShapeStrides: ${a}, `});const u=Ln(e.shape.length);o+=`outShape : ${u}, `,i=e.shape.length-1,a=Ln(i),o+=`
         outShapeStrides: ${a}, `,t.size&&(o+="size : i32, "),t.uniforms&&(o+=t.uniforms),o+="};",o=dpe(o),s.push(o),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${pu(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((x,b)=>{s.push(`
      @group(0) @binding(${1+b}) var<storage, read> ${x}: array<${t.variableComponents?pu(n[b].dtype,t.variableComponents[b]):pu(n[b].dtype,t.outputComponent)}>;
        `)}),o!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=upe(e.shape,t.dispatchLayout),d=[_E,s.join(`
`)+ipe,Xy(e.shape),c,cpe(e.shape.length)];t.atomic||d.push(hpe(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((x,b)=>{d.push(`${Xy(n[b].shape,x)}`)});const p=n.map((x,b)=>lpe(x,e.shape,t.variableComponents?t.variableComponents[b]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);d.push(p),d.push(t.getUserCode());const m=OE(t);return d.push(DE(m,t)),d.join(`
`)}function rpe(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const r=[],i=[];e.forEach(d=>{r.push(d.shape),i.push(d.dtype)}),r.push(t.shape),i.push(t.dtype);const a=e.map(d=>dl(d.shape,t.shape)),o=e.map(d=>xt(d.shape,t.shape)).join("_"),u=a.map(d=>d.join("_")).join(";"),c=Fz(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+r.map(d=>d.length).join(",")+i.join(",")+n.variableNames.join(",")+u+o+c,s}const _E=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,ipe=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Xy(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const i=Ze(n),a=Ln(t),o=[];for(let c=0;c<t;c++)o.push(`d${c}`);if(i.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+i.map((c,d)=>{const p=`let ${o[d]} = index2 / uniforms.${r}.${oo(d)}`,m=d===i.length-1?`let ${o[d+1]} = index2 - ${o[d]} * uniforms.${r}.${oo(d)}`:`index2 = index2 - ${o[d]} * uniforms.${r}.${oo(d)}`;return`${p}; ${m};`}).join(""),`
    fn ${s}(index : i32) -> ${a} {
      ${u}
      return ${a}(${o.join(",")});
    }
  `}function ape(n,e){const t=n.name,s=n.shape.length,r=Ln(s),i="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,s),o=a.map(d=>`${d} : i32`).join(", ");if(s<1)return`
      fn ${i}() -> ${wt(e)} {
        return ${wt(e)}(${t}[0]);
      }
    `;const u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${s}D`;return s===0&&(c="1D"),`
    fn ${i}(${o}) -> ${wt(e)} {
      return ${wt(e)}(${t}[getIndexFromCoords${c}(${r}(${a.join(",")}),
        ${u})${e===1?"":` / ${e}`}]);
    }
   `}function ope(n,e,t,s){const r=n.name,i=r.charAt(0).toUpperCase()+r.slice(1),a="get"+i+"ByOutput",o=n.shape.length,u=e.length,c=Ln(u);if(xt(n.shape,e)&&s)return`
    fn ${a}Index(globalIndex : i32) -> ${wt(t)} {
      return ${wt(t)}(${r}[globalIndex]);
    }

    fn ${a}Coords(coords : ${c}) -> ${wt(t)} {
      return ${wt(t)}(${r}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const d=dl(n.shape,e),p=u-o;let m="";if(o===0)return`
    fn ${a}Index(globalIndex : i32) -> ${wt(t)}{
      return get${i}();
    }

    fn ${a}Coords(coords : ${c}) -> ${wt(t)}{
      return get${i}();
    }
  `;u<2&&d.length>=1?m="coords = 0;":m=d.map(v=>`coords.${oo(v+p)} = 0;`).join(`
`);let g="";if(u<2&&o>0)g="coords";else if(u>1){const v=Ln(o),w=n.shape.map((N,I)=>`coords.${oo(I+p)}`).join(", ");g=`${v}(${w})`}else g="coords";const x=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,b=`${o}D`;return`
  fn ${a}Index(globalIndex : i32) -> ${wt(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${m}
    return ${wt(t)}(${r}[getIndexFromCoords${b}(${g}, ${x})${t===1?"":` / ${t}`}]);
  }

  fn ${a}Coords(coordsIn : ${c}) -> ${wt(t)} {
    var coords = coordsIn;
    ${m}
    return ${wt(t)}(${r}[getIndexFromCoords${b}(${g}, ${x})${t===1?"":` / ${t}`}]);
  }
`}function lpe(n,e,t,s){let r=ape(n,t);return n.shape.length<=e.length&&(r+=ope(n,e,t,s)),r}function upe(n,e){const{x:t,y:s=[],z:r=[]}=e,i=n.length,a=t.length+s.length+r.length;if(a!==i)return"";if(t.length===i)return`fn getOutputCoords() -> ${Ln(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let o="";const u=[t,s,r];for(let m=0;m<u.length;m++){const g=u[m];if(g.length!==0)if(g.length===1)o+=`let d${g[0]} = i32(globalId[${m}]);`;else{const x=epe(g,"uniforms.outShape");o+=`var index${m} = i32(globalId[${m}]);`;for(let b=0;b<x.length;b++)o+=`let d${g[b]} = index${m} / ${x[b]};`,b===x.length-1?o+=`let d${g[b+1]} = index${m} - d${g[b]} * ${x[b]};`:o+=`index${m} = index${m} - d${g[b]} * ${x[b]};`}}const c=[];for(let m=0;m<a;m++)c.push(`d${m}`);const d=Ln(a);let p=`fn getOutputCoords() -> ${d} {
  ${o}
`;return c.length===0?p+=`return ${d}(0); }`:p+=`return ${d}(${c.join(",")}); }`,p}function cpe(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:B(!1,()=>`Unsupported ${n}D shape`);break}return e}function Fz(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function pu(n,e=1){if(n==="float32")return wt(e,"f32");if(n==="int32"||n==="bool")return wt(e,"i32");throw new Error(`type ${n} is not supported.`)}function hpe(n,e,t){const s=n.length,r=pu(e,t);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${wt(t)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${wt(t,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const a=["d0","d1","d2","d3","d4","d5"].slice(0,s),o=Ln(s);i+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : ${wt(t)}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${a.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : ${wt(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return i}function dpe(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,r,i)=>`vec${r}, @align(16) ${i}`),n}function OE(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}const vu=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function Le(n,e,t=[1,1,1],s=[1,1,1]){const[r,i,a]=[Math.ceil(vu(n.x.map(o=>e[o]))/(t[0]*s[0])),n.y?Math.ceil(vu(n.y.map(o=>e[o]))/(t[1]*s[1])):1,n.z?Math.ceil(vu(n.z.map(o=>e[o]))/(t[2]*s[2])):1];return[r,i,a]}function ppe(n,e,t,s=!1){const r=[8,8,1],i=[4,4,1];return s||(n<=8&&(i[1]=1),e<=16&&t<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function zz(n,e,t=!1){if(t)return[8,8,1];const s=vu(n.x.map(i=>e[i])),r=vu(n.y.map(i=>e[i]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function Lz(n,e,t=!1){if(t)return[4,4,1];const s=vu(n.x.map(i=>e[i])),r=vu(n.y.map(i=>e[i]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function We(n){return{x:n.map((e,t)=>t)}}function FE(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function Mz(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function Pz(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var da;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(da||(da={}));const fpe=fe().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),mpe=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,r=e.dispatch;if(r.every(a=>a<=t))return r;B(r[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(r[0]));return i>t?(i=Math.ceil(Math.cbrt(r[0])),B(i<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class Md extends Fx{nextDataId(){return Md.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!Mz())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new Qde(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Zde(this.device),this.textureManager=new Jde(this.device),this.tensorMap=new Q2(this,Gs()),fe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:t,values:e,refCount:1}),r}move(e,t,s,r,i){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:s,values:t,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if(fe().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),fe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(B(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const b=this.readSync(r.real.dataId),v=this.readSync(r.imag.dataId),w=zy(Xi(b,v).buffer,"float32");return this.convertAndCacheOnCPU(e,w),w}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],a=t.resource,o=a.size;B(o%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=o/4,c=new ArrayBuffer(o),d=256,p=256,m=i.map(b=>new OffscreenCanvas(d,p)),g=new OffscreenCanvas(d,p);this.endComputePassEncoder(),m.map((b,v)=>{const w=b.getContext("webgpu");return w.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[v]}),w.getCurrentTexture()}).map((b,v)=>{const w=d*4,N=(L,z,M)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:a,bytesPerRow:w,offset:M},{texture:b},{width:L,height:z}),this.submitQueue();const O=g.getContext("2d",{willReadFrequently:!0});O.clearRect(0,0,L,z),O.drawImage(m[v],0,0);const H=O.getImageData(0,0,L,z).data,X=i[v],te=new Uint8ClampedArray(c,M,L*z*4);for(let Z=0;Z<te.length;Z+=4)if(X==="premultiplied")te[Z+3]=H[Z+3];else{const W=H[Z];te[Z]=H[Z+2],te[Z+1]=H[Z+1],te[Z+2]=W}},I=Math.floor(u/(d*p));let $=d,E=p,D=0;for(let L=0;L<I;L++)N($,E,D),D+=d*p*4;const F=u%(d*p);E=Math.floor(F/d),E>0&&(N($,E,D),D+=E*(d*4)),$=F%d,$>0&&N($,1,D)});const x=zy(c,t.dtype);return this.convertAndCacheOnCPU(e,x),x}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let r;if(t.dtype==="complex64"){const i=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=i[0],o=i[1];r=Xi(a,o)}else{const i=await this.getBufferData(t.resource);r=zy(i,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,s=e.usage,r=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,s){let r=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const a=this.tensorMap.get(i),o=FE(a.dtype)*ce(a.shape);if(e.buffer.size<o)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(r=this.copyBuffer(r)),a.resource=r,Gs().makeTensorFromDataId(i,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:r,shape:i,resource:a}=t;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=a,u=o.size,c=o.usage,d=this.bufferManager.acquireBuffer(u,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,d,0,u),this.submitQueue();const p=this.makeTensorInfo(i,r),m=Gs().makeTensorFromTensorInfo(p),g=this.tensorMap.get(p.dataId);return g.resource=d,{tensorRef:m,buffer:d}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Hi(r));return ft(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=lo(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),a=lo(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(i);return o.kernelMs=FR(u),o.getExtraProfileInfo=()=>u.map((c,d)=>({name:a[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&Ih(s[0])&&(s=s.map(i=>ro(i))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=FE(t.dtype)*ce(t.shape);let r;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(r=this.bufferManager.acquireBuffer(s,i,!0),r.mapState==="unmapped"){const a=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),o=a.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),a.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,r,0,s),this.stagingPendingDisposal.push(a)}else{const a=r.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),r.unmap()}t.values=null}else r=this.bufferManager.acquireBuffer(s,i);t.resource=r}makeUniforms(e){let t=0,s=0;const r=[];let i=1;e.forEach(u=>{u.data.length===0&&(u.data=[1]);let c;switch(u.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:B(!1,()=>`Unsupported ${u.data.length}D shape`)}(s===5||s===6)&&(c=16),c>i&&(i=c),t=Math.ceil(t/c)*c,s=u.data.length,r.push(t),t+=u.data.length*4}),t=Math.ceil(t/i)*i;const a=new ArrayBuffer(t);e.forEach((u,c)=>{const d=r[c];u.type==="int32"?new Int32Array(a,d,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(a,d,u.data.length).set(u.data):new Float32Array(a,d,u.data.length).set(u.data)});const o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,a,0,t),this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,t,s,r,i){if(i||(i=this.makeTensorInfo(e.outputShape,s)),ce(i.shape)===0)return this.tensorMap.get(i.dataId).values=ss(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=mpe(this.device,e);const a=t.map((u,c)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:e.variableNames[c]}});e.shaderKey=rpe(e,a,i);const o=fe().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=tpe(this.device,e,a,i,o)),e.pipeline=this.pipelineCache[e.shaderKey],o||this.recordAndSubmit(e,i,t,r),i}recordAndSubmit(e,t,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],a=[];const o="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=s.concat(t).map(g=>g.shape);const m="int32";a.map(g=>{i.push({type:m,data:g});const x=Ze(g);i.push({type:m,data:x})})}else{const m=Ze(t.shape);i.push({type:o,data:m})}if(e.size){const m=ce(e.outputShape);i.push({type:o,data:[e.outputComponent?m/e.outputComponent:m]})}r&&(i=[...i,...r]);const u=[this.tensorToBinding(t),...s.map(m=>this.tensorToBinding(m)),this.makeUniforms(i)];s.forEach(m=>{this.commandQueueOwnedIds.add(m.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:u.map((m,g)=>({binding:g,resource:m}))}),d=this.activeTimers!=null;this.ensureCommandEncoderReady();const p={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),p.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(p)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(p)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(d||fe().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Sh.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=fpe){return fe().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&ce(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Md.nextDataId=0;Mz()&&fS("webgpu",async()=>{const n={powerPreference:fe().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const r=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(t),a="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Md(i,a)},3);var ht;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(ht||(ht={}));const gpe="let resultTemp = a + b;",ype="let resultTemp = atan2(a, b);",xpe="let resultTemp = areal * breal - aimag * bimag;",bpe="let resultTemp = areal * bimag + aimag * breal;",vpe="let resultTemp = a / b;",wpe="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Spe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,Cpe=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,Npe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,kpe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,$pe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,Ipe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,Tpe="return f32(a >= 1.0 && b >= 1.0);",Epe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Rpe="return f32(a >= 1.0 || b >= 1.0);",Ape=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,Dpe="let resultTemp = max(a, b);",_pe="let resultTemp = min(a, b);",Ope=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,Fpe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,zpe="let resultTemp = a * b;",Lpe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,Mpe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,Ppe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,Bpe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,Vpe="if (a < 0.0) { return b * a; }  return a;",Upe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Wpe="let resultTemp = (a - b) * (a - b);",Gpe="let resultTemp = a - b;";function KC(n,e){let t;do{switch(n){case ht.ATAN2:t=ype;break;case ht.MAX:t=Dpe;break;case ht.MIN:t=_pe;break;case ht.MOD:t=e?Fpe:Ope;break;case ht.NOT_EQUAL:t=e?Mpe:Lpe;break;case ht.POW:t=e?Bpe:Ppe;break;default:continue}let s,r,i;return e?(s="isnanVec4",r="vec4<f32>",i="vec4<bool>"):(s="isnan",r="f32",i="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case ht.ADD:t=gpe;break;case ht.COMPLEX_MULTIPLY_IMAG:t=bpe;break;case ht.COMPLEX_MULTIPLY_REAL:t=xpe;break;case ht.DIV:t=vpe;break;case ht.ELU_DER:t=wpe;break;case ht.EQUAL:t=Spe;break;case ht.FLOOR_DIV:t=Cpe;break;case ht.GREATER:t=Npe;break;case ht.GREATER_EQUAL:t=kpe;break;case ht.LESS:t=$pe;break;case ht.LESS_EQUAL:t=Ipe;break;case ht.LOGICAL_AND:return e?Epe:Tpe;case ht.LOGICAL_OR:return e?Ape:Rpe;case ht.MUL:t=zpe;break;case ht.PRELU:return e?Upe:Vpe;case ht.SQUARED_DIFFERENCE:t=Wpe;break;case ht.SUB:t=Gpe;break}return`
    ${t}
    return resultTemp;
  `}var Oe;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(Oe||(Oe={}));const Hpe="return abs(a);",jpe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,qpe=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,Xpe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,Kpe="return asinh(a);",Ype=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,Qpe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,Zpe="return ceil(a);",Jpe="return cos(a);",efe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,tfe="return exp(a) - 1.0;",nfe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",sfe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,rfe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${fb};
  let a1 = ${mb};
  let a2 = ${gb};
  let a3 = ${yb};
  let a4 = ${xb};
  let a5 = ${bb};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,ife="return exp(a);",afe="return floor(a);",ofe="return f32(!isnan(a) && !isinf(a));",lfe="return f32(isinf(a));",ufe="return f32(isnan(a));",cfe="return a;",hfe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,dfe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,pfe="return f32(!(a >= 1.0));",ffe="return -a;",mfe="if (a < 0.0) { return uniforms.alpha * a; } return a;",gfe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,yfe="return 1.0 / a;",xfe="return select(a, 0.0, a < 0.0);",bfe="return clamp(a, 0.0, 6.0);",vfe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",wfe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,Sfe="return round(a);",Cfe="return inverseSqrt(a);",Nfe=`
  if (a >= 0.0) {
    return ${Lm} * a;
  } else {
    return ${zm} * (exp(a) - 1.0);
  }
`,kfe="return 1.0 / (1.0 + exp(-1.0 * a));",$fe="return sign(a);",Ife="return sin(a);",Tfe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Efe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,Rfe="return sqrt(a);",Afe="return a * a;",Dfe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,_fe="return tan(a);",Ofe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Ffe="return f32(i32((a)));";function lu(n,e){switch(n){case Oe.ABS:return Hpe;case Oe.ACOS:return jpe;case Oe.ACOSH:return qpe;case Oe.ASIN:return Xpe;case Oe.ASINH:return Kpe;case Oe.ATAN:return Ype;case Oe.ATANH:return Qpe;case Oe.COS:return Jpe;case Oe.COSH:return efe;case Oe.CEIL:return Zpe;case Oe.ELU:return e?sfe:nfe;case Oe.ERF:return rfe;case Oe.EXP:return ife;case Oe.EXPM1:return tfe;case Oe.FLOOR:return afe;case Oe.IS_FINITE:return ofe;case Oe.IS_INF:return lfe;case Oe.IS_NAN:return ufe;case Oe.LINEAR:return cfe;case Oe.LOG:return hfe;case Oe.LOG1P:return dfe;case Oe.LOGICAL_NOT:return pfe;case Oe.NEG:return ffe;case Oe.LEAKYRELU:return e?gfe:mfe;case Oe.RECIPROCAL:return yfe;case Oe.RELU:return e?wfe:xfe;case Oe.RELU6:return e?vfe:bfe;case Oe.ROUND:return Sfe;case Oe.RSQRT:return Cfe;case Oe.SELU:return Nfe;case Oe.SIGMOID:return kfe;case Oe.SIGN:return $fe;case Oe.SIN:return Ife;case Oe.SINH:return Tfe;case Oe.SOFTPLUS:return Efe;case Oe.SQRT:return Rfe;case Oe.SQUARE:return Afe;case Oe.STEP:return Dfe;case Oe.TAN:return _fe;case Oe.TANH:return Ofe;case Oe.TO_INT:return Ffe;default:throw new Error(`BinaryType ${n} is not implemented!`)}}function go(n,e=!1,t=!1,s=3){if(n===null)return"";let r="";if(n==="linear")r=lu(Oe.LINEAR);else if(n==="relu")r=lu(Oe.RELU,t);else if(n==="elu")r=lu(Oe.ELU,t);else if(n==="relu6")r=lu(Oe.RELU6,t);else if(n==="prelu")r=KC(ht.PRELU,t);else if(n==="sigmoid")r=lu(Oe.SIGMOID,t);else if(n==="leakyrelu")r=lu(Oe.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const a=wt(t?4:1);let o="";return e?o=`
      fn activation(a : ${a}, coords : vec${s}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:o=`
      fn activation(a : ${a}, coords : vec${s}<i32>) -> ${a} {
        ${r}
      }`,o}function Zu(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}function Bz(n,e,t=!1,s=!1,r=!1,i=1){B(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const a=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,o=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${wt(i)} {
    var value = ${wt(i)}(0.0);
    ${t&&r?a:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${a}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${wt(i)} {
    var value = ${wt(i)}(0.0);
    ${o}
    return value;
  }
  `}function YC(n,e,t,s,r=!1,i=!1,a=!1,o=1){return`
  ${Bz(t,s,r,i,a,o)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${wt(o)}) {
    ${r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Zu(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const zfe=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,Lfe=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",i="";for(let a=0;a<e;a++)r+=`let BCached${a} = mm_Bsub[k * ${e} + ${a}][tileCol];`,i+=`acc[i] = fma(BCached${a}, vec4<f32>(ACached[${a}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${r}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function Gb(n,e,t=!1,s=32,r=!1,i=32,a=!1){const o=e[1]*n[1],u=e[0]*n[0],c=t?o:s,d=t?s:o,p=c/e[0],m=s/e[1],g=n[1],x=n[0];return B((t&&p===4&&n[1]===4||!t&&(p===3||p===4))&&c%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${p} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${p} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${c/p}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/n[0]}>, ${s}>;

  ${ze()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${g};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${g};
    let globalCol = i32(globalId.x) * ${x};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${o};

    let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${m};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${zfe(t,p)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${Lfe(t,p,g,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const zE=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Mfe=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Hb(n,e,t=!1,s=32,r=!1,i=32,a=!1,o=!1){const u=n[1]*e[1],c=n[0]*e[0],d=t?u:s,p=t?s:u;B(p%e[1]===0&&d%e[0]===0&&s%e[1]===0,()=>`tileAHight ${p} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const m=p/e[1],g=d/e[0],x=s/e[1],b=n[1],v=n[0],w=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
            ${zE(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${v}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${v}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${b}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${v}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${b}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${b};
  let tileCol = i32(localId.x) * ${v};

  let globalRow = i32(globalId.y) * ${b};
  let globalCol = i32(globalId.x) * ${v};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${m};
  let tileColA = i32(localId.x) * ${g};
  let tileRowB = i32(localId.y) * ${x};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${zE(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${x}; innerRow++) {
      for (var innerCol = 0; innerCol < ${v}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${v}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${v}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${b}; innerRow++) {
        ${Mfe(t)}
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${b}; innerRow++) {
    for (var innerCol = 0; innerCol < ${v}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${p}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${s}>;

    ${ze()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(i/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${v}>, ${b}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${b}; innerRow++) {
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${w}
    }
  `}const Pfe=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function Bfe(n,e=!1){B(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${ze()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Pfe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class Vfe{constructor(e,t,s=!1,r=!1,i=null,a=null,o=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=s?e[1]:e[2];if(this.isVec4=(c%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const m=ppe(t[1],c,t[2],s);this.workgroupSize=m.workgroupSize,this.elementsPerThread=m.elementsPerThread}this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=i!=null,p=o!=null;d&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=s,this.transposeB=r,this.addBias=d,this.activation=a,this.hasPreluActivationWeights=p,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const a=e%r===0,o=t%i===0,u=s%this.tileInner===0;return[a,o,u]}getUserCode(){return`
      ${go(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${YC(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Gb(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?Bfe(this.workgroupSize,this.transposeA):Hb(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}function Ufe(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${ze()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class Wfe{constructor(e,t=!1,s=!1,r=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=r!=null,u=a!=null;o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${go(this.activation,this.hasPreluActivationWeights)}
      ${YC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Ufe(this.workgroupSize[0])}
    `}}function Gfe(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${ze()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class Hfe{constructor(e,t,s,r=!1,i=!1,a=null,o=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const c=a!=null;c&&this.variableNames.push("bias");const d=u!=null;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=c,this.activation=o,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`
      ${go(this.activation,this.hasPreluActivationWeights)}
      ${YC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Gfe(this.workgroupSize)}
    `}}class jfe{constructor(e,t,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,B(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Le(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${Bz(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${wt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Rl("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?Gb(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Hb(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class qfe{constructor(e,t=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${go(this.activation,this.hasPreluActivationWeights)}
    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Zu(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}class Xfe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}function ur(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||Mu(r),i==="string"){const a=En(i,ce(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new Xfe(s),o=[{type:"float32",data:[r]}];return e.runWebGPUProgram(a,[],i,o)}}const Kfe={kernelName:s0,backendName:"webgpu",kernelFunc:ur};function Xe(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:r}=t,i=ce(s.shape),a=J2(r,i),o=ce(a);return B(i===o,()=>`The new shape (${a}) has ${o} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:a,dtype:s.dtype}}const Yfe={kernelName:mm,backendName:"webgpu",kernelFunc:Xe};function jb({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const c=n.shape.length,d=e.shape.length,p=t?n.shape[c-2]:n.shape[c-1],m=s?e.shape[d-1]:e.shape[d-2],g=t?n.shape[c-1]:n.shape[c-2],x=s?e.shape[d-2]:e.shape[d-1],b=n.shape.slice(0,-2),v=e.shape.slice(0,-2),w=ce(b),N=ce(v),$=it(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,x]);B(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[w,p,g]:[w,g,p],D=s?[N,x,m]:[N,m,x],F=Xe({inputs:{x:n},backend:r,attrs:{shape:E}}),L=Xe({inputs:{x:e},backend:r,attrs:{shape:D}}),z=[F,L],M=Math.max(w,N),O=[F,L],H=[{type:"int32",data:[g]},{type:"int32",data:[x]},{type:"int32",data:[p]}];let X,te;const Z=[M,g,x];let W=fe().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(W<0){const ie=fe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),de=ie>0?ie:r.thresholdToIncreaseWorkgroups,ge=M*Math.ceil(g/32)*Math.ceil(x/32);ge<=de||g<=8&&ge<=de*2?M*g*x<=128?W=da.MatMulReduceProgram:M===1&&m>=2e3?W=da.MatMulSplitKProgram:W=da.MatMulSmallOutputSizeProgram:W=da.MatMulPackedProgram}switch(W){case da.MatMulReduceProgram:X=new Wfe(Z,t,s,i,u,a);break;case da.MatMulSplitKProgram:{if(te=ur({backend:r,attrs:{shape:Z,value:0,dtype:n.dtype}}),X=new jfe(Z,m,t,s),i||u){te=r.runWebGPUProgram(X,O,n.dtype,H,te);const de=new qfe(te.shape,i,u,a);let ge=null;const G=[te];i&&G.push(i),a&&G.push(a),u==="leakyrelu"&&(ge=[{type:"float32",data:[o]}],de.uniforms+=" alpha : f32,");const re=r.runWebGPUProgram(de,G,te.dtype,ge);z.push(te);const pe=Xe({inputs:{x:re},backend:r,attrs:{shape:$}});z.push(re);for(const ve of z)r.disposeData(ve.dataId);return pe}break}case da.MatMulSmallOutputSizeProgram:X=new Hfe(E,D,Z,t,s,i,u,a);break;case da.MatMulPackedProgram:const ie=r.adapterInfo.isIntel();X=new Vfe(E,Z,t,s,i,u,a,ie);break;default:throw new Error(`Unsupported MatMulProgramType ${W}.`)}i&&O.push(i),a&&O.push(a),u==="leakyrelu"&&(H.push({type:"float32",data:[o]}),X.uniforms+=" alpha : f32,"),te=r.runWebGPUProgram(X,O,n.dtype,H,te);const ee=Xe({inputs:{x:te},backend:r,attrs:{shape:$}});z.push(te);for(const ie of z)r.disposeData(ie.dataId);return ee}function Qfe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=s;return jb({a:r,b:i,transposeA:u,transposeB:c,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:p,activation:d})}const Zfe={kernelName:rf,backendName:"webgpu",kernelFunc:Qfe};class LE{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=it(t,s),this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${KC(this.op,!1)}
      }

      ${ze("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}class Ix{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=it(t,s),this.dispatchLayout=We(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=t.length>0&&t[t.length-1]%4===0,i=s.length>0&&s[s.length-1]%4===0;r&&i?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(OI(s)||s[s.length-1]===1)||i&&(OI(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${KC(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ze("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${ze("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}function Ar(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const Jfe={kernelName:Kh,backendName:"webgpu",kernelFunc:Ar};function Ju(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.tensorMap.get(i.dataId),o=Ar({inputs:{x:s},backend:t}),u=Ar({inputs:{x:r},backend:t});return a.complexTensorInfos={real:o,imag:u},i}const eme={kernelName:Wx,backendName:"webgpu",kernelFunc:Ju};class Pd{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${lu(this.op,!1)}
      }
      ${ze("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}function Pt({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:r})=>{const{x:i}=s,a=r,o=t||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){const c=a.tensorMap.get(i.dataId),d=e(c.values,o);return a.makeTensorInfo(i.shape,o,d)}const u=new Pd(i.shape,n);return a.runWebGPUProgram(u,[i],o)}}function xs({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:r,backend:i})=>{const{a,b:o}=r,u=i;if(t&&a.dtype==="complex64"){const p=u.tensorMap.get(a.dataId),m=u.tensorMap.get(o.dataId);let g,x;if(n!==ht.MUL)[g,x]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{const[w,N]=v,I={dataId:w.dataId,dtype:w.dtype,shape:a.shape},$={dataId:N.dataId,dtype:N.dtype,shape:o.shape},E=new Ix(n,a.shape,o.shape);return u.runWebGPUProgram(E,[I,$],ys(w.dtype,N.dtype))});else{const v=new LE(ht.COMPLEX_MULTIPLY_REAL,a.shape,o.shape),w=new LE(ht.COMPLEX_MULTIPLY_IMAG,a.shape,o.shape),N=[{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:o.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:o.shape}];g=u.runWebGPUProgram(v,N,"float32"),x=u.runWebGPUProgram(w,N,"float32")}const b=Ju({inputs:{real:g,imag:x},backend:u});return u.disposeData(g.dataId),u.disposeData(x.dataId),b}const c=s||ys(a.dtype,o.dtype);if((a.dtype==="string"||o.dtype==="string"||u.shouldExecuteOnCPU([a,o]))&&e!=null){const p=u.tensorMap.get(a.dataId).values,m=u.tensorMap.get(o.dataId).values,g=a.dtype==="string"?Ki(p):p,x=a.dtype==="string"?Ki(m):m,[b,v]=e(a.shape,o.shape,g,x,c);return u.makeTensorInfo(v,c,b)}const d=new Ix(n,a.shape,o.shape);return u.runWebGPUProgram(d,[a,o],c)}}const{addImpl:tme,castImpl:nme,ceilImpl:sme,concatImpl:rme,equalImpl:ime,expImpl:ame,expm1Impl:ome,floorImpl:lme,floorDivImpl:ume,gatherNdImpl:cme,gatherV2Impl:hme,greaterEqualImpl:dme,greaterImpl:pme,lessEqualImpl:fme,lessImpl:mme,logImpl:gme,maxImpl:yme,maximumImpl:xme,minimumImpl:bme,multiplyImpl:vme,negImpl:wme,notEqualImpl:Sme,prodImpl:Cme,rangeImpl:Nme,rsqrtImpl:kme,scatterImpl:$me,simpleAbsImpl:Ime,sliceImpl:Tme,stridedSliceImpl:Eme,stringNGramsImpl:Rme,subImpl:Ame,tileImpl:Dme,topKImpl:_me,transposeImpl:Ome}=IF;const Fme=Pt({opType:Oe.ABS,cpuKernelImpl:Ime}),zme={kernelName:If,backendName:"webgpu",kernelFunc:Fme};const Lme=Pt({opType:Oe.ACOS}),Mme={kernelName:Eh,backendName:"webgpu",kernelFunc:Lme};const Pme=Pt({opType:Oe.ACOSH}),Bme={kernelName:Rh,backendName:"webgpu",kernelFunc:Pme};const Vme=xs({opType:ht.ADD,cpuKernelImpl:tme,supportsComplex:!0}),Ume={kernelName:Pu,backendName:"webgpu",kernelFunc:Vme};class Wme{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const t=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${ze("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}function Gme(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Ar({inputs:{x:s[0]},backend:t});const r=s.map(o=>o.dtype).reduce((o,u)=>ys(o,u)),i=s.map(o=>o.shape),a=new Wme(i);return t.runWebGPUProgram(a,s,r)}const Hme={kernelName:Tf,backendName:"webgpu",kernelFunc:Gme};class jme{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){B(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${ze()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}class qme{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Ln(this.outputShape.length),t=Vz(this.newDim);return`
      ${ze("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function Vz(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${oo(s)}`;return t.join()}function Na(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,o=r.shape.length,u=new Array(o);for(let d=0;d<u.length;d++)u[d]=r.shape[i[d]];if(t.shouldExecuteOnCPU([r])){const p=a.tensorMap.get(r.dataId).values,m=Ome(p,r.shape,r.dtype,i,u);return t.makeTensorInfo(u,r.dtype,m)}if(r.shape.length===2&&xt(i,[1,0])){const d=new jme(r.shape,i);return a.runWebGPUProgram(d,[r],r.dtype)}const c=new qme(r.shape,i);return a.runWebGPUProgram(c,[r],r.dtype)}const Xme={kernelName:yu,backendName:"webgpu",kernelFunc:Na};class Kme{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=Mn(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ze("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}}const Yme={mean:"float32",all:"bool",any:"bool"};function ec(n,e,t,s,r){const i=n.shape.length,a=[],o=gt(e,n.shape);let u=o;const c=sn(u,i);let d=n;c!=null&&(d=Na({inputs:{x:n},attrs:{perm:c},backend:r}),u=mn(u.length,i),a.push(d)),Hn(s,u,i);const[p,m]=Mn(d.shape,u);let g=p;t&&(g=Dn(p,o));let x;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([d])){const b=r.tensorMap.get(d.dataId).values;switch(s){case"max":const v=yme(b,ce(m),g,n.dtype);x=r.makeTensorInfo(g,n.dtype,v);break;case"prod":const{outVals:w,outShape:N,outDtype:I}=Cme(d.shape,d.dtype,b,u);x=r.makeTensorInfo(N,I,w);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const b=ce(m),w=ce(d.shape)/b,N={windowSize:b,inSize:b,batchSize:w,outSize:1},I=Yme[s]||O0(n.dtype),$=[{type:"int32",data:[b]}],E=new Kme(N,s,r.device.limits.maxComputeWorkgroupSizeX),D=r.runWebGPUProgram(E,[d],I,$);a.push(D),x=Xe({inputs:{x:D},attrs:{shape:g},backend:r})}return a.forEach(b=>r.disposeData(b.dataId)),x}function Qme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:a}=s;return ec(r,a,i,"all",t)}const Zme={kernelName:zx,backendName:"webgpu",kernelFunc:Qme};function Jme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:a}=s;return ec(r,a,i,"any",t)}const ege={kernelName:Lx,backendName:"webgpu",kernelFunc:Jme};class Uz{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op=s==="min"?"<":">";const[i,a]=Mn(e,r);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=We(this.outputShape),ce(a)<32?(this.type="plain",this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Le(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${oo(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)r+=`outputCoords.${oo(i)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${ze("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${ze("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}function tge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=gt(i,r.shape);const o=sn(a,r.shape.length);let u=r;const c=[];o!=null&&(u=Na({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(u),a=mn(a.length,u.shape.length)),Hn("argMax",[a[0]],u.shape.length);const d=new Uz(u.shape,a[0],"max"),p=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],m=t.runWebGPUProgram(d,[u],"int32",p);return c.forEach(g=>t.disposeData(g.dataId)),m}const nge={kernelName:Ef,backendName:"webgpu",kernelFunc:tge};function sge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=gt(i,r.shape);const o=sn(a,r.shape.length);let u=r;const c=[];o!=null&&(u=Na({inputs:{x:r},backend:t,attrs:{perm:o}}),c.push(u),a=mn(a.length,u.shape.length)),Hn("argMin",[a[0]],u.shape.length);const d=new Uz(u.shape,a[0],"min"),p=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],m=t.runWebGPUProgram(d,[u],"int32",p);return c.forEach(g=>t.disposeData(g.dataId)),m}const rge={kernelName:Rf,backendName:"webgpu",kernelFunc:sge};const ige=Pt({opType:Oe.ASIN}),age={kernelName:Ah,backendName:"webgpu",kernelFunc:ige};const oge=Pt({opType:Oe.ASINH}),lge={kernelName:Dh,backendName:"webgpu",kernelFunc:oge};const uge=Pt({opType:Oe.ATAN}),cge={kernelName:_h,backendName:"webgpu",kernelFunc:uge};const hge=xs({opType:ht.ATAN2}),dge={kernelName:Fh,backendName:"webgpu",kernelFunc:hge};const pge=Pt({opType:Oe.ATANH}),fge={kernelName:Oh,backendName:"webgpu",kernelFunc:pge};class mge{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}class Nf{constructor(e,t,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class QC{constructor(e,t,s=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${s}_${r}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}function Wz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s;return ec(r,i,a,"max",t)}const gge={kernelName:tm,backendName:"webgpu",kernelFunc:Wz};function Gz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:i,axis:a}=s;return ec(r,a,i,"mean",t)}const yge={kernelName:rm,backendName:"webgpu",kernelFunc:Gz};function Hz(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&xt(e.inShape,e.outShape))return Ar({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const a=n.shape.length,o=Xe({inputs:{x:n},backend:s,attrs:{shape:[n.shape[a-3]*n.shape[a-2],n.shape[a-1]]}});let u;t==="avg"?u=Gz({inputs:{x:o},backend:s,attrs:{axis:0,keepDims:!1}}):(B(t==="max",()=>`Invalid pool type ${t}`),u=Wz({inputs:{x:o},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const c=Xe({inputs:{x:u},backend:s,attrs:{shape:e.outShape}});return s.disposeData(o.dataId),s.disposeData(u.dataId),c}let r;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?r=new mge(e):(t==="avg"?r=new Nf(e,"avg"):(B(t==="max",()=>`Invalid pool type ${t}`),r=new Nf(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(r,[n],n.dtype,i)}function xge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,d=zs(r.shape,i,a,1,o,u);return Hz(r,d,"avg",t)}const bge={kernelName:Af,backendName:"webgpu",kernelFunc:xge};function vge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:c}=s,d=[1,1,1],p=Qr(r.shape,i,a,d,o,c,u),m=new QC(p,"avg"),g=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];return t.runWebGPUProgram(m,[r],r.dtype,g)}const wge={kernelName:Df,backendName:"webgpu",kernelFunc:vge};class Sge{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Cge{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}function Nge(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:u,pad:c,dimRoundingMode:d}=s,p=Qr(a.shape,o,u,1,c,d),m=new Cge(p),g=1/(p.filterDepth*p.filterHeight*p.filterWidth),x=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[g]}];return t.runWebGPUProgram(m,[r],a.dtype,x)}const kge={kernelName:Px,backendName:"webgpu",kernelFunc:Nge};function $ge(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;Pz([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=s,d=zs(a.shape,o,u,1,c),p=new Sge(d),m=1/(d.filterHeight*d.filterWidth),g=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[m]}];return t.runWebGPUProgram(p,[r],a.dtype,g)}const Ige={kernelName:Mx,backendName:"webgpu",kernelFunc:$ge};function Tge(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return jb({a:r,b:i,transposeA:a,transposeB:o,backend:t})}const Ege={kernelName:_f,backendName:"webgpu",kernelFunc:Tge};class Rge{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ln(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ln(this.rank),t=Age(this.rank);let s;return this.start.length===1?s=this.outputShape.map((i,a)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((i,a)=>`sourceLoc.${B2[a]} = uniforms.start.${oo(a)} + coords.${B2[a]};`),`
      ${ze("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const B2=["x","y","z","w","u","v"];function Age(n){if(n===1)return"sourceLoc";if(n<=6)return B2.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}function Bd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[o,u]=Fm(r,i,a);if(ab(r,o,u),t.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=t.tensorMap.get(r.dataId),m=Tme(p.values,o,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,m)}if(ce(u)===0)return t.makeTensorInfo(u,r.dtype,[]);const c=new Rge(o,u),d=[{type:"int32",data:o}];return t.runWebGPUProgram(c,[r],r.dtype,d)}const Dge={kernelName:vm,backendName:"webgpu",kernelFunc:Bd};const _ge=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;B(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const o=i.reduce((N,I)=>N*I),u=Wu(r.shape,i,o),c=Gu(u.length,i.length),d=Hu(r.shape,i,o),p=db(a,i.length),m=pb(d,a,i.length),g=[],x=Xe({inputs:{x:r},backend:t,attrs:{shape:u}}),b=Na({inputs:{x},backend:t,attrs:{perm:c}}),v=Xe({inputs:{x:b},backend:t,attrs:{shape:d}}),w=Bd({inputs:{x:v},backend:t,attrs:{begin:p,size:m}});return g.push(x),g.push(b),g.push(v),g.forEach(N=>t.disposeData(N.dataId)),w},Oge={kernelName:Of,backendName:"webgpu",kernelFunc:_ge};const Fge=`
  fn bincount_write(index: i32, value: f32) {
    ${Rl("&result[index]","value","float32")}
  }
`,zge=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class jz{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?zge:Fge}
  ${ze("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}function Lge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=ce(r.shape),c=ce(i.shape)>0,d=[a],p=i.dtype,m=ur({backend:t,attrs:{shape:d,value:0,dtype:p}}),g=new jz([o],c),x=[{type:"int32",data:[a]}],b=c?[r,i]:[r];return t.runWebGPUProgram(g,b,p,x,m)}const Mge={kernelName:Bx,backendName:"webgpu",kernelFunc:Lge};class Pge{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${ze("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}function Bge(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e;if(t.shouldExecuteOnCPU([s,r])){const d=t.tensorMap.get(s.dataId),p=t.tensorMap.get(r.dataId),m=d.values,g=p.values,x=it(Array.from(m),Array.from(g));return t.makeTensorInfo([x.length],"int32",Int32Array.from(x))}const i=ce(s.shape),a=ce(r.shape),o=Math.max(i,a),u=new Pge(o),c=[{type:"int32",data:[i]},{type:"int32",data:[a]}];return t.runWebGPUProgram(u,[s,r],"int32",c)}const Vge={kernelName:Ux,backendName:"webgpu",kernelFunc:Bge};const qz=xs({opType:ht.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Sme}),Uge={kernelName:lm,backendName:"webgpu",kernelFunc:qz};function Zm(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return Ar({inputs:{x:r.complexTensorInfos.real},backend:t})}const Wge={kernelName:y0,backendName:"webgpu",kernelFunc:Zm};function Gge(n,e){const t=new Pd(n.shape,Oe.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function V2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Ar({inputs:{x:r},backend:t});const a=zn(r.shape),o=V2({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Ju({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeData(o.dataId),u}if(r.dtype==="complex64"){const a=Zm({inputs:{input:r},backend:t}),o=V2({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeData(a.dataId),o}if(!eS(r.dtype,i)){const a=Ar({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.tensorMap.get(r.dataId).values,[o,u,c]=nme(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,u,c)}if(i==="int32")return Gge(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",ss("bool",1)),u=qz({inputs:{a:r,b:a},backend:t});return t.disposeData(a.dataId),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Hge={kernelName:zh,backendName:"webgpu",kernelFunc:V2};const jge=Pt({opType:Oe.CEIL,cpuKernelImpl:sme}),qge={kernelName:Lh,backendName:"webgpu",kernelFunc:jge};class Xge{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ze("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}class Kge{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ze("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}function Yge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;const u=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return ce(r.shape)%4===0?o=new Xge(r.shape):o=new Kge(r.shape),t.runWebGPUProgram(o,[r],r.dtype,u)}const Qge={kernelName:Mh,backendName:"webgpu",kernelFunc:Yge};class Zge{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}function ME(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Jge(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.tensorMap.get(s.dataId),i=new Zge(s.shape),a=[ME(s,r.complexTensorInfos.real),ME(s,r.complexTensorInfos.imag)];return t.runWebGPUProgram(i,a,a[0].dtype)}const eye={kernelName:Ff,backendName:"webgpu",kernelFunc:Jge};class tye{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=lr(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${ze("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}function qb(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return Ar({inputs:{x:r.complexTensorInfos.imag},backend:t})}const nye={kernelName:o0,backendName:"webgpu",kernelFunc:qb};function Jp(n,e,t){const s=n[0].dtype;if(s==="complex64"){const x=n.map(I=>Zm({inputs:{input:I},backend:t})),b=n.map(I=>qb({inputs:{input:I},backend:t})),v=Jp(x,e,t),w=Jp(b,e,t),N=Ju({inputs:{real:v,imag:w},backend:t});return x.forEach(I=>t.disposeData(I.dataId)),b.forEach(I=>t.disposeData(I.dataId)),t.disposeData(v.dataId),t.disposeData(w.dataId),N}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const x=n.map(E=>{const F=[-1,ce(E.shape.slice(e))];return Xe({inputs:{x:E},backend:t,attrs:{shape:F}})}),b=x.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),v=lr(x.map(E=>E.shape),1),w=x[0].shape[0]===1,N=rme(b,v,s,w),I=lr(n.map(E=>E.shape),e),$=t.makeTensorInfo(I,s,N);return x.forEach(E=>t.disposeData(E.dataId)),$}const i=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const x=[];for(let v=0;v<n.length;v+=i){const w=n.slice(v,v+i);x.push(Jp(w,e,t))}const b=Jp(x,e,t);for(const v of x)t.disposeData(v.dataId);return b}const{tensors2D:a,outShape:o}=sye(n,e,t),u=a.map(x=>x.shape),c=new tye(u),d=[],p=new Array(u.length-1);if(p.length>0){p[0]=u[0][1],d.push({type:"int32",data:[p[0]]});for(let x=1;x<p.length;x++)p[x]=p[x-1]+u[x][1],d.push({type:"int32",data:[p[x]]})}const m=t.runWebGPUProgram(c,a,a[0].dtype,d);a.forEach(x=>t.disposeData(x.dataId));const g=Xe({inputs:{x:m},backend:t,attrs:{shape:o}});return t.disposeData(m.dataId),g}function sye(n,e,t){const s=lr(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Xe({inputs:{x:i},backend:t,attrs:{shape:[ce(i.shape.slice(0,e)),ce(i.shape.slice(e))]}})),outShape:s}}function Xz(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=gt(r,e[0].shape)[0],a=e.map(c=>c.shape);ub(a,i);const o=lr(e.map(c=>c.shape),i);if(ce(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(c=>ce(c.shape)>0);return u.length===1?Ar({inputs:{x:u[0]},backend:t}):Jp(u,i,t)}const rye={kernelName:zf,backendName:"webgpu",kernelFunc:Xz};function iye(n,e,t,s,r=!1,i=null,a=!1,o=4,u=4,c=4){const d=z=>{switch(z){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},p=z=>{switch(z){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},m=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,x=n?"uniforms.xShape[1]":"uniforms.xShape[2]",b=n?"uniforms.xShape[2]":"uniforms.xShape[3]",v=n?"row":"col",w=n?"col":"row",N=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${v} / outWidth;
      let outCol = ${v} % outWidth;

      let WRow = ${w} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${w} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${w} % inChannels;
      var resData = ${wt(o)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${x} && xCol >= 0 && xCol < ${b}) {
        ${m}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${d(o)}
      }
      return resData;`,I=n?e&&s?`
      ${N}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${N}
      }
      return ${wt(o)}(0.0);`:s&&t?`
      ${N}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${N}
      }
      return ${wt(o)}(0.0);`,$=`${p(u)}`,E=wt(c),D=wt(n?o:u),F=wt(n?u:o);return`
      ${go(i,a,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${D} {
        ${n?I:$}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${F} {
        ${n?$:I}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${E}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${Zu(r,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class aye{constructor(e,t,s,r,i=!1,a=null,o=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=zz(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Lz(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Gb(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Hb(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${iye(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}class oye{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${go(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Zu(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${ze("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}class lye{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${ze("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}function Tx(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function uye({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=t.dataFormat==="channelsLast",c=!u,d=!1,p=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",m=[];let g,x;if(p){const w=t.inHeight*t.inWidth*t.inChannels;g=Xe({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,w]}}),x=Xe({inputs:{x:e},backend:s,attrs:{shape:[1,w,t.outChannels]}})}else g=Xe({inputs:{x:n},backend:s,attrs:{shape:u?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),x=Xe({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(m.push(g),m.push(x),i!=null){const w=Tx(i.shape,u);w!=null&&(i=Xe({inputs:{x:i},backend:s,attrs:{shape:w}}),m.push(i))}if(r!=null){const w=Tx(r.shape,u);w!=null&&(r=Xe({inputs:{x:r},backend:s,attrs:{shape:w}}),m.push(r))}const b=jb({a:u?g:x,b:u?x:g,transposeA:c,transposeB:d,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),v=Xe({inputs:{x:b},backend:s,attrs:{shape:t.outShape}});m.push(b);for(const w of m)s.disposeData(w.dataId);return v}function cye({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:c,inChannels:d,strideWidth:p,strideHeight:m,padInfo:g,outWidth:x,outHeight:b,dilationWidth:v,dilationHeight:w,dataFormat:N}=t,I=N==="channelsLast",$=u*c*d,E=b*x,D=I?[t.batchSize,E,$]:[t.batchSize,$,E],F=new lye(D,I),L=[{type:"int32",data:[g.top,g.left]},{type:"int32",data:[m,p]},{type:"int32",data:[w,v]},{type:"int32",data:[x]},{type:"int32",data:[d*u]},{type:"int32",data:[d]}],z=s.runWebGPUProgram(F,[n],n.dtype,L),M=[];M.push(z);const O=Xe({inputs:{x:e},backend:s,attrs:{shape:[1,$,-1]}});if(M.push(O),i!=null){const W=Tx(i.shape,I);W!=null&&(i=Xe({inputs:{x:i},backend:s,attrs:{shape:W}}),M.push(i))}if(r!=null){const W=Tx(r.shape,I);W!=null&&(r=Xe({inputs:{x:r},backend:s,attrs:{shape:W}}),M.push(r))}const te=jb({a:I?z:O,b:I?O:z,transposeA:!I,transposeB:!1,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),Z=Xe({inputs:{x:te},backend:s,attrs:{shape:t.outShape}});M.push(te);for(const W of M)s.disposeData(W.dataId);return Z}function Kz({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=r!=null,c=i!=null,d=t.dataFormat==="channelsLast",p=d&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",m=fe().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!m&&(p||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return uye({x:n,filter:e,convInfo:t,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});const g=fe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),x=g>-1?g:s.thresholdToIncreaseWorkgroups,b=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(fe().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||b<=x)return cye({x:n,filter:e,convInfo:t,backend:s,bias:r,preluActivationWeights:i,leakyreluAlpha:a,activation:o});let v;const w=[t.padInfo.top,t.padInfo.left],N=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...w]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(m)v=new oye(t,u,o,c);else{const D=d?t.outHeight*t.outWidth:t.outChannels,F=d?t.outChannels:t.outHeight*t.outWidth,L=t.filterHeight*t.filterWidth*t.inChannels;N.push({type:"int32",data:[D]},{type:"int32",data:[F]},{type:"int32",data:[L]});const z=s.adapterInfo.isIntel();v=new aye(t,D,F,L,u,o,c,z)}const I=[],$=[n,e];u&&(!d&&r.shape.length===1&&(r=Xe({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),I.push(r)),$.push(r)),c&&(!d&&i.shape.length===1&&(i=Xe({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),I.push(i)),$.push(i)),o==="leakyrelu"&&(N.push({type:"float32",data:[a]}),v.uniforms+=" alpha : f32,");const E=s.runWebGPUProgram(v,$,n.dtype,N);for(const D of I)s.disposeData(D.dataId);return E}function hye(n){const{inputs:e,attrs:t,backend:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:u,dilations:c,dimRoundingMode:d}=t,p=Dr(u),m=fn(r.shape,i.shape,a,c,o,d,!1,p);return Kz({x:r,filter:i,convInfo:m,backend:s})}const dye={kernelName:Lf,backendName:"webgpu",kernelFunc:hye};class pye{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${ze()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${ze("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class fye{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${ze("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class mye{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${ze("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class gye{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${ze("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}function yye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:d}=s,p=Dr(u),m=fn(r.shape,d,a,1,o,c,!1,p),g=new fye(m),x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]},{type:"int32",data:[m.inHeight]},{type:"int32",data:[m.inWidth]}];return t.runWebGPUProgram(g,[r,i],r.dtype,x)}const xye={kernelName:Gx,backendName:"webgpu",kernelFunc:yye};function bye(n=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${wt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${wt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${wt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${wt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${wt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${wt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${wt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class vye{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,B(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=zz(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Lz(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Gb(this.elementsPerThread,this.workgroupSize):Hb(this.elementsPerThread,this.workgroupSize);return`
    ${bye(this.isVec4?4:1)}
    ${e}
    `}}function wye(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:u,dataFormat:c,dimRoundingMode:d}=s,p=Dr(c),m=fn(a,i.shape,o,1,u,d,!1,p),g=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.filterHeight-1-m.padInfo.top,m.filterWidth-1-m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize,m.outHeight,m.outWidth,m.outChannels]}];let x;if(fe().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||m.dataFormat!=="channelsLast")x=new pye(m);else{x=new vye(m);const b=m.inHeight*m.inWidth,v=m.inChannels,w=m.filterHeight*m.filterWidth*m.outChannels;g.push({type:"uint32",data:[b]},{type:"uint32",data:[v]},{type:"uint32",data:[w]})}return t.runWebGPUProgram(x,[r,i],"float32",g)}const Sye={kernelName:Mf,backendName:"webgpu",kernelFunc:wye};class Cye{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}function Nye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s,c=ea(r.shape,i.shape,a,u,o),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],p=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],m=new Cye(c),g=ys(r.dtype,i.dtype);return t.runWebGPUProgram(m,[r,i],g,p)}const kye={kernelName:Pf,backendName:"webgpu",kernelFunc:Nye};function $ye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:u}=s,c=ea(r.shape,u,a,1,o),d=new mye(c),p=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(d,[r,i],i.dtype,p)}const Iye={kernelName:Hx,backendName:"webgpu",kernelFunc:$ye};function Tye(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,pad:o,inputShape:u}=s,c=ea(u,i.shape,a,1,o),d=new gye(c),p=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(d,[r,i],r.dtype,p)}const Eye={kernelName:jx,backendName:"webgpu",kernelFunc:Tye};const Rye=Pt({opType:Oe.COS}),Aye={kernelName:Ph,backendName:"webgpu",kernelFunc:Rye};const Dye=Pt({opType:Oe.COSH}),_ye={kernelName:Bh,backendName:"webgpu",kernelFunc:Dye};class Oye{constructor(e,t,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,s[0],s[1],e],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,o,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${o};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}const Fye=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:u,extrapolationValue:c}=s,d=new Oye(r.shape[3],i.shape,o,u),p=[{type:"float32",data:[c]}];return t.runWebGPUProgram(d,[r,i,a],"float32",p)},zye={kernelName:Xx,backendName:"webgpu",kernelFunc:Fye};var kf;(function(n){n.Prod="*",n.Sum="+"})(kf||(kf={}));class PE{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===kf.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${BE(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?`end != ${r-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${ze("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${VE(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${a};
           ${VE(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${BE(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function BE(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function VE(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Yz(n,e,t,s,r,i){const a=e.shape.length,o=sn([s],a);let u=e;o!=null&&(u=Na({inputs:{x:e},backend:t,attrs:{perm:o}}));const c=mn(1,a)[0];if(c!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=u.shape[c];let p=Ar({inputs:{x:u},backend:t});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const g=new PE(n,u.shape,!1,i),x=p,b=[{type:"float32",data:[m]}];p=t.runWebGPUProgram(g,[p],p.dtype,b),t.disposeData(x.dataId)}if(r){const m=new PE(n,u.shape,r,i),g=p,x=[{type:"float32",data:[0]}];p=t.runWebGPUProgram(m,[p],p.dtype,x),t.disposeData(g.dataId)}if(o!=null){const m=$a(o),g=Na({inputs:{x:p},backend:t,attrs:{perm:m}});return t.disposeData(p.dataId),t.disposeData(u.dataId),g}return p}function Lye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return Yz(kf.Prod,r,t,i,a,o)}const Mye={kernelName:qx,backendName:"webgpu",kernelFunc:Lye};function Pye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return Yz(kf.Sum,r,t,i,a,o)}const Bye={kernelName:Bf,backendName:"webgpu",kernelFunc:Pye};function Vye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s,u=r.shape.length===1,d=ce(i.shape)>0,p=i.dtype,m=u?[r.shape[0]]:[r.shape[0],r.shape[1]],g=u?[a]:[r.shape[0],a],x=ur({backend:t,attrs:{shape:g,value:0,dtype:p}}),b=new jz(m,d,o),v=[{type:"int32",data:[a]}],w=d?[r,i]:[r];return t.runWebGPUProgram(b,w,p,v,x)}const Uye={kernelName:Kx,backendName:"webgpu",kernelFunc:Vye};class Wye{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function Gye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,o=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],c=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],p=u*i,m=c*i,g=d/(i*i),x=a==="NHWC"?[o,p,m,g]:[o,g,p,m],b=[{type:"int32",data:[i]}],v=new Wye(x,a);return t.runWebGPUProgram(v,[r],r.dtype,b)}const Hye={kernelName:Yx,backendName:"webgpu",kernelFunc:Gye};class jye{constructor(e,t,s,r=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${go(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${ze()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Zu(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}class Qz{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=We(i),this.dispatch=Le(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),B(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${go(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${ze("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Zu(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}class Zz{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${go(this.activation,this.hasPreluActivation,!1,4)}

      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Zu(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}function qye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:u,dilations:c,dimRoundingMode:d}=s,p=Dr(u);let m=c;m==null&&(m=[1,1]);const g=fn(r.shape,i.shape,a,m,o,d,!0,p),x=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}],b=g.dataFormat==="channelsLast";let v;return!b&&g.inHeight>16&&g.inWidth>16&&g.strideHeight===1&&g.strideWidth===1&&g.dilationWidth===1&&g.dilationHeight===1&&g.inChannels===g.outChannels?v=new jye(g.outShape,g.filterHeight,g.filterWidth):b&&g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(v=new Qz(g),x.push({type:"int32",data:[v.virtualWidth]})):(v=new Zz(g),x.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),t.runWebGPUProgram(v,[r,i],r.dtype,x)}const Xye={kernelName:Vf,backendName:"webgpu",kernelFunc:qye};class Kye{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Yye{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}function Qye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:c,filterShape:d}=s,p=fn(r.shape,d,a,o,u,c,!0),m=new Kye(p),g=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outChannels/p.inChannels]}];return t.runWebGPUProgram(m,[r,i],"float32",g)}const Zye={kernelName:Qx,backendName:"webgpu",kernelFunc:Qye};function Jye(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:c,inputShape:d}=s,p=fn(d,i.shape,a,o,u,c,!0),m=new Yye(p),g=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.outChannels/p.inChannels]}];return t.runWebGPUProgram(m,[r,i],r.dtype,g)}const exe={kernelName:Zx,backendName:"webgpu",kernelFunc:Jye};class txe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}function nxe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=ce(s.shape),a=Xe({inputs:{x:s},backend:t,attrs:{shape:[i]}}),o=new txe(i),u=t.runWebGPUProgram(o,[a],a.dtype),c=Xe({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeData(a.dataId),t.disposeData(u.dataId),c}const sxe={kernelName:Jx,backendName:"webgpu",kernelFunc:nxe};class rxe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${ze("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}function ixe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s,c=Nl(r.shape,i.shape,a,o,"NHWC",u),d=[c.padInfo.top,c.padInfo.left],p=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],m=new rxe(c);return t.runWebGPUProgram(m,[r,i],r.dtype,p)}const axe={kernelName:Uf,backendName:"webgpu",kernelFunc:ixe};class oxe{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=We(e.outShape),this.dispatch=Le(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${ze("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Rl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class lxe{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=We(e.outShape),this.dispatch=Le(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${ze("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Rl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}function uxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,dy:a}=e,{strides:o,pad:u,dilations:c}=s,d=Nl(r.shape,i.shape,o,u,"NHWC",c),p=i.dtype,m=new lxe(d,i.shape,p),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[ce(d.outShape)]}],x=ur({backend:t,attrs:{shape:i.shape,value:0,dtype:p}});return t.runWebGPUProgram(m,[r,i,a],p,g,x)}const cxe={kernelName:Jy,backendName:"webgpu",kernelFunc:uxe};function hxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,dy:a}=e,{strides:o,pad:u,dilations:c}=s,d=Nl(r.shape,i.shape,o,u,"NHWC",c),p=r.dtype,m=new oxe(d,p),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[ce(d.outShape)]}],x=ur({backend:t,attrs:{shape:d.inShape,value:0,dtype:p}});return t.runWebGPUProgram(m,[r,i,a],p,g,x)}const dxe={kernelName:Zy,backendName:"webgpu",kernelFunc:hxe};class pxe{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Sh.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${ze("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}function fxe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,[o,u]=r.shape.slice(0,2),{imageOptions:c}=a||{},d=c?.alpha||1,p=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",m=[o,u],g=new pxe(m,r.dtype,p);i.width=u,i.height=o;const x="webgpu";let b=i.getContext(x),v;b||(v=new OffscreenCanvas(u,o),b=v.getContext(x));const w=r.shape.length===3?r.shape[2]:1;b.configure({device:t.device,format:p,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const N="int32",I=t.makeTensorInfo(m,N),$=t.tensorMap.get(I.dataId);$.resource=b.getCurrentTexture(),$.external=!0;const E=[{type:"uint32",data:[w]},{type:"float32",data:[d]}];if(t.runWebGPUProgram(g,[r],N,E,I),v){const D=i.getContext("2d");if(!D)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");D.drawImage(v,0,0)}return t.disposeData(I.dataId),r}const mxe={kernelName:sS,backendName:"webgpu",kernelFunc:fxe};const Jz=xs({opType:ht.MUL,cpuKernelImpl:vme,supportsComplex:!0}),gxe={kernelName:rd,backendName:"webgpu",kernelFunc:Jz};function eL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return ec(r,i,a,"sum",t)}const yxe={kernelName:wm,backendName:"webgpu",kernelFunc:eL};function xxe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:u}=vb(r,i.length);Sb(a.length,u,i);const{path:c,steps:d}=Cb(o,u),p=d.length;let m=null,g=a.length;const x=[];for(let b=0;b<p;++b){for(const v of d[b]){const{permutationIndices:w,expandDims:N}=wb(g,u[v]);let I;Nb(w)?I=i[v]:(I=Na({inputs:{x:i[v]},backend:t,attrs:{perm:w}}),x.push(I));const $=I.shape.slice();for(let E=0;E<N.length;++E)$.splice(N[E],0,1);xt(I.shape,$)||(I=Xe({inputs:{x:I},backend:t,attrs:{shape:$}}),x.push(I)),m===null?m=I:(m=Jz({inputs:{a:I,b:m},backend:t}),x.push(m))}b<p-1&&(c[b]>=0&&(m=eL({inputs:{x:m},backend:t,attrs:{axis:c[b]-(a.length-g),keepDims:!1}}),x.push(m)),g--)}for(const b of x)b!==m&&t.disposeData(b.dataId);return m}const bxe={kernelName:e0,backendName:"webgpu",kernelFunc:xxe};const vxe=Pt({opType:Oe.ELU}),wxe={kernelName:Uh,backendName:"webgpu",kernelFunc:vxe};const Sxe=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=new Ix(ht.ELU_DER,s.shape,r.shape);return t.runWebGPUProgram(i,[s,r],s.dtype)},Cxe={kernelName:t0,backendName:"webgpu",kernelFunc:Sxe};const Nxe=xs({opType:ht.EQUAL,dtype:"bool",cpuKernelImpl:ime}),kxe={kernelName:Wf,backendName:"webgpu",kernelFunc:Nxe};const $xe=Pt({opType:Oe.ERF}),Ixe={kernelName:Wh,backendName:"webgpu",kernelFunc:$xe};const Txe=Pt({opType:Oe.EXP,cpuKernelImpl:ame,dtype:"float32"}),Exe={kernelName:Gh,backendName:"webgpu",kernelFunc:Txe};function U2(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,o=i.shape.slice();let u=r;return r<0&&(B(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),o.splice(u,0,1),Xe({inputs:{x:i},backend:s,attrs:{shape:o}})}const Rxe={kernelName:Gf,backendName:"webgpu",kernelFunc:U2};const Axe=Pt({opType:Oe.EXPM1,cpuKernelImpl:ome}),Dxe={kernelName:Hh,backendName:"webgpu",kernelFunc:Axe};class UE{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}function tL(n,e,t){const s=t.tensorMap.get(n.dataId),r=ce(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=[],u=Xe({inputs:{x:n},backend:t,attrs:{shape:[a,i]}});o.push(u);const c=u.shape,d=new UE("real",c),p=new UE("imag",c),m=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],g=e?2*Math.PI:-2*Math.PI,x=e?c[1]:1,b=[{type:"float32",data:[g]},{type:"float32",data:[x]}],v=t.runWebGPUProgram(d,m,"float32",b);o.push(v);const w=t.runWebGPUProgram(p,m,"float32",b);o.push(w);const N=Ju({inputs:{real:v,imag:w},backend:t});o.push(N);const I=Xe({inputs:{x:N},backend:t,attrs:{shape:n.shape}});return o.forEach($=>t.disposeData($.dataId)),I}function _xe(n){const{inputs:e,backend:t}=n,{input:s}=e;return tL(s,!1,t)}const Oxe={kernelName:n0,backendName:"webgpu",kernelFunc:_xe};class Fxe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}const zxe={kernelName:r0,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new Fxe(t.shape);return s.runWebGPUProgram(r,[t],t.dtype)}};const Lxe=Pt({opType:Oe.FLOOR,cpuKernelImpl:lme}),Mxe={kernelName:jh,backendName:"webgpu",kernelFunc:Lxe};const Pxe=xs({opType:ht.FLOOR_DIV,cpuKernelImpl:ume,dtype:"int32"}),Bxe={kernelName:qh,backendName:"webgpu",kernelFunc:Pxe};class Vxe{constructor(e,t,s=!1){this.pixelsOpType=Sh.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${ze("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}const Uxe={kernelName:ex,backendName:"webgpu",kernelFunc:Wxe};let Kc,Aw=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Wxe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[d,p]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],m=[p,d,i],g=fe().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&a,x=a||o;if(c||u||x){let N;if(g)N=t.device.importExternalTexture({source:r});else{if(x){const X=fe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Kc==null||X!==Aw)&&(Aw=X,Kc=document.createElement("canvas").getContext("2d",{willReadFrequently:Aw})),Kc.canvas.width=d,Kc.canvas.height=p,Kc.drawImage(r,0,0,d,p),r=Kc.canvas}const M=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,H=t.textureManager.acquireTexture(m[1],m[0],"rgba8unorm",M);t.queue.copyExternalImageToTexture({source:r},{texture:H},[m[1],m[0]]),N=H}const I=ce(m),$=Ze(m),E=new Vxe(m,i,g),D=[{type:"uint32",data:[I]},{type:"uint32",data:[i]},{type:"uint32",data:[...$]}],F=t.makeTensorInfo([p,d],"int32"),L=t.tensorMap.get(F.dataId);L.resource=N;const z=t.runWebGPUProgram(E,[F],"int32",D);return t.disposeData(F.dataId),z}const b=r.data;let v=b;if(i!=null&&i!==4){v=new Uint8Array(r.width*r.height*i);const N=b.length;let I=0;for(let $=0;$<N;$++)$%4<i&&(v[I++]=b[$])}const w=t.makeTensorInfo(m,"int32",new Int32Array(v));return t.uploadToGPU(w.dataId),w}class Gxe{constructor(e,t,s,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],it(e,t),it(e,s),this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(it(e,r),this.variableNames.push("offset")),i!=null&&(it(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${ze("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}const Hxe={kernelName:Hf,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:r,offset:i,mean:a,variance:o}=n,{varianceEpsilon:u}=e,c=t,d=[s,a,o];let p=null;i!=null&&(p=i.shape,d.push(i));let m=null;r!=null&&(m=r.shape,d.push(r));const g=new Gxe(s.shape,a.shape,o.shape,p,m),x=[{type:"float32",data:[u]}];return c.runWebGPUProgram(g,d,s.dtype,x)}};function jxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=s,b=Dr(d),v=fn(r.shape,i.shape,u,p,c,m,!1,b);return Kz({x:r,filter:i,convInfo:v,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:x,activation:g})}const qxe={kernelName:af,backendName:"webgpu",kernelFunc:jxe};function Xxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:c,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=s;let x=d;x==null&&(x=[1,1]),B(is(u,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${x}'`);const b=fn(r.shape,i.shape,u,x,c,p,!0),v=[r,i],w=a!=null,N=o!=null;w&&v.push(a),N&&v.push(o);const I=[{type:"int32",data:[b.padInfo.top,b.padInfo.left]},{type:"int32",data:[b.inHeight,b.inWidth]}];let $;return b.outHeight>4&&b.outWidth>4&&b.strideWidth<=2&&b.inChannels===b.outChannels&&b.dilationHeight===1&&b.dilationWidth===1&&b.inChannels%4===0?($=new Qz(b,w,m,N),I.push({type:"int32",data:[$.virtualWidth]})):($=new Zz(b,w,m,N),I.push({type:"int32",data:[b.filterHeight]},{type:"int32",data:[b.filterWidth]},{type:"int32",data:[b.strideHeight,b.strideWidth]},{type:"int32",data:[b.dilationHeight,b.dilationWidth]})),m==="leakyrelu"&&(I.push({type:"float32",data:[g]}),$.uniforms+=" alpha : f32,"),t.runWebGPUProgram($,v,"float32",I)}const Kxe={kernelName:of,backendName:"webgpu",kernelFunc:Xxe};class Yxe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ln(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}function Qxe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=ce(s.shape),[u,c,d,p]=ib(s,r),m=Xe({inputs:{x:r},backend:t,attrs:{shape:[c,a]}}),g=Xe({inputs:{x:s},backend:t,attrs:{shape:[ce(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const N=t.readSync(r.dataId),I=t.bufferSync(s),$=cme(N,I,s.dtype,c,a,d,p,s.shape,o);return t.makeTensorInfo(u,s.dtype,$.values)}const x=new Yxe(a,[c,d]),b=[{type:"int32",data:[a]},{type:"int32",data:p}],v=t.runWebGPUProgram(x,[g,m],g.dtype,b),w=Xe({inputs:{x:v},backend:t,attrs:{shape:u}});return t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(v.dataId),w}const Zxe={kernelName:i0,backendName:"webgpu",kernelFunc:Qxe};class Jxe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=e0e(this.aShape);return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function e0e(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}function nL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,u=gt(a,r.shape)[0],c=$b(r,i,u,o),d=ce(i.shape),p=[],m=Xe({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Xe({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,d/c.batchSize]}});p.push(m),p.push(g);const x=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,i])){const I=t.tensorMap.get(g.dataId).values,$=ft(g.shape,g.dtype,I),D=t.tensorMap.get(m.dataId).values,F=ft(m.shape,m.dtype,D),L=hme(F,$,x);return p.forEach(z=>t.disposeData(z.dataId)),t.makeTensorInfo(c.outputShape,L.dtype,L.values)}const b=new Jxe(m.shape,x),v=t.runWebGPUProgram(b,[m,g],m.dtype);p.push(v);const w=Xe({inputs:{x:v},backend:t,attrs:{shape:c.outputShape}});return p.forEach(N=>t.disposeData(N.dataId)),w}const t0e={kernelName:jf,backendName:"webgpu",kernelFunc:nL};const n0e=xs({opType:ht.GREATER,cpuKernelImpl:pme,dtype:"bool"}),s0e={kernelName:qf,backendName:"webgpu",kernelFunc:n0e};const r0e=xs({opType:ht.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:dme}),i0e={kernelName:Xh,backendName:"webgpu",kernelFunc:r0e};function a0e(n){const{inputs:e,backend:t}=n,{input:s}=e;return tL(s,!0,t)}const o0e={kernelName:a0,backendName:"webgpu",kernelFunc:a0e};const l0e=Pt({opType:Oe.IS_FINITE,dtype:"bool"}),u0e={kernelName:Yh,backendName:"webgpu",kernelFunc:l0e};const c0e=Pt({opType:Oe.IS_INF,dtype:"bool"}),h0e={kernelName:Qh,backendName:"webgpu",kernelFunc:c0e};const d0e=Pt({opType:Oe.IS_NAN,dtype:"bool"}),p0e={kernelName:Zh,backendName:"webgpu",kernelFunc:d0e};function f0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=[{type:"float32",data:[i]}],o=new Pd(r.shape,Oe.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(o,[r],"float32",a)}const m0e={kernelName:Xf,backendName:"webgpu",kernelFunc:f0e};const g0e=xs({opType:ht.LESS,dtype:"bool",cpuKernelImpl:mme}),y0e={kernelName:Kf,backendName:"webgpu",kernelFunc:g0e};const x0e=xs({opType:ht.LESS_EQUAL,dtype:"bool",cpuKernelImpl:fme}),b0e={kernelName:Yf,backendName:"webgpu",kernelFunc:x0e};class v0e{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}function w0e(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=(r-s)/(i-1),o=new v0e(i),u=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return e.runWebGPUProgram(o,[],"float32",u)}const S0e={kernelName:l0,backendName:"webgpu",kernelFunc:w0e};const C0e=Pt({opType:Oe.LOG,cpuKernelImpl:gme}),N0e={kernelName:Jh,backendName:"webgpu",kernelFunc:C0e};const k0e=Pt({opType:Oe.LOG1P}),$0e={kernelName:ed,backendName:"webgpu",kernelFunc:k0e};const I0e=xs({opType:ht.LOGICAL_AND,dtype:"bool"}),T0e={kernelName:Qf,backendName:"webgpu",kernelFunc:I0e};const E0e=Pt({opType:Oe.LOGICAL_NOT}),R0e={kernelName:Zf,backendName:"webgpu",kernelFunc:E0e};const A0e=xs({opType:ht.LOGICAL_OR}),D0e={kernelName:Jf,backendName:"webgpu",kernelFunc:A0e};const sL=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class _0e{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${sL}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class O0e{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,B(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Le(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${ze()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${sL}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}function F0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:u}=s;let c;i>16?c=new _0e(r.shape):c=new O0e(r.shape,i);const d=[{type:"int32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return t.runWebGPUProgram(c,[r],r.dtype,d)}const z0e={kernelName:em,backendName:"webgpu",kernelFunc:F0e};class L0e{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}function M0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:u,alpha:c,beta:d}=s,p=new L0e(r.shape),m=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[d]}];return t.runWebGPUProgram(p,[r,i,a],r.dtype,m)}const P0e={kernelName:u0,backendName:"webgpu",kernelFunc:M0e};const B0e=xs({opType:ht.MAX,cpuKernelImpl:xme}),V0e={kernelName:td,backendName:"webgpu",kernelFunc:B0e};function U0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,d=zs(r.shape,i,a,1,o,u);return Hz(r,d,"max",t)}const W0e={kernelName:nm,backendName:"webgpu",kernelFunc:U0e};function G0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:c}=s,d=[1,1,1],p=Qr(r.shape,i,a,d,o,c,u),m=new QC(p,"max"),g=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];return t.runWebGPUProgram(m,[r],r.dtype,g)}const H0e={kernelName:sm,backendName:"webgpu",kernelFunc:G0e};class j0e{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class q0e{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}function X0e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:u,pad:c,dimRoundingMode:d}=s,p=[1,1,1],m=Qr(a.shape,o,u,p,c,d),g=new QC(m,"max",!0);let x=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.front,m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inDepth,m.inHeight,m.inWidth]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]}];const b=t.runWebGPUProgram(g,[a],"int32",x),v=new q0e(m);x=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.effectiveFilterDepth-1-m.padInfo.front,m.effectiveFilterHeight-1-m.padInfo.top,m.effectiveFilterWidth-1-m.padInfo.left]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]},{type:"int32",data:[m.outDepth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]}];const w=t.runWebGPUProgram(v,[r,b],a.dtype,x);return t.disposeData(b.dataId),w}const K0e={kernelName:h0,backendName:"webgpu",kernelFunc:X0e};function Y0e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;Pz([i,a],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=s,m=zs(o.shape,u,c,1,d,p),g=new Nf(m,"max",!0);let x=[{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]},{type:"int32",data:[m.inHeight,m.inWidth]},{type:"int32",data:[m.effectiveFilterHeight,m.effectiveFilterWidth]}];const b=t.runWebGPUProgram(g,[o],"int32",x),v=new j0e(m);x=[{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.effectiveFilterHeight-1-m.padInfo.top,m.effectiveFilterWidth-1-m.padInfo.left]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]},{type:"int32",data:[m.effectiveFilterHeight,m.effectiveFilterWidth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]}];const w=t.runWebGPUProgram(v,[r,b],o.dtype,x);return t.disposeData(b.dataId),w}const Q0e={kernelName:c0,backendName:"webgpu",kernelFunc:Y0e};function Z0e(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=s,{x:u}=e;B(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const c=[1,1];B(is(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=zs(u.shape,r,i,c,a),p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let m=new Nf(d,"max",!1);const g=t.runWebGPUProgram(m,[u],u.dtype,p);m=new Nf(d,"max",!0,!0,o);const x=t.runWebGPUProgram(m,[u],"int32",p);return[g,x]}const J0e={kernelName:d0,backendName:"webgpu",kernelFunc:Z0e};function ebe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return ec(r,i,a,"min",t)}const tbe={kernelName:im,backendName:"webgpu",kernelFunc:ebe};const nbe=xs({opType:ht.MIN,cpuKernelImpl:bme}),sbe={kernelName:nd,backendName:"webgpu",kernelFunc:nbe};class rbe{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,i)=>r[0]+e[i]+r[1]),this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,d)=>`uniforms.pad${d}[0]`).join(","),s=this.xShape.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),r=e===1?"start":"start[i]",i=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",o=Ln(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let start = ${o}(${t});
          let end = ${o}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${r}) {
              ${a} = ${r} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${i}) {
              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}}const ibe={kernelName:am,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:r,mode:i}=e,a=t,o=r.map(d=>({type:"int32",data:[d[0],d[1]]})),u=new rbe(s.shape,r,i);return a.runWebGPUProgram(u,[s],s.dtype,o)}};const abe=xs({opType:ht.MOD}),obe={kernelName:sd,backendName:"webgpu",kernelFunc:abe};class lbe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ze("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}class ube{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${ze("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}function rL(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=Xe({inputs:{x:r},backend:t,attrs:{shape:[ce(r.shape)/r.shape[i],r.shape[i]]}}),o=new ube(a.shape),u=t.runWebGPUProgram(o,[a],r.dtype),c=Xe({inputs:{x:u},backend:t,attrs:{shape:r.shape}});return t.disposeData(a.dataId),t.disposeData(u.dataId),c}const cbe={kernelName:Nm,backendName:"webgpu",kernelFunc:rL};function hbe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,u=o?r:rL({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=u.shape[0],d=u.shape[1],p=new lbe(c,i),m=[{type:"float32",data:[a]},{type:"int32",data:[d]}],g=t.runWebGPUProgram(p,[u],"int32",m);return o||t.disposeData(u.dataId),g}const dbe={kernelName:p0,backendName:"webgpu",kernelFunc:hbe};function pbe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.tensorMap.get(s.dataId),[a,o]=wme(i.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}const r=new Pd(s.shape,Oe.NEG);return t.runWebGPUProgram(r,[s],s.dtype)}const fbe={kernelName:om,backendName:"webgpu",kernelFunc:pbe};function mbe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s,c=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:p}=sb(c,d,a,o,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const gbe={kernelName:f0,backendName:"webgpu",kernelFunc:mbe};function ybe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),m=a,g=o,x=u,b=c,{selectedIndices:v,selectedScores:w}=rb(d,p,m,g,x,b);return[t.makeTensorInfo([v.length],"int32",new Int32Array(v)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const xbe={kernelName:m0,backendName:"webgpu",kernelFunc:ybe};class bbe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${ze("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}function vbe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:u}=s,c=ce(r.shape),d=new bbe(c,a),p=Xe({inputs:{x:r},backend:t,attrs:{shape:[c]}}),m=[{type:"float32",data:[o]},{type:"float32",data:[u]}],g=t.runWebGPUProgram(d,[p],i,m);t.disposeData(p.dataId);const x=[...r.shape,a],b=Xe({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeData(g.dataId),b}const wbe={kernelName:cm,backendName:"webgpu",kernelFunc:vbe};function Ex(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Zm({inputs:{input:s},backend:t}),i=Ex({inputs:{x:r},backend:t}),a=qb({inputs:{input:s},backend:t}),o=Ex({inputs:{x:a},backend:t}),u=Ju({inputs:{real:i,imag:o},backend:t});return t.disposeData(r.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),t.disposeData(o.dataId),u}else return ur({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const Sbe={kernelName:Im,backendName:"webgpu",kernelFunc:Ex};function iL(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Zm({inputs:{input:s},backend:t}),i=iL({inputs:{x:r},backend:t}),a=qb({inputs:{input:s},backend:t}),o=Ex({inputs:{x:a},backend:t}),u=Ju({inputs:{real:i,imag:o},backend:t});return t.disposeData(r.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),t.disposeData(o.dataId),u}else return ur({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const Cbe={kernelName:um,backendName:"webgpu",kernelFunc:iL};function Nbe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return U2({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{pr(i,d.shape,"All tensors passed to stack must have matching shapes"),B(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(d=>{const p=U2({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),c=Xz({inputs:u,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeData(d.dataId)),c}const kbe={kernelName:hm,backendName:"webgpu",kernelFunc:Nbe};function aL(n,e=!1){const t=n.length,s=Ln(t),r=n.map((p,m)=>`uniforms.pad${m}[0]`).join(","),i=n.map((p,m)=>`uniforms.pad${m}[0] + uniforms.xShape${t>1?`[${m}]`:""}`).join(","),a=t>1?`${s}(${r})`:`${r}`,o=t>1?`${s}(${i})`:`${i}`,u=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${a};
        let end = ${o};
        if (${u} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}class $be{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,r)=>s[0]+e[r]+s[1]),this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${aL(this.xShape)}
        }
      }
    `}}const Ibe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(i.every(c=>xt(c,[0,0])))return Ar({inputs:{x:r},backend:t});if(ce(r.shape)===0){const c=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return ur({backend:t,attrs:{shape:c,value:a,dtype:r.dtype}})}const o=[{type:"float32",data:[a]}];i.map(c=>o.push({type:"int32",data:[c[0],c[1]]}));const u=new $be(r.shape,i);return t.runWebGPUProgram(u,[r],r.dtype,o)},Tbe={kernelName:dm,backendName:"webgpu",kernelFunc:Ibe};const Ebe=xs({opType:ht.POW}),Rbe={kernelName:id,backendName:"webgpu",kernelFunc:Ebe};function Abe(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=new Ix(ht.PRELU,s.shape,r.shape);return t.runWebGPUProgram(i,[s,r],"float32")}const Dbe={kernelName:pm,backendName:"webgpu",kernelFunc:Abe};function _be(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return ec(r,i,a,"prod",t)}const Obe={kernelName:fm,backendName:"webgpu",kernelFunc:_be};const Fbe=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,o=Nme(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},zbe={kernelName:g0,backendName:"webgpu",kernelFunc:Fbe};const Lbe=xs({opType:ht.DIV}),Mbe={kernelName:Vh,backendName:"webgpu",kernelFunc:Lbe};const Pbe=Pt({opType:Oe.RECIPROCAL}),Bbe={kernelName:ad,backendName:"webgpu",kernelFunc:Pbe};const Vbe=Pt({opType:Oe.RELU}),Ube={kernelName:od,backendName:"webgpu",kernelFunc:Vbe};const Wbe=Pt({opType:Oe.RELU6}),Gbe={kernelName:ld,backendName:"webgpu",kernelFunc:Wbe};class Hbe{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}function jbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,size:a,halfPixelCenters:o}=s,[u,c]=a,d=i&&u>1?1:0,p=i&&c>1?1:0,g=[{type:"float32",data:[d,p]},{type:"float32",data:[o?.5:0]}],x=new Hbe(r.shape,u,c);return t.runWebGPUProgram(x,[r],"float32",g)}const qbe={kernelName:ym,backendName:"webgpu",kernelFunc:jbe};class Xbe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}function Kbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,[,o,u]=r.shape,[,c,d]=i.shape,p=[a&&c>1?o-1:o,a&&d>1?u-1:u],m=[a&&c>1?c-1:c,a&&d>1?d-1:d],g=p[0]/m[0],x=p[1]/m[1],b=1/g,v=1/x,w=Math.ceil(b)*2+2,N=Math.ceil(v)*2+2,I=new Xbe(r.shape,a),$=[{type:"int32",data:p},{type:"int32",data:m},{type:"float32",data:[g]},{type:"float32",data:[x]},{type:"float32",data:[b]},{type:"float32",data:[v]},{type:"int32",data:[w]},{type:"int32",data:[N]}];return t.runWebGPUProgram(I,[i],i.dtype,$)}const Ybe={kernelName:b0,backendName:"webgpu",kernelFunc:Kbe};class Qbe{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}function Zbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,c]=o,d=i&&u>1?1:0,p=i&&c>1?1:0,g=[{type:"float32",data:[d,p]},{type:"float32",data:[i?.5:0]}],x=new Qbe(r.shape,u,c,a);return t.runWebGPUProgram(x,[r],r.dtype,g)}const Jbe={kernelName:gm,backendName:"webgpu",kernelFunc:Zbe};class e1e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}function t1e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,[,o,u]=r.shape,[,c,d]=i.shape,p=[a&&c>1?o-1:o,a&&d>1?u-1:u],m=[a&&c>1?c-1:c,a&&d>1?d-1:d],g=p[0]/m[0],x=p[1]/m[1],b=1/g,v=1/x,w=Math.ceil(b)*2+2,N=Math.ceil(v)*2+2,I=new e1e(r.shape,a),$=[{type:"int32",data:p},{type:"int32",data:m},{type:"float32",data:[b]},{type:"float32",data:[v]},{type:"int32",data:[w]},{type:"int32",data:[N]}];return t.runWebGPUProgram(I,[i],i.dtype,$)}const n1e={kernelName:x0,backendName:"webgpu",kernelFunc:t1e};class s1e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}function r1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length;if(a===0)return Ar({inputs:{x:r},backend:t});const o=r.shape,u=[1,1,1,1];o.forEach((v,w)=>{const N=w+4-a;u[N]=v});const c=gt(i,r.shape),d=[0,0,0,0];c.forEach(v=>{const w=v+4-a;d[w]=1});const p=[{type:"int32",data:d}],m=Xe({inputs:{x:r},backend:t,attrs:{shape:u}}),g=new s1e(u),x=t.runWebGPUProgram(g,[m],m.dtype,p);t.disposeData(m.dataId);const b=Xe({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeData(x.dataId),b}const i1e={kernelName:xm,backendName:"webgpu",kernelFunc:r1e};class a1e{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ze("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}const o1e={kernelName:D0,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,u=new a1e(s.shape,i),[c,d]=hb(a,s.shape[1],s.shape[2]),p=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof i=="number"?p.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):p.push({type:"float32",data:i}),o.runWebGPUProgram(u,[s],s.dtype,p)}};const l1e=Pt({opType:Oe.ROUND}),u1e={kernelName:ud,backendName:"webgpu",kernelFunc:l1e};const c1e=Pt({opType:Oe.RSQRT,cpuKernelImpl:kme}),h1e={kernelName:cd,backendName:"webgpu",kernelFunc:c1e};class tf{constructor(e,t,s,r,i,a,o,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=o,this.sumDupeIndices=u,this.dispatchLayout=We(e),this.dispatch=Le(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${o}_${u}_${i.length}`;const c=Ln(i.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";this.dispatchLayout.x.length===1?(r="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const o=`getUpdates(${Array.from({length:this.updatesRank},(c,d)=>`coords[${d}]`).join(", ")})`;return`
    ${i}
      ${ze("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${pu(this.type)}(${o});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?Rl("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}function d1e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Ta(i,r,a),m=[p/c,c];if(p===0)return t.makeTensorInfo(a,r.dtype);const g=Xe({inputs:{x:r},backend:t,attrs:{shape:[u,o]}}),x=Xe({inputs:{x:i},backend:t,attrs:{shape:[u,c]}}),b=x.dtype,v=ur({backend:t,attrs:{shape:m,value:0,dtype:b}}),w=ce(x.shape),N=[{type:"int32",data:[o]},{type:"int32",data:d},{type:"int32",data:[w]}],I=new tf(x.shape,o,g.shape.length,x.shape.length,d,m,b),$=t.runWebGPUProgram(I,[x,g],b,N,v),E=Xe({inputs:{x:$},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData($.dataId),E}const p1e={kernelName:v0,backendName:"webgpu",kernelFunc:d1e};class f1e{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${ze("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}function m1e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=new f1e([i.shape[0],i.shape[1]],a),u=[{type:"int32",data:[r.shape[1]]}];return t.runWebGPUProgram(o,[r,i],"int32",u)}const g1e={kernelName:S0,backendName:"webgpu",kernelFunc:m1e};class y1e{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let o=0;o<this.outputShape.length;o++)a.push(`${r[o]}`),o<this.cRank&&i.push(`${r[o]}`);e=i.join(),t=a.join()}return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}function x1e(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new y1e(s.shape.length,r.shape,r.shape.length);return t.runWebGPUProgram(a,[s,r,i],ys(r.dtype,i.dtype))}const b1e={kernelName:bm,backendName:"webgpu",kernelFunc:x1e};const v1e=Pt({opType:Oe.SELU}),w1e={kernelName:hd,backendName:"webgpu",kernelFunc:v1e};const S1e=Pt({opType:Oe.SIGMOID}),C1e={kernelName:md,backendName:"webgpu",kernelFunc:S1e};const N1e=Pt({opType:Oe.SIGN}),k1e={kernelName:fd,backendName:"webgpu",kernelFunc:N1e};const $1e=Pt({opType:Oe.SIN}),I1e={kernelName:dd,backendName:"webgpu",kernelFunc:$1e};const T1e=Pt({opType:Oe.SINH}),E1e={kernelName:pd,backendName:"webgpu",kernelFunc:T1e};const R1e=Pt({opType:Oe.SOFTPLUS}),A1e={kernelName:gd,backendName:"webgpu",kernelFunc:R1e};class D1e{constructor(e,t,s,r,i,a){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const o=new Array(r.length);for(let u=0;u<o.length;u++)o[u]=r[i[u]];this.outputShape=o,this.newDim=i,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Ln(r.length)}, paddedXShapeStrides : ${Ln(a)}, `,s.map((u,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Ln(this.outputShape.length),t=Vz(this.newDim);return`
      ${Xy(this.paddedXShape,"PaddedX")}
      ${ze("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${aL(this.xShape,!0)}
        }
      }
    `}}const _1e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;B(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const o=i.reduce((N,I)=>N*I),u=[[0,0]];u.push(...a);for(let N=1+i.length;N<r.shape.length;++N)u.push([0,0]);const c=u.map((N,I)=>N[0]+r.shape[I]+N[1]),d=Wu(c,i,o,!1),p=Gu(d.length,i.length,!1),m=Hu(c,i,o,!1),g=Ze(c),x=new D1e(r.shape,c,u,d,p,g.length),b=[{type:"int32",data:d},{type:"int32",data:g}];u.map(N=>b.push({type:"int32",data:[N[0],N[1]]}));const v=t.runWebGPUProgram(x,[r],r.dtype,b),w=Xe({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeData(v.dataId),w},O1e={kernelName:Sm,backendName:"webgpu",kernelFunc:_1e};class F1e{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=We([t]),this.dispatch=Le(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Rl("&result[outIndex]","value",this.type)}
      }
    }
  `}}class z1e{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=We(t),this.dispatch=Le(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Rl("&result[segmentId]","1","int32")}
      }
    }
  `}}class L1e{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=We(e),this.dispatch=Le(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}function oL(n,e,t,s=!1,r){const a=ce(n.shape)/n.shape[0],o=n.dtype,u=ce(e.shape),c=r.readSync(t.dataId),p=u>0?c[u-1]+1:0;let m;const g=n.shape.slice();g[0]=p;const x=u*a,b=ur({backend:r,attrs:{shape:g,value:0,dtype:o}});m=new F1e(g,x,o);let v=[{type:"int32",data:[a]},{type:"int32",data:[x]}];const w=r.runWebGPUProgram(m,[n,e,t],o,v,b);if(s)return w;const N=ur({backend:r,attrs:{shape:[p],value:0,dtype:"int32"}});m=new z1e(p,t.shape);const I=r.runWebGPUProgram(m,[t],"int32",null,N),$=ur({backend:r,attrs:{shape:g,value:0,dtype:o}});m=new L1e(g,o),v=[{type:"int32",data:[a]}];const E=r.runWebGPUProgram(m,[w,I],o,v,$);return r.disposeData(w.dataId),r.disposeData(I.dataId),E}function M1e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;return oL(s,r,i,!1,t)}const P1e={kernelName:C0,backendName:"webgpu",kernelFunc:M1e};function B1e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;return oL(s,r,i,!0,t)}const V1e={kernelName:N0,backendName:"webgpu",kernelFunc:B1e};class U1e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*t[r];this.outputShape=s,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=W1e(this.rank,"uniforms.");return`
      ${ze("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function W1e(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n;r++)s.push(`(${t[r]} % ${e}aShape[${r}])`);return s.join()}function ZC(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(t.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const u=t.readSync(r.dataId),c=r.dtype==="string"?u.map(m=>Hi(m)):u,d=ft(r.shape,r.dtype,c),p=Dme(d,i);return t.makeTensorInfo(p.shape,p.dtype,p.values)}const a=new U1e(r.shape,i);return t.runWebGPUProgram(a,[r],r.dtype)}const G1e={kernelName:Sd,backendName:"webgpu",kernelFunc:ZC};function H1e(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:m}=Ta(i,r,o),g=!1;if(i.dtype==="string"){const L=t.bufferSync(r),z=t.bufferSync(i),M=Hi(t.readSync(a.dataId)[0]),O=$me(L,z,o,m,d,c,u,p,M,g);return t.makeTensorInfo(o,O.dtype,O.values)}const x=[m/d,d],b=Xe({inputs:{x:r},backend:t,attrs:{shape:[c,u]}}),v=i.shape.length?Xe({inputs:{x:i},backend:t,attrs:{shape:[c,d]}}):Ar({inputs:{x:i},backend:t}),w=v.dtype,N=t.makeTensorInfo([],w,Ns(1,w)),I=Xe({inputs:{x:a},backend:t,attrs:{shape:Array(x.length).fill(1)}}),$=ZC({inputs:{x:I},backend:t,attrs:{reps:x}}),E=ce([c,d]),D=[{type:"int32",data:[u]},{type:"int32",data:p},{type:"int32",data:[E]}];switch(c){case 0:break;case 1:{const L=new tf([c,d],u,b.shape.length,v.shape.length,p,x,w,g);t.runWebGPUProgram(L,[v,b],w,D,$)}break;default:{const L=new tf([c,d],u,b.shape.length,N.shape.length,p,x,w,g);t.runWebGPUProgram(L,[N,b],w,D,$)}{const L=new tf([c,d],u,b.shape.length,v.shape.length,p,x,w);t.runWebGPUProgram(L,[v,b],w,D,$)}}const F=Xe({inputs:{x:$},backend:t,attrs:{shape:o}});return t.disposeData(b.dataId),t.disposeData(v.dataId),t.disposeData(I.dataId),t.disposeData(N.dataId),t.disposeData($.dataId),F}const j1e={kernelName:k0,backendName:"webgpu",kernelFunc:H1e};function q1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=gt(a,r.shape)[0],u=kb(r,i,o),c=r.shape.length,d=new Array(c).fill(0),p=r.shape.slice();return u.map(m=>{const g=[...p];g[o]=m;const x=Bd({inputs:{x:r},backend:t,attrs:{begin:d,size:g}});return d[o]+=m,x})}const X1e={kernelName:Cm,backendName:"webgpu",kernelFunc:q1e};const K1e=Pt({opType:Oe.SQRT}),Y1e={kernelName:yd,backendName:"webgpu",kernelFunc:K1e};const Q1e={kernelName:$0,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,r=new Pd(t.shape,Oe.SQUARE);return s.runWebGPUProgram(r,[t],t.dtype)}};const Z1e=xs({opType:ht.SQUARED_DIFFERENCE}),J1e={kernelName:xd,backendName:"webgpu",kernelFunc:Z1e};function eve({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=new Pd(s.shape,Oe.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(r,[s],s.dtype,i)}const tve={kernelName:Cd,backendName:"webgpu",kernelFunc:eve};class nve{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ln(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let r=0;t=this.outputShape.map((i,a)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${r-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${ze("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}function sve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:g,finalShape:x,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:N,end:I,strides:$}=lb(r.shape,i,a,o,u,c,d,p,m);let E;if(b)E=Xe({inputs:{x:r},backend:t,attrs:{shape:x}});else if(v||w){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const D=ob(N,I,$),F=Bd({inputs:{x:r},backend:t,attrs:{begin:N,size:D}});E=Xe({inputs:{x:F},backend:t,attrs:{shape:x}}),t.disposeData(F.dataId)}else if(t.shouldExecuteOnCPU([r])){const F=t.readSync(r.dataId),L=ft(r.shape,r.dtype,F),z=Eme(g,L,$,N);E=t.makeTensorInfo(x,r.dtype,z.values)}else{const F=new nve(g),L=[{type:"int32",data:N},{type:"int32",data:$}],z=t.runWebGPUProgram(F,[r],r.dtype,L);E=Xe({inputs:{x:z},backend:t,attrs:{shape:x}}),t.disposeData(z.dataId)}return E}const rve={kernelName:T0,backendName:"webgpu",kernelFunc:sve};function ive(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:c}=s,{data:d,dataSplits:p}=e,m=t.readSync(d.dataId),g=t.readSync(p.dataId),[x,b]=Rme(m,g,r,i,a,o,u,c);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(p.shape,"int32",b)]}const ave={kernelName:E0,backendName:"webgpu",kernelFunc:ive};const ove=xs({opType:ht.SUB,cpuKernelImpl:Ame,supportsComplex:!0}),lve={kernelName:bd,backendName:"webgpu",kernelFunc:ove};const uve=Pt({opType:Oe.TAN}),cve={kernelName:vd,backendName:"webgpu",kernelFunc:uve};const hve=Pt({opType:Oe.TANH}),dve={kernelName:wd,backendName:"webgpu",kernelFunc:hve};function pve(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Ta(a,i,r.shape),m=[p/c,c];if(p===0)return t.makeTensorInfo(r.shape,i.dtype);const g=[],x=Xe({inputs:{x:i},backend:t,attrs:{shape:[u,o]}});g.push(x);const b=Xe({inputs:{x:a},backend:t,attrs:{shape:[u,c]}});g.push(b);const v=Xe({inputs:{x:r},backend:t,attrs:{shape:m}});g.push(v);const w=ZC({inputs:{x:v},backend:t,attrs:{reps:Array(m.length).fill(1)}}),N=new tf([u,c],o,x.shape.length,b.shape.length,d,m,r.dtype,!1),I=ce([u,c]),$=[{type:"int32",data:[o]},{type:"int32",data:d},{type:"int32",data:[I]}],E=t.runWebGPUProgram(N,[b,x],v.dtype,$,w);g.push(E);const D=Xe({inputs:{x:E},backend:t,attrs:{shape:r.shape}});return g.forEach(F=>t.disposeData(F.dataId)),D}const fve={kernelName:w0,backendName:"webgpu",kernelFunc:pve};class mve{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${ze("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class gve{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${ze("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}function Yc(n,e){e!==null&&n.disposeData(e.dataId)}function WE(n){let e=1;for(;e<n;)e*=2;return e}function yve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,o=r.shape,u=o[o.length-1];if(t.shouldExecuteOnCPU([r])){const E=t.readSync(r.dataId),[D,F]=_me(E,o,r.dtype,i,a);return[t.makeTensorInfo(D.shape,D.dtype,D.values),t.makeTensorInfo(F.shape,F.dtype,F.values)]}if(i===0)return o[o.length-1]=0,[t.makeTensorInfo(o,r.dtype,[]),t.makeTensorInfo(o,"int32",[])];if(u===1)return[r,ur({attrs:{shape:o,dtype:"int32",value:0},backend:t})];const d=ce(o)/u,p=Xe({inputs:{x:r},attrs:{shape:[d,u]},backend:t}),m=WE(i),g=WE(u);let x=null;const b=()=>x===null?[p,p]:[p,x],v=(E,D,F)=>{const L=b(),z=new mve(F),O=[{type:"int32",data:[u]},{type:"int32",data:[x===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[E]},{type:"int32",data:[D]}],H=x;x=t.runWebGPUProgram(z,L,"int32",O),Yc(t,H)};for(let E=1;E<m;E*=2){const D=E*2;for(let F=E;F>=1;F/=2)v(D,F,[d,g])}for(let E=g;E>m;E/=2){const D=b(),F=new gve([d,E/2]),z=[{type:"int32",data:[u]},{type:"int32",data:[x===null?1:0]},{type:"int32",data:[m]}],M=x;x=t.runWebGPUProgram(F,D,"int32",z),Yc(t,M);const O=m/2,H=O*2;for(let X=O;X>=1;X/=2)v(H,X,x.shape)}let w=x;x=Bd({inputs:{x},backend:t,attrs:{begin:0,size:[d,i]}}),Yc(t,w);let N=nL({inputs:{x:p,indices:x},backend:t,attrs:{axis:1,batchDims:1}});Yc(t,p);const I=o.slice(0,-1);I.push(i),w=x,x=Xe({inputs:{x},attrs:{shape:I},backend:t}),Yc(t,w);const $=N;return N=Xe({inputs:{x:N},attrs:{shape:I},backend:t}),Yc(t,$),[N,x]}const xve={kernelName:R0,backendName:"webgpu",kernelFunc:yve};class bve{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ze("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}function vve(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:u,outputShape:c}=s,[d,p,m,g]=r.shape,[x,b]=c??[p,m],v=[d,x,b,g],w=new bve(v),N=a==="nearest"?1:2;let I;switch(o){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}const $=[{type:"int32",data:[N]},{type:"int32",data:[I]},{type:"float32",data:[u]}];return t.runWebGPUProgram(w,[r,i],"float32",$)}const wve={kernelName:A0,backendName:"webgpu",kernelFunc:vve};function Sve(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,u=r.shape[i],c=new Array(o-1);let d=0;for(let b=0;b<o;b++)b!==i&&(c[d++]=a.shape[b]);const p=[],m=new Array(o).fill(0),g=a.shape.slice();g[i]=1;const x=new Array(u);for(let b=0;b<x.length;b++){m[i]=b;const v=Bd({inputs:{x:a},backend:t,attrs:{begin:m,size:g}}),w=Xe({inputs:{x:v},backend:t,attrs:{shape:c}});x[b]=w,p.push(v)}return p.forEach(b=>t.disposeData(b.dataId)),x}const Cve={kernelName:km,backendName:"webgpu",kernelFunc:Sve};class Nve{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=We(e),this.dispatch=Le(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${ze("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Rl("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}function kve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,u=[];let c=0;const d=sn([c],o);let p=r;d!=null&&(p=Na({inputs:{x:r},backend:t,attrs:{perm:d}}),u.push(p),c=mn(1,o)[0]);const m=oC(p.shape,c,a),g=ce([p.shape[c]]),x=Xe({inputs:{x:p},backend:t,attrs:{shape:[-1,g]}});u.push(x);const b=r.dtype,v=[x.shape[0],a],w=ur({backend:t,attrs:{shape:v,value:0,dtype:b}}),N=new Nve(x.shape,v,b),I=[{type:"int32",data:[a]},{type:"int32",data:[ce(x.shape)]}],$=t.runWebGPUProgram(N,[x,i],b,I,w),E=Xe({inputs:{x:$},backend:t,attrs:{shape:m}});u.push($);let D=E;if(d!=null){u.push(E);const F=$a(d);D=Na({inputs:{x:D},backend:t,attrs:{perm:F}})}return u.forEach(F=>t.disposeData(F.dataId)),D}const $ve={kernelName:$m,backendName:"webgpu",kernelFunc:kve};const Ive=[Zfe,zme,Mme,Bme,Ume,Hme,Zme,ege,nge,rge,age,lge,cge,dge,fge,bge,wge,kge,Ige,Ege,Oge,Mge,Vge,Hge,qge,Qge,eme,eye,rye,dye,xye,Sye,kye,Iye,Eye,Aye,_ye,zye,Mye,Bye,Uye,Hye,Zye,exe,Xye,sxe,axe,cxe,dxe,mxe,bxe,wxe,Cxe,kxe,Ixe,Exe,Rxe,Dxe,Oxe,Kfe,zxe,Uxe,Mxe,Bxe,Hxe,qxe,Kxe,Zxe,t0e,s0e,i0e,Jfe,o0e,nye,u0e,h0e,p0e,m0e,y0e,b0e,S0e,$0e,N0e,T0e,R0e,D0e,z0e,P0e,gge,V0e,W0e,Q0e,H0e,K0e,J0e,yge,tbe,sbe,ibe,obe,dbe,gxe,fbe,gbe,xbe,Uge,wbe,Cbe,kbe,Tbe,Rbe,Dbe,Obe,zbe,Wge,Mbe,Bbe,Ube,Gbe,Yfe,qbe,Ybe,Jbe,n1e,i1e,o1e,u1e,h1e,p1e,g1e,b1e,w1e,C1e,k1e,I1e,E1e,Dge,tve,rve,ave,cbe,A1e,O1e,P1e,V1e,j1e,X1e,Y1e,Q1e,J1e,lve,yxe,cve,dve,fve,G1e,xve,wve,Xme,Cve,$ve,Sbe];for(const n of Ive)pS(n);var lL=function(n,e){return(lL=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(t[r]=s[r])})(n,e)};function uL(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}lL(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var cn=function(){return(cn=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};function At(n,e,t,s){return new(t||(t=Promise))((function(r,i){function a(c){try{u(s.next(c))}catch(d){i(d)}}function o(c){try{u(s.throw(c))}catch(d){i(d)}}function u(c){var d;c.done?r(c.value):(d=c.value,d instanceof t?d:new t((function(p){p(d)}))).then(a,o)}u((s=s.apply(n,[])).next())}))}function Dt(n,e){var t,s,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function o(u){return function(c){return(function(d){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,s&&(r=2&d[0]?s.return:d[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,d[1])).done)return r;switch(s=0,r&&(d=[2&d[0],r.value]),d[0]){case 0:case 1:r=d;break;case 4:return a.label++,{value:d[1],done:!1};case 5:a.label++,s=d[1],d=[0];continue;case 7:d=a.ops.pop(),a.trys.pop();continue;default:if(r=a.trys,!((r=r.length>0&&r[r.length-1])||d[0]!==6&&d[0]!==2)){a=0;continue}if(d[0]===3&&(!r||d[1]>r[0]&&d[1]<r[3])){a.label=d[1];break}if(d[0]===6&&a.label<r[1]){a.label=r[1],r=d;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(d);break}r[2]&&a.ops.pop(),a.trys.pop();continue}d=e.call(n,a)}catch(p){d=[6,p],s=0}finally{t=r=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}})([u,c])}}}function gu(n,e,t){if(t||arguments.length===2)for(var s,r=0,i=e.length;r<i;r++)!s&&r in e||(s||(s=Array.prototype.slice.call(e,0,r)),s[r]=e[r]);return n.concat(s||Array.prototype.slice.call(e))}var ka=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],$f=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function Rx(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function cL(n){return At(this,void 0,void 0,(function(){var e,t;return Dt(this,(function(s){switch(s.label){case 0:return e=document.createElement("canvas"),n instanceof Kt?[4,nC(n,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=Rx(n.width),e.height=Rx(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),s.label=3;case 3:return[2,e]}}))}))}function hL(n){return At(this,void 0,void 0,(function(){var e,t,s,r,i,a;return Dt(this,(function(o){switch(o.label){case 0:return n instanceof Kt?(e=n.shape.slice(0,2),t=e[0],s=e[1],r=ImageData.bind,[4,nC(n)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,o.sent(),s,t]))];case 2:return i=document.createElement("canvas"),a=i.getContext("2d"),i.width=Rx(n.width),i.height=Rx(n.height),a.drawImage(n,0,0),[2,a.getImageData(0,0,i.width,i.height)]}}))}))}function Tve(n){return At(this,void 0,void 0,(function(){var e,t;return Dt(this,(function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,cL(n)]:[3,2];case 1:return t=s.sent(),[3,3];case 2:t=n,s.label=3;case 3:return e=t,[2,OA(e,4)]}}))}))}function dL(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var jp={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Eve=(function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,this.mask]}))}))},n.prototype.toImageData=function(){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,hL(this.mask)]}))}))},n.prototype.toTensor=function(){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,Tve(this.mask)]}))}))},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n})();function Rve(n){return dL(n),"person"}var Ave=(function(){function n(e){var t,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new Yde.Pose({locateFile:function(r,i){if(e.solutionPath){var a=e.solutionPath.replace(/\/+$/,"");return"".concat(a,"/").concat(r)}return"".concat(i,"/").concat(r)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(r){if(s.height=r.image.height,s.width=r.image.width,r.poseLandmarks==null)s.poses=[];else{var i=s.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(i.segmentation={maskValueToLabel:Rve,mask:new Eve(r.segmentationMask)}),s.poses=[i]}}))}return n.prototype.translateOutput=function(e,t){var s=this,r={keypoints:e.map((function(i,a){return{x:i.x*s.width,y:i.y*s.height,z:i.z,score:i.visibility,name:$f[a]}}))};return t!=null&&(r.keypoints3D=t.map((function(i,a){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:$f[a]}}))),r},n.prototype.estimatePoses=function(e,t,s){return At(this,void 0,void 0,(function(){var r,i;return Dt(this,(function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Kt?(i=ImageData.bind,[4,nC(e)]):[3,2];case 1:return r=new(i.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},s)];case 4:return a.sent(),[2,this.poses]}}))}))},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n})();function Dve(n){return At(this,void 0,void 0,(function(){var e,t;return Dt(this,(function(s){switch(s.label){case 0:return e=(function(r){if(r==null)return cn({},jp);var i=cn({},r);return i.runtime="mediapipe",i.enableSegmentation==null&&(i.enableSegmentation=jp.enableSegmentation),i.enableSmoothing==null&&(i.enableSmoothing=jp.enableSmoothing),i.smoothSegmentation==null&&(i.smoothSegmentation=jp.smoothSegmentation),i.modelType==null&&(i.modelType=jp.modelType),i})(n),[4,(t=new Ave(e)).initialize()];case 1:return s.sent(),[2,t]}}))}))}function Ch(n){return n instanceof Kt?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function pL(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function JC(n){return n instanceof Kt?n:OA(n)}function fL(n,e,t){return W2(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function W2(n,e){B(n.width!==0,(function(){return"".concat(e," width cannot be 0.")})),B(n.height!==0,(function(){return"".concat(e," height cannot be 0.")}))}function Dw(n,e,t){var s=t.rotationVectorStartKeypointIndex,r=t.rotationVectorEndKeypointIndex,i=n.locationData,a=i.relativeKeypoints[s].x*e.width,o=i.relativeKeypoints[s].y*e.height,u=i.relativeKeypoints[r].x*e.width,c=i.relativeKeypoints[r].y*e.height,d=2*Math.sqrt((u-a)*(u-a)+(c-o)*(c-o)),p=(function(m,g,x){var b,v=m.locationData,w=x.rotationVectorStartKeypointIndex,N=x.rotationVectorEndKeypointIndex;b=x.rotationVectorTargetAngle?x.rotationVectorTargetAngle:Math.PI*x.rotationVectorTargetAngleDegree/180;var I=v.relativeKeypoints[w].x*g.width,$=v.relativeKeypoints[w].y*g.height,E=v.relativeKeypoints[N].x*g.width,D=v.relativeKeypoints[N].y*g.height;return pL(b-Math.atan2(-(D-$),E-I))})(n,e,t);return{xCenter:a/e.width,yCenter:o/e.height,width:d/e.width,height:d/e.height,rotation:p}}function mL(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function _w(n,e,t,s,r,i,a){return n[e][r]*(n[t][i]*n[s][a]-n[t][a]*n[s][i])}function Ws(n,e,t){var s=(e+1)%4,r=(e+2)%4,i=(e+3)%4,a=(t+1)%4,o=(t+2)%4,u=(t+3)%4;return _w(n,s,r,i,a,o,u)+_w(n,r,i,s,a,o,u)+_w(n,i,s,r,a,o,u)}function GE(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var s=[],r=0,i=n;r<i.length;r++){var a=i[r],o=a.x-.5,u=a.y-.5,c=t.ignoreRotation?0:e.rotation,d=Math.cos(c)*o-Math.sin(c)*u,p=Math.sin(c)*o+Math.cos(c)*u;d=d*e.width+e.xCenter,p=p*e.height+e.yCenter;var m=a.z*e.width,g=cn({},a);g.x=d,g.y=p,g.z=m,s.push(g)}return s}function gL(n,e){var t=(function(s,r,i,a){var o=r-s,u=a-i,c=u/o;return{scale:c,offset:i-s*c}})(0,255,e[0],e[1]);return he((function(){return $e(Q(n,t.scale),t.offset)}))}function G2(n,e,t){var s,r,i,a,o,u,c,d,p,m,g,x,b,v,w=e.outputTensorSize,N=e.keepAspectRatio,I=e.borderMode,$=e.outputTensorFloatRange,E=Ch(n),D=(function(z,M){return M?{xCenter:M.xCenter*z.width,yCenter:M.yCenter*z.height,width:M.width*z.width,height:M.height*z.height,rotation:M.rotation}:{xCenter:.5*z.width,yCenter:.5*z.height,width:z.width,height:z.height,rotation:0}})(E,t),F=(function(z,M,O){if(O===void 0&&(O=!1),!O)return{top:0,left:0,right:0,bottom:0};var H=M.height,X=M.width;W2(M,"targetSize"),W2(z,"roi");var te,Z,W=H/X,ee=z.height/z.width,ie=0,de=0;return W>ee?(te=z.width,Z=z.width*W,de=(1-ee/W)/2):(te=z.height/W,Z=z.height,ie=(1-W/ee)/2),z.width=te,z.height=Z,{top:de,left:ie,right:ie,bottom:de}})(D,w,N),L=(s=D,r=E.width,i=E.height,a=!1,o=s.width,u=s.height,c=a?-1:1,d=Math.cos(s.rotation),p=Math.sin(s.rotation),m=s.xCenter,g=s.yCenter,x=1/r,b=1/i,(v=new Array(16))[0]=o*d*c*x,v[1]=-u*p*x,v[2]=0,v[3]=(-.5*o*d*c+.5*u*p+m)*x,v[4]=o*p*c*b,v[5]=u*d*b,v[6]=0,v[7]=(-.5*u*d-.5*o*p*c+g)*b,v[8]=0,v[9]=0,v[10]=o*x,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,mL(v));return{imageTensor:he((function(){var z=JC(n),M=Ni(fL(L,E,w),[1,8]),O=I==="zero"?"constant":"nearest",H=Xs.transform(Wn(Fe(z,"float32")),M,"bilinear",O,0,[w.height,w.width]);return $!=null?gL(H,$):H})),padding:F,transformationMatrix:L}}function HE(n,e,t,s){return s===1?.5*(n+e):n+(e-n)*t/(s-1)}function _ve(n){return he((function(){var e=(function(r){return he((function(){return[dt(r,[0,0,0],[1,-1,1]),dt(r,[0,0,1],[1,-1,-1])]}))})(n),t=e[0],s=e[1];return{boxes:Wt(s),logits:Wt(t)}}))}function yL(n){return n!=null&&n.currentTime!=null}function jE(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,a=0;a<n.length;++a){var o=n[a];t=Math.min(t,o.x),s=Math.max(s,o.x),r=Math.min(r,o.y),i=Math.max(i,o.y),e.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:r,xMax:s,yMax:i,width:s-t,height:i-r},e}function Ove(n,e,t,s){return At(this,void 0,void 0,(function(){var r,i,a,o,u;return Dt(this,(function(c){switch(c.label){case 0:return n.sort((function(d,p){return Math.max.apply(Math,p.score)-Math.max.apply(Math,d.score)})),r=Ni(n.map((function(d){return[d.locationData.relativeBoundingBox.yMin,d.locationData.relativeBoundingBox.xMin,d.locationData.relativeBoundingBox.yMax,d.locationData.relativeBoundingBox.xMax]}))),i=Gn(n.map((function(d){return d.score[0]}))),[4,Xs.nonMaxSuppressionAsync(r,i,e,t)];case 1:return[4,(a=c.sent()).array()];case 2:return o=c.sent(),u=n.filter((function(d,p){return o.indexOf(p)>-1})),rt([r,i,a]),[2,u]}}))}))}function xL(n,e){return n.map((function(t){var s=cn(cn({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(s.z=t.z*e.width),s}))}function Fve(n,e,t){return At(this,void 0,void 0,(function(){var s,r,i,a,o,u,c,d,p,m,g,x,b,v,w,N,I,$,E,D,F,L,z,M;return Dt(this,(function(O){switch(O.label){case 0:if(s=Wt(e,[0]),r=s.shape,i=r[0],a=r[1],o=r[2],n.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(o));return u=[],[4,s.buffer()];case 1:for(c=O.sent(),d=0;d<n.length;d++)if(p=n[d],m=cn({},p),u.push(m),g=Math.trunc(m.x*a),x=Math.trunc(m.y*i),!(g<0||g>=a||x<0||g>=i)){for(b=Math.trunc((t.kernelSize-1)/2),v=Math.max(0,g-b),w=Math.min(a,g+b+1),N=Math.max(0,x-b),I=Math.min(i,x+b+1),$=0,E=0,D=0,F=0,L=N;L<I;++L)for(z=v;z<w;++z)M=c.get(L,z,d),$+=M,F=Math.max(F,M),E+=z*M,D+=L*M;F>=t.minConfidenceToRefine&&$>0&&(m.x=E/a/$,m.y=D/i/$)}return s.dispose(),[2,u]}}))}))}function qE(n,e){var t=e.left,s=e.top,r=e.left+e.right,i=e.top+e.bottom;return n.map((function(a){return cn(cn({},a),{x:(a.x-t)/(1-r),y:(a.y-s)/(1-i),z:a.z/(1-r)})}))}function zve(n,e,t){return lf()==="webgl"?(function(s,r,i){var a=i.combineWithPreviousRatio.toFixed(2),o={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(a,`);

      setOutput(outputValue);
    }
`)},u=ku();return he((function(){var c=u.compileAndRun(o,[s,r]);return Gs().makeTensorFromDataId(c.dataId,c.shape,c.dtype)}))})(n,e,t):he((function(){var s=Ue(e,.5),r=tn(s),i=Ue(1,pl(1,Q(r,$e(5.68842,Q(r,$e(-.748699,Q(r,$e(-57.8051,Q(r,$e(291.309,Q(r,-624.717)))))))))));return $e(e,Q(Ue(n,e),Q(i,t.combineWithPreviousRatio)))}))}function Lve(n,e,t){return At(this,void 0,void 0,(function(){var s,r,i,a,o;return Dt(this,(function(u){switch(u.label){case 0:return s=n[0],r=n[1],i=(function(c,d,p){return he((function(){var m,g,x,b;p.reverseOutputOrder?(g=Wt(dt(c,[0,p.boxCoordOffset+0],[-1,1])),m=Wt(dt(c,[0,p.boxCoordOffset+1],[-1,1])),b=Wt(dt(c,[0,p.boxCoordOffset+2],[-1,1])),x=Wt(dt(c,[0,p.boxCoordOffset+3],[-1,1]))):(m=Wt(dt(c,[0,p.boxCoordOffset+0],[-1,1])),g=Wt(dt(c,[0,p.boxCoordOffset+1],[-1,1])),x=Wt(dt(c,[0,p.boxCoordOffset+2],[-1,1])),b=Wt(dt(c,[0,p.boxCoordOffset+3],[-1,1]))),g=$e(Q(Ve(g,p.xScale),d.w),d.x),m=$e(Q(Ve(m,p.yScale),d.h),d.y),p.applyExponentialOnBoxSize?(x=Q(Ks(Ve(x,p.hScale)),d.h),b=Q(Ks(Ve(b,p.wScale)),d.w)):(x=Q(Ve(x,p.hScale),d.h),b=Q(Ve(b,p.wScale),d.h));var v=Ue(m,Ve(x,2)),w=Ue(g,Ve(b,2)),N=$e(m,Ve(x,2)),I=$e(g,Ve(b,2)),$=$n([ae(v,[p.numBoxes,1]),ae(w,[p.numBoxes,1]),ae(N,[p.numBoxes,1]),ae(I,[p.numBoxes,1])],1);if(p.numKeypoints)for(var E=0;E<p.numKeypoints;++E){var D=p.keypointCoordOffset+E*p.numValuesPerKeypoint,F=void 0,L=void 0;p.reverseOutputOrder?(F=Wt(dt(c,[0,D],[-1,1])),L=Wt(dt(c,[0,D+1],[-1,1]))):(L=Wt(dt(c,[0,D],[-1,1])),F=Wt(dt(c,[0,D+1],[-1,1])));var z=$e(Q(Ve(F,p.xScale),d.w),d.x),M=$e(Q(Ve(L,p.yScale),d.h),d.y);$=$n([$,ae(z,[p.numBoxes,1]),ae(M,[p.numBoxes,1])],1)}return $}))})(r,e,t),a=he((function(){var c=s;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=hr(s,-t.scoreClippingThresh,t.scoreClippingThresh)),c=qr(c)):c})),[4,Mve(i,a,t)];case 1:return o=u.sent(),rt([i,a]),[2,o]}}))}))}function Mve(n,e,t){return At(this,void 0,void 0,(function(){var s,r,i,a,o,u,c,d,p,m,g,x;return Dt(this,(function(b){switch(b.label){case 0:return s=[],[4,n.data()];case 1:return r=b.sent(),[4,e.data()];case 2:for(i=b.sent(),a=0;a<t.numBoxes;++a)if(!(t.minScoreThresh!=null&&i[a]<t.minScoreThresh||(o=a*t.numCoords,u=Pve(r[o+0],r[o+1],r[o+2],r[o+3],i[a],t.flipVertically,a),(c=u.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((d=u.locationData).relativeKeypoints=[],p=t.numKeypoints*t.numValuesPerKeypoint,m=0;m<p;m+=t.numValuesPerKeypoint)g=o+t.keypointCoordOffset+m,x={x:r[g+0],y:t.flipVertically?1-r[g+1]:r[g+1]},d.relativeKeypoints.push(x);s.push(u)}return[2,s]}}))}))}function Pve(n,e,t,s,r,i,a){return{score:[r],ind:a,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-t:n,xMax:s,yMax:i?1-n:t,width:s-e,height:t-n}}}}function Bve(n,e){return n==="none"?e:(function(t){return 1/(1+Math.exp(-t))})(e)}function XE(n,e,t,s){return At(this,void 0,void 0,(function(){var r,i,a,o,u,c,d,p;return Dt(this,(function(m){switch(m.label){case 0:return t=t||e.flipHorizontally||!1,s=s||e.flipVertically||!1,r=n.size,i=r/e.numLandmarks,[4,n.data()];case 1:for(a=m.sent(),o=[],u=0;u<e.numLandmarks;++u)c=u*i,(p={x:0,y:0}).x=t?e.inputImageWidth-a[c]:a[c],i>1&&(p.y=s?e.inputImageHeight-a[c+1]:a[c+1]),i>2&&(p.z=a[c+2]),i>3&&(p.score=Bve(e.visibilityActivation,a[c+3])),o.push(p);for(d=0;d<o.length;++d)(p=o[d]).x=p.x/e.inputImageWidth,p.y=p.y/e.inputImageHeight,p.z=p.z/e.inputImageWidth/(e.normalizeZ||1);return[2,o]}}))}))}function KE(n,e,t){var s=n.width,r=n.height,i=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(i=(function(c,d){return d.rotation!=null?c+=d.rotation:d.rotationDegree!=null&&(c+=Math.PI*d.rotationDegree/180),pL(c)})(i,t)),i===0)n.xCenter=n.xCenter+s*t.shiftX,n.yCenter=n.yCenter+r*t.shiftY;else{var a=(e.width*s*t.shiftX*Math.cos(i)-e.height*r*t.shiftY*Math.sin(i))/e.width,o=(e.width*s*t.shiftX*Math.sin(i)+e.height*r*t.shiftY*Math.cos(i))/e.height;n.xCenter=n.xCenter+a,n.yCenter=n.yCenter+o}{var u=Math.max(s*e.width,r*e.height);s=u/e.width,r=u/e.height}return n.width=s*t.scaleX,n.height=r*t.scaleY,n}function Vve(n,e){return n.map((function(t){var s=cn(cn({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),s}))}var sl=(function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var s;return this.initialized?s=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(s=e,this.initialized=!0),this.rawValue=e,this.storedValue=s,s},n.prototype.applyWithAlpha=function(e,t,s){return this.alpha=t,this.apply(e,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n})(),Ow=(function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new sl(this.getAlpha(this.minCutOff)),this.dx=new sl(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,s){if(e==null)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;this.lastTimestamp!==0&&r!==0&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*s*this.frequency:0,a=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(a),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(e,this.getAlpha(o),u)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n})(),H2=(function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var r=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return gu([],e,!0);i=1/s}return e.map((function(a,o){var u=cn(cn({},a),{x:r.xFilters[o].apply(a.x,t,i),y:r.yFilters[o].apply(a.y,t,i)});return a.z!=null&&(u.z=r.zFilters[o].apply(a.z,t,i)),u}))},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map((function(s){return new Ow(t.config)})),this.yFilters=e.map((function(s){return new Ow(t.config)})),this.zFilters=e.map((function(s){return new Ow(t.config)})))},n})(),Fw=(function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new sl(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,s){if(e==null)return e;var r,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(this.lastTimestamp===-1)r=1;else{for(var a=e*s-this.lastValue*this.lastValueScale,o=i-this.lastTimestamp,u=a,c=o,d=(1+this.window.length)*(1e6/30),p=0,m=this.window;p<m.length;p++){var g=m[p];if(c+g.duration>d)break;u+=g.distance,c+=g.duration}var x=u/(1e-6*c);r=1-1/(1+this.config.velocityScale*Math.abs(x)),this.window.unshift({distance:a,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=s,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,r)},n})(),Uve=(function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var r=this;if(e==null)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return gu([],e,!0);i=1/s}return this.initializeFiltersIfEmpty(e),e.map((function(a,o){var u=cn(cn({},a),{x:r.xFilters[o].apply(a.x,t,i),y:r.yFilters[o].apply(a.y,t,i)});return a.z!=null&&(u.z=r.zFilters[o].apply(a.z,t,i)),u}))},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map((function(s){return new Fw(t.config)})),this.yFilters=e.map((function(s){return new Fw(t.config)})),this.zFilters=e.map((function(s){return new Fw(t.config)})))},n})(),zw=(function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new Uve(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new H2(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,s,r,i){if(r===void 0&&(r=!1),e==null)return this.keypointsFilter.reset(),null;var a=i!=null?(function(c,d){return(c.width*d.width+c.height*d.height)/2})(i,s):1,o=r?xL(e,s):e,u=this.keypointsFilter.apply(o,t,a);return r?Vve(u,s):u},n})(),YE=(function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(o){return new sl(t.alpha)})));for(var s=[],r=0;r<e.length;++r){var i=e[r],a=cn({},i);a.score=this.visibilityFilters[r].apply(i.score),s.push(a)}return s},n})(),Wve={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Qc={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Gve={maxPoses:1,flipHorizontal:!1},Hve={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},jve=.3,QE={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},qve={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Xve={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Kve={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Yve={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Qve={kernelSize:7,minConfidenceToRefine:.5},ZE={alpha:.1},Zve={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Jve={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},ewe={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},twe={activation:"none"},nwe={combineWithPreviousRatio:.7},swe=(function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,cL(this.mask)]}))}))},n.prototype.toImageData=function(){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,hL(this.mask)]}))}))},n.prototype.toTensor=function(){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,this.mask]}))}))},n.prototype.getUnderlyingType=function(){return"tensor"},n})();function rwe(n){return dL(n),"person"}var iwe=(function(){function n(e,t,s,r,i,a){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=s,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=(function(p){p.reduceBoxesInLowestLayer==null&&(p.reduceBoxesInLowestLayer=!1),p.interpolatedScaleAspectRatio==null&&(p.interpolatedScaleAspectRatio=1),p.fixedAnchorSize==null&&(p.fixedAnchorSize=!1);for(var m=[],g=0;g<p.numLayers;){for(var x=[],b=[],v=[],w=[],N=g;N<p.strides.length&&p.strides[N]===p.strides[g];){var I=HE(p.minScale,p.maxScale,N,p.strides.length);if(N===0&&p.reduceBoxesInLowestLayer)v.push(1),v.push(2),v.push(.5),w.push(.1),w.push(I),w.push(I);else{for(var $=0;$<p.aspectRatios.length;++$)v.push(p.aspectRatios[$]),w.push(I);if(p.interpolatedScaleAspectRatio>0){var E=N===p.strides.length-1?1:HE(p.minScale,p.maxScale,N+1,p.strides.length);w.push(Math.sqrt(I*E)),v.push(p.interpolatedScaleAspectRatio)}}N++}for(var D=0;D<v.length;++D){var F=Math.sqrt(v[D]);x.push(w[D]/F),b.push(w[D]*F)}var L=0,z=0;if(p.featureMapHeight.length>0)L=p.featureMapHeight[g],z=p.featureMapWidth[g];else{var M=p.strides[g];L=Math.ceil(p.inputSizeHeight/M),z=Math.ceil(p.inputSizeWidth/M)}for(var O=0;O<L;++O)for(var H=0;H<z;++H)for(var X=0;X<x.length;++X){var te={xCenter:(H+p.anchorOffsetX)/z,yCenter:(O+p.anchorOffsetY)/L,width:0,height:0};p.fixedAnchorSize?(te.width=1,te.height=1):(te.width=b[X],te.height=x[X]),m.push(te)}g=N}return m})(Wve);var o=Gn(this.anchors.map((function(p){return p.width}))),u=Gn(this.anchors.map((function(p){return p.height}))),c=Gn(this.anchors.map((function(p){return p.xCenter}))),d=Gn(this.anchors.map((function(p){return p.yCenter})));this.anchorTensor={x:c,y:d,w:o,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?Ni([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,s){return At(this,void 0,void 0,(function(){var r,i,a,o,u,c,d,p,m,g,x,b,v,w,N,I,$,E,D,F,L,z,M;return Dt(this,(function(O){switch(O.label){case 0:return r=(function(H){var X;if((X=H==null?Gve:cn({},H)).maxPoses==null&&(X.maxPoses=1),X.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(X.maxPoses,". Should be > 0."));if(X.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return X})(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=s!=null?1e3*s:yL(e)?1e6*e.currentTime:null,i=Ch(e),a=he((function(){return Fe(JC(e),"float32")})),(o=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(a)]);case 1:if((u=O.sent()).length===0)return this.reset(),a.dispose(),[2,[]];c=u[0],o=this.poseDetectionToRoi(c,i),O.label=2;case 2:return[4,this.poseLandmarksByRoi(o,a)];case 3:return d=O.sent(),a.dispose(),d==null?(this.reset(),[2,[]]):(p=d.landmarks,m=d.auxiliaryLandmarks,g=d.poseScore,x=d.worldLandmarks,b=d.segmentationMask,v=this.poseLandmarkFiltering(p,m,x,i),w=v.actualLandmarksFiltered,N=v.auxiliaryLandmarksFiltered,I=v.actualWorldLandmarksFiltered,$=this.poseLandmarksToRoi(N,i),this.regionOfInterest=$,E=this.smoothSegmentation&&b!=null?this.poseSegmentationFiltering(b):b,(D=w!=null?xL(w,i):null)!=null&&D.forEach((function(H,X){H.name=$f[X]})),(F=I)!=null&&F.forEach((function(H,X){H.name=$f[X]})),L={score:g,keypoints:D,keypoints3D:F},E!==null&&(z=he((function(){var H=Wn(E,2),X=qi(H,[[0,0],[0,0],[0,1]]);return AS(X,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||rt(E),M={maskValueToLabel:rwe,mask:new swe(z)},L.segmentation=M),[2,[L]])}}))}))},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=zve(t,e,nwe),rt(e)),rt(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),rt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(rt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Ni([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return At(this,void 0,void 0,(function(){var t,s,r,i,a,o,u,c,d,p;return Dt(this,(function(m){switch(m.label){case 0:return t=G2(e,qve),s=t.imageTensor,r=t.padding,i=this.detectorModel.predict(s),a=_ve(i),o=a.boxes,[4,Lve([u=a.logits,o],this.anchorTensor,Hve)];case 1:return(c=m.sent()).length===0?(rt([s,i,u,o]),[2,c]):[4,Ove(c,this.maxPoses,jve)];case 2:return d=m.sent(),p=(function(g,x){g===void 0&&(g=[]);for(var b=x.left,v=x.top,w=x.left+x.right,N=x.top+x.bottom,I=0;I<g.length;I++){var $=g[I],E=$.locationData.relativeBoundingBox,D=(E.xMin-b)/(1-w),F=(E.yMin-v)/(1-N),L=E.width/(1-w),z=E.height/(1-N);E.xMin=D,E.yMin=F,E.width=L,E.height=z,E.xMax=D+L,E.yMax=F+z;var M=$.locationData.relativeKeypoints;M&&M.forEach((function(O){var H=(O.x-b)/(1-w),X=(O.y-v)/(1-N);O.x=H,O.y=X}))}return g})(d,r),rt([s,i,u,o]),[2,p]}}))}))},n.prototype.poseDetectionToRoi=function(e,t){return KE(Dw(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,QE)},n.prototype.poseLandmarksByRoi=function(e,t){return At(this,void 0,void 0,(function(){var s,r,i,a,o,u,c,d,p,m,g,x,b,v;return Dt(this,(function(w){switch(w.label){case 0:if(s=Ch(t),r=G2(t,Xve,e),i=r.imageTensor,a=r.padding,o=r.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),c=this.landmarkModel.execute(i,u),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(d=w.sent())==null?(rt(c),rt(i),[2,null]):(p=d.landmarks,m=d.auxiliaryLandmarks,g=d.poseScore,x=d.worldLandmarks,b=d.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,e,a,o,p,m,x,b)]);case 2:return v=w.sent(),rt(c),rt(i),[2,cn({poseScore:g},v)]}}))}))},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,s,r,i,a,o,u){return At(this,void 0,void 0,(function(){var c,d,p,m,g,x;return Dt(this,(function(b){return c=qE(i,s),d=qE(a,s),p=GE(c,t),m=GE(d,t),g=(function(v,w){for(var N=[],I=0,$=v;I<$.length;I++){var E=$[I],D=E.x,F=E.y,L=w.rotation,z=Math.cos(L)*D-Math.sin(L)*F,M=Math.sin(L)*D+Math.cos(L)*F,O=cn({},E);O.x=z,O.y=M,N.push(O)}return N})(o,t),x=null,this.enableSegmentation&&(x=he((function(){var v=u.shape,w=v[0],N=v[1],I=(function(D){var F=mL(new Array(16).fill(0));F[0][0]=Ws(D,0,0),F[1][0]=-Ws(D,0,1),F[2][0]=Ws(D,0,2),F[3][0]=-Ws(D,0,3),F[0][2]=Ws(D,2,0),F[1][2]=-Ws(D,2,1),F[2][2]=Ws(D,2,2),F[3][2]=-Ws(D,2,3),F[0][1]=-Ws(D,1,0),F[1][1]=Ws(D,1,1),F[2][1]=-Ws(D,1,2),F[3][1]=Ws(D,1,3),F[0][3]=-Ws(D,3,0),F[1][3]=Ws(D,3,1),F[2][3]=-Ws(D,3,2),F[3][3]=Ws(D,3,3);for(var L=D[0][0]*F[0][0]+D[1][0]*F[0][1]+D[2][0]*F[0][2]+D[3][0]*F[0][3],z=0;z<F.length;z++)for(var M=0;M<F.length;M++)F[z][M]/=L;return F})(r),$=Ni(fL(I,{width:N,height:w},e),[1,8]),E=[1,w,N,1];return Wt(Xs.transform(ae(u,E),$,"bilinear","constant",0,[e.height,e.width]),[0,3])})),rt(u)),[2,{landmarks:p,auxiliaryLandmarks:m,worldLandmarks:g,segmentationMask:x}]}))}))},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return At(this,void 0,void 0,(function(){var t,s,r,i,a,o,u,c,d,p,m,g,x;return Dt(this,(function(b){switch(b.label){case 0:return t=e[0],s=e[1],r=e[2],i=e[3],a=this.enableSegmentation?e[4]:null,[4,s.data()];case 1:return(o=b.sent()[0])<.5?[2,null]:[4,XE(t,Kve)];case 2:return[4,Fve(b.sent(),r,Qve)];case 3:return u=b.sent(),c=u.slice(0,33),d=u.slice(33,35),[4,XE(i,Yve)];case 4:return p=b.sent(),m=p.slice(0,33),g=(function(v,w,N){for(var I=[],$=0;$<v.length;$++){var E=cn({},w[$]);E.score=v[$].score,I.push(E)}return I})(c,m),x=this.enableSegmentation?(function(v,w,N){return he((function(){var I=Wt(v,[0]),$=I.shape[2];if($===1){var E=I;switch(w.activation){case"none":break;case"sigmoid":E=qr(E);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(w.activation,")"))}var D=E;return Wt(D,[2])}throw new Error("Unsupported number of tensor channels ".concat($))}))})(a,twe):null,[2,{landmarks:c,auxiliaryLandmarks:d,poseScore:o,worldLandmarks:g,segmentationMask:x}]}}))}))},n.prototype.poseLandmarksToRoi=function(e,t){return KE(Dw(jE(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,QE)},n.prototype.poseLandmarkFiltering=function(e,t,s,r){var i,a,o;if(this.timestamp!=null&&this.enableSmoothing){var u=Dw(jE(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new YE(ZE)),i=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new YE(ZE)),a=this.visibilitySmoothingFilterAuxiliary.apply(t),o=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new zw(Zve)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new zw(Jve)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,r,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new zw(ewe)),o=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else i=e,a=t,o=s;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:o}},n})();function awe(n){return At(this,void 0,void 0,(function(){var e,t,s,r,i,a;return Dt(this,(function(o){switch(o.label){case 0:return e=(function(u){var c=cn({},u??Qc);if(c.enableSmoothing==null&&(c.enableSmoothing=Qc.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Qc.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Qc.smoothSegmentation),c.modelType==null&&(c.modelType=Qc.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Qc.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c})(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([gh(e.detectorModelUrl,{fromTFHub:t}),gh(e.landmarkModelUrl,{fromTFHub:s})])];case 1:return r=o.sent(),i=r[0],a=r[1],[2,new iwe(i,a,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}}))}))}var wu,va,bL=(function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,r=t.keypointTrackerParams.keypointFalloff;s<r.length;s++){var i=r[s];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var s=this.computeSimilarity(e);return this.assignTracks(e,s,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(s){return e-s.lastTimestamp<=t.maxAge}))},n.prototype.assignTracks=function(e,t,s){for(var r=Array.from(Array(t[0].length).keys()),i=[],a=0,o=Array.from(Array(e.length).keys());a<o.length;a++){var u=o[a];if(r.length!==0){for(var c=-1,d=-1,p=0,m=r;p<m.length;p++){var g=m[p],x=t[u][g];x>=this.minSimilarity&&x>d&&(c=g,d=x)}if(c>=0){var b=this.tracks[c];b=Object.assign(b,this.createTrack(e[u],s,b.id)),e[u].id=b.id;var v=r.indexOf(c);r.splice(v,1)}else i.push(u)}else i.push(u)}for(var w=0,N=i;w<N.length;w++){u=N[w];var I=this.createTrack(e[u],s);this.tracks.push(I),e[u].id=I.id}},n.prototype.updateTracks=function(e){this.tracks.sort((function(t,s){return s.lastTimestamp-t.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,s){var r={id:s||this.nextTrackID(),lastTimestamp:t,keypoints:gu([],e.keypoints,!0).map((function(i){return cn({},i)}))};return e.box!==void 0&&(r.box=cn({},e.box)),r},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(s){return!e.includes(s.id)}))},n.prototype.reset=function(){this.tracks=[]},n})(),owe=(function(n){function e(t){return n.call(this,t)||this}return uL(e,n),e.prototype.computeSimilarity=function(t){var s=this;return t.length===0||this.tracks.length===0?[[]]:t.map((function(r){return s.tracks.map((function(i){return s.iou(r,i)}))}))},e.prototype.iou=function(t,s){var r=Math.max(t.box.xMin,s.box.xMin),i=Math.max(t.box.yMin,s.box.yMin),a=Math.min(t.box.xMax,s.box.xMax),o=Math.min(t.box.yMax,s.box.yMax);if(r>=a||i>=o)return 0;var u=(a-r)*(o-i);return u/(t.box.width*t.box.height+s.box.width*s.box.height-u)},e})(bL),lwe=(function(n){function e(t){var s=n.call(this,t)||this;return s.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=t.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,s}return uL(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var s=[],r=0,i=t;r<i.length;r++){for(var a=i[r],o=[],u=0,c=this.tracks;u<c.length;u++){var d=c[u];o.push(this.oks(a,d))}s.push(o)}return s},e.prototype.oks=function(t,s){for(var r=this.area(s.keypoints)+1e-6,i=0,a=0,o=0;o<t.keypoints.length;++o){var u=t.keypoints[o],c=s.keypoints[o];if(!(u.score<this.keypointThreshold||c.score<this.keypointThreshold)){a+=1;var d=Math.pow(u.x-c.x,2)+Math.pow(u.y-c.y,2),p=2*this.keypointFalloff[o];i+=Math.exp(-1*d/(2*r*Math.pow(p,2)))}}return a<this.minNumKeyoints?0:i/a},e.prototype.area=function(t){var s=this,r=t.filter((function(u){return u.score>s.keypointThreshold})),i=Math.min.apply(Math,gu([1],r.map((function(u){return u.x})),!1)),a=Math.max.apply(Math,gu([0],r.map((function(u){return u.x})),!1)),o=Math.min.apply(Math,gu([1],r.map((function(u){return u.y})),!1));return(a-i)*(Math.max.apply(Math,gu([0],r.map((function(u){return u.y})),!1))-o)},e})(bL);function uwe(n){switch(n){case va.BlazePose:return $f.reduce((function(e,t,s){return e[t]=s,e}),{});case va.PoseNet:case va.MoveNet:return ka.reduce((function(e,t,s){return e[t]=s,e}),{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(wu||(wu={})),(function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"})(va||(va={}));var JE=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],vL={modelType:"SinglePose.Lightning",enableSmoothing:!0},eR={},tR={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Lw={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},nR={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function cwe(n,e,t,s){for(var r={},i=0,a=ka;i<a.length;i++){var o=a[i];r[o]=[e[t[o]].y*s.height,e[t[o]].x*s.width]}if((function(N,I){return(N[I.left_hip].score>.2||N[I.right_hip].score>.2)&&(N[I.left_shoulder].score>.2||N[I.right_shoulder].score>.2)})(e,t)){var u=(r.left_hip[0]+r.right_hip[0])/2,c=(r.left_hip[1]+r.right_hip[1])/2,d=(function(N,I,$,E,D){for(var F=["left_shoulder","right_shoulder","left_hip","right_hip"],L=0,z=0,M=0;M<F.length;M++)(Z=Math.abs(E-$[F[M]][0]))>L&&(L=Z),(W=Math.abs(D-$[F[M]][1]))>z&&(z=W);for(var O=0,H=0,X=0,te=Object.keys($);X<te.length;X++){var Z,W,ee=te[X];N[I[ee]].score<.2||((Z=Math.abs(E-$[ee][0]))>O&&(O=Z),(W=Math.abs(D-$[ee][1]))>H&&(H=W))}return[L,z,O,H]})(e,t,r,u,c),p=d[0],m=d[1],g=d[2],x=d[3],b=Math.max(1.9*m,1.9*p,1.2*g,1.2*x),v=[u-(b=Math.min(b,Math.max(c,s.width-c,u,s.height-u))),c-b];if(b>Math.max(s.width,s.height)/2)return j2(n==null,s);var w=2*b;return{yMin:v[0]/s.height,xMin:v[1]/s.width,yMax:(v[0]+w)/s.height,xMax:(v[1]+w)/s.width,height:(v[0]+w)/s.height-v[0]/s.height,width:(v[1]+w)/s.width-v[1]/s.width}}return j2(n==null,s)}function j2(n,e){var t,s,r,i;return n?e.width>e.height?(t=1,s=e.height/e.width,r=0,i=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,i=0):e.width>e.height?(t=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,i=0):(t=1,s=e.height/e.width,r=0,i=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:i,yMax:r+t,xMax:i+s,height:t,width:s}}function hwe(n){var e,t=n==null?vL:cn({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(JE.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(JE));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=wu.BoundingBox),t.trackerType===wu.Keypoint)t.trackerConfig!=null?t.trackerConfig=(function(s){var r=sR(Lw,s);return r.keypointTrackerParams=cn({},Lw.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(r.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(r.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),r})(t.trackerConfig):t.trackerConfig=Lw;else{if(t.trackerType!==wu.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,sR(nR,e)):t.trackerConfig=nR}return t}function sR(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var dwe=(function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=uwe(va.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new H2(tR),this.cropRegionFilterYMin=new sl(.9),this.cropRegionFilterXMin=new sl(.9),this.cropRegionFilterYMax=new sl(.9),this.cropRegionFilterXMax=new sl(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===wu.Keypoint?this.tracker=new lwe(t.trackerConfig):t.trackerType===wu.BoundingBox&&(this.tracker=new owe(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return At(this,void 0,void 0,(function(){var t,s,r,i,a;return Dt(this,(function(o){switch(o.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return lf()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=o.sent(),o.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},i=0,a=0;a<17;++a)r.keypoints[a]={y:s[3*a],x:s[3*a+1],score:s[3*a+2]},r.keypoints[a].score>.2&&(++i,r.score+=r.keypoints[a].score);return i>0&&(r.score/=i),[2,r]}}))}))},n.prototype.runMultiPersonPoseModel=function(e){return At(this,void 0,void 0,(function(){var t,s,r,i,a,o,u,c;return Dt(this,(function(d){switch(d.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return lf()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=d.sent(),d.label=3;case 3:for(t.dispose(),r=[],i=s.length/56,a=0;a<i;++a)for(r[a]={keypoints:[]},o=56*a+51,r[a].box={yMin:s[o],xMin:s[o+1],yMax:s[o+2],xMax:s[o+3],width:s[o+3]-s[o+1],height:s[o+2]-s[o]},u=56*a+55,r[a].score=s[u],r[a].keypoints=[],c=0;c<17;++c)r[a].keypoints[c]={y:s[56*a+3*c],x:s[56*a+3*c+1],score:s[56*a+3*c+2]};return[2,r]}}))}))},n.prototype.estimatePoses=function(e,t,s){return t===void 0&&(t=eR),At(this,void 0,void 0,(function(){var r,i,a,o,u,c;return Dt(this,(function(d){switch(d.label){case 0:return t=(function(p){return p==null?eR:cn({},p)})(t),e==null?(this.reset(),[2,[]]):(s==null?yL(e)&&(s=1e6*e.currentTime):s*=1e3,r=JC(e),i=Ch(r),a=Wn(r,0),e instanceof Kt||r.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,i,s)]);case 1:return o=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,i,s)];case 3:o=d.sent(),d.label=4;case 4:for(u=0;u<o.length;++u)for(c=0;c<o[u].keypoints.length;++c)o[u].keypoints[c].name=ka[c],o[u].keypoints[c].y*=i.height,o[u].keypoints[c].x*=i.width;return[2,o]}}))}))},n.prototype.estimateSinglePose=function(e,t,s){return At(this,void 0,void 0,(function(){var r,i,a,o,u=this;return Dt(this,(function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=j2(this.cropRegion==null,t)),r=he((function(){var d=Ni([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),p=zn([1],"int32"),m=[u.modelInputResolution.height,u.modelInputResolution.width];return Fe(Xs.cropAndResize(e,d,p,m,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(i=c.sent(),r.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<i.keypoints.length;++a)i.keypoints[a].y=this.cropRegion.yMin+i.keypoints[a].y*this.cropRegion.height,i.keypoints[a].x=this.cropRegion.xMin+i.keypoints[a].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,s,1)),o=cwe(this.cropRegion,i.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(o),[2,[i]]}}))}))},n.prototype.estimateMultiplePoses=function(e,t,s){return At(this,void 0,void 0,(function(){var r,i,a,o,u,c,d,p,m,g,x,b=this;return Dt(this,(function(v){switch(v.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=Xs.resizeBilinear(e,[a,i]),u=i,c=32*Math.ceil(a/32),o=qi(r,[[0,0],[0,c-a],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),a=this.multiPoseMaxDimension,r=Xs.resizeBilinear(e,[a,i]),u=32*Math.ceil(i/32),c=a,o=qi(r,[[0,0],[0,0],[0,u-i],[0,0]])),r.dispose(),e.dispose(),d=Fe(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(d)];case 1:for(p=v.sent(),d.dispose(),p=p.filter((function(w){return w.score>=b.minPoseScore})),g=0;g<p.length;++g)for(m=0;m<p[g].keypoints.length;++m)p[g].keypoints[m].y*=c/a,p[g].keypoints[m].x*=u/i;if(this.enableTracking&&(this.tracker.apply(p,s),this.enableSmoothing)){for(g=0;g<p.length;++g)this.keypointFilterMap.has(p[g].id)||this.keypointFilterMap.set(p[g].id,new H2(tR)),p[g].keypoints=this.keypointFilterMap.get(p[g].id).apply(p[g].keypoints,s,1);x=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(w,N){x.has(N)||b.keypointFilterMap.delete(N)}))}return[2,p]}}))}))},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),s=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:s,yMax:r,xMax:i,height:r-t,width:i-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n})();function pwe(n){return n===void 0&&(n=vL),At(this,void 0,void 0,(function(){var e,t,s,r;return Dt(this,(function(i){switch(i.label){case 0:return e=hwe(n),s=!0,e.modelUrl?(s=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,gh(e.modelUrl,{fromTFHub:s})]):[3,2];case 1:return t=i.sent(),[3,4];case 2:return r=void 0,e.modelType==="SinglePose.Lightning"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,gh(r,{fromTFHub:s})];case 3:t=i.sent(),i.label=4;case 4:return lf()==="webgl"&&fe().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new dwe(t,e)]}}))}))}var rR={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},iR=["MobileNetV1","ResNet50"],aR={MobileNetV1:[8,16],ResNet50:[16]},fwe=[8,16,32],oR={MobileNetV1:[.5,.75,1],ResNet50:[1]},lR=[1,2,4],uR={maxPoses:1,flipHorizontal:!1},mwe={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},gwe=[-123.15,-115.9,-103.06];function Mw(n){return Math.floor(n/2)}var ywe=(function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(Mw(e),e);)this.exchange(e,Mw(e)),e=Mw(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=s},n})();function xwe(n,e,t,s,r,i){for(var a=i.shape,o=a[0],u=a[1],c=!0,d=Math.max(t-r,0),p=Math.min(t+r+1,o),m=d;m<p;++m){for(var g=Math.max(s-r,0),x=Math.min(s+r+1,u),b=g;b<x;++b)if(i.get(m,b,n)>e){c=!1;break}if(!c)break}return c}function bwe(n){return At(this,void 0,void 0,(function(){return Dt(this,(function(e){return[2,Promise.all(n.map((function(t){return t.buffer()})))]}))}))}function wL(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+17)}}function SL(n,e,t){var s=wL(n.heatmapY,n.heatmapX,n.id,t),r=s.y,i=s.x;return{x:n.heatmapX*e+i,y:n.heatmapY*e+r}}function CL(n,e,t,s){var r=t.x,i=t.y;return n.some((function(a){var o,u,c,d,p,m,g=a.keypoints;return o=i,u=r,c=g[s].y,d=g[s].x,(p=c-o)*p+(m=d-u)*m<=e}))}var cR=ka.reduce((function(n,e,t){return n[e]=t,n}),{}),NL=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(n){var e=n[0],t=n[1];return[cR[e],cR[t]]})),Pw=NL.map((function(n){return n[1]})),hR=NL.map((function(n){return n[0]}));function dR(n,e,t){return n<e?e:n>t?t:n}function Bw(n,e,t,s){return{y:dR(Math.round(n.y/e),0,t-1),x:dR(Math.round(n.x/e),0,s-1)}}function pR(n,e){return{x:n.x+e.x,y:n.y+e.y}}function fR(n,e,t,s,r,i,a,o){o===void 0&&(o=2);for(var u=s.shape,c=u[0],d=u[1],p={y:e.y,x:e.x},m=pR(p,(function(N,I,$){var E=$.shape[2]/2;return{y:$.get(I.y,I.x,N),x:$.get(I.y,I.x,E+N)}})(n,Bw(p,i,c,d),a)),g=0;g<o;g++){var x=Bw(m,i,c,d),b=wL(x.y,x.x,t,r);m=pR({x:x.x*i,y:x.y*i},{x:b.x,y:b.y})}var v=Bw(m,i,c,d),w=s.get(v.y,v.x,t);return{y:m.y,x:m.x,name:ka[t],score:w}}function vwe(n,e,t,s,r,i){var a=e.shape[2],o=Pw.length,u=new Array(a),c=n.part,d=n.score,p=SL(c,s,t);u[c.id]={score:d,name:ka[c.id],y:p.y,x:p.x};for(var m=o-1;m>=0;--m){var g=Pw[m],x=hR[m];u[g]&&!u[x]&&(u[x]=fR(m,u[g],x,e,t,s,i))}for(m=0;m<o;++m)g=hR[m],x=Pw[m],u[g]&&!u[x]&&(u[x]=fR(m,u[g],x,e,t,s,r));return u}function wwe(n,e,t){return t.reduce((function(s,r,i){var a=r.y,o=r.x,u=r.score;return CL(n,e,{y:a,x:o},i)||(s+=u),s}),0)/t.length}function Swe(n,e,t,s,r,i,a,o){return a===void 0&&(a=.5),o===void 0&&(o=20),At(this,void 0,void 0,(function(){var u,c,d,p,m,g,x,b,v,w,N,I;return Dt(this,(function($){switch($.label){case 0:return[4,bwe([n,e,t,s])];case 1:for(u=$.sent(),c=u[0],d=u[1],p=u[2],m=u[3],g=[],x=(function(E,D,F){for(var L=F.shape,z=L[0],M=L[1],O=L[2],H=new ywe(z*M*O,(function(ee){return ee.score})),X=0;X<z;++X)for(var te=0;te<M;++te)for(var Z=0;Z<O;++Z){var W=F.get(X,te,Z);W<E||xwe(Z,W,X,te,D,F)&&H.enqueue({score:W,part:{heatmapY:X,heatmapX:te,id:Z}})}return H})(a,1,c),b=o*o;g.length<i&&!x.empty();)v=x.dequeue(),w=SL(v.part,r,d),CL(g,b,w,v.part.id)||(N=vwe(v,c,d,r,p,m),I=wwe(g,b,N),g.push({keypoints:N,score:I}));return[2,g]}}))}))}function kL(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var Cwe=(function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=We(this.outputShape),this.dispatch=Le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(kL("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n})();function Nwe(n,e){if(ku()instanceof Md)return(function(t,s){var r=ku(),i=new Cwe(s.shape),a=r.runWebGPUProgram(i,[t,s],"float32");return Gs().makeTensorFromTensorInfo(a)})(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var kwe=(function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=We(t),this.dispatch=Le(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(kL("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n})();function $we(n,e){if(ku()instanceof Md)return(function(t,s){var r=ku(),i=new kwe(t.shape),a=r.runWebGPUProgram(i,[t,s],"float32");return Gs().makeTensorFromTensorInfo(a)})(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function $L(n){var e=n.shape,t=e[0],s=e[1],r=e[2];return he((function(){var i,a,o=ae(n,[t*s,r]),u=Tu(o,0),c=Wn(Ve(u,Je(s,"int32")),1),d=Wn((i=u,a=s,he((function(){var p=Ve(i,Je(a,"int32"));return Ue(i,Q(p,Je(a,"int32")))}))),1);return $n([c,d],1)}))}function Iwe(n,e,t){return he((function(){var s=(function(r,i){for(var a=[],o=0;o<ka.length;o++){var u=r.get(o,0).valueOf(),c=r.get(o,1).valueOf(),d=Twe(u,c,o,i),p=d.x,m=d.y;a.push(m),a.push(p)}return Ni(a,[ka.length,2])})(n,t);return $e(Fe(Q(n.toTensor(),Je(e,"int32")),"float32"),s)}))}function Twe(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+ka.length)}}function Ewe(n,e,t){return At(this,void 0,void 0,(function(){var s,r,i,a,o,u,c,d,p,m;return Dt(this,(function(g){switch(g.label){case 0:return s=0,r=$L(n),[4,Promise.all([n.buffer(),e.buffer(),r.buffer()])];case 1:return i=g.sent(),a=i[0],o=i[1],u=i[2],[4,(c=Iwe(u,t,o)).buffer()];case 2:return d=g.sent(),p=Array.from((function(x,b){for(var v=b.shape[0],w=new Float32Array(v),N=0;N<v;N++){var I=b.get(N,0),$=b.get(N,1);w[N]=x.get(I,$,N)}return w})(a,u)),m=p.map((function(x,b){return s+=x,{y:d.get(b,0),x:d.get(b,1),score:x,name:ka[b]}})),r.dispose(),c.dispose(),[2,{keypoints:m,score:s/m.length}]}}))}))}function Rwe(n,e,t){return At(this,void 0,void 0,(function(){var s,r,i;return Dt(this,(function(a){return s=$L(n),r=(function(o,u,c){return he((function(){var d=$we(o,c);return $e(Fe(Q(o,Je(u,"int32")),"float32"),d)}))})(s,t,e),i=Nwe(n,s),[2,[r,i]]}))}))}function mR(n,e){return(n-1)%e==0}var gR="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",yR="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function xR(n,e){return(function(t,s){return(t-1)%s==0})(n,e)?n:Math.floor(n/e)*e+1}var bR=(function(){function n(e,t){this.posenetModel=e;var s=this.posenetModel.inputs[0].shape;B(s[1]===-1&&s[2]===-1,(function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"}));var r,i,a=(r=t.inputResolution,i=t.outputStride,{height:xR(r.height,i),width:xR(r.width,i)});(function(o){B(fwe.indexOf(o)>=0,(function(){return"outputStride of ".concat(o," is invalid. ")+"It must be either 8 or 16."}))})(t.outputStride),(function(o,u){B(mR(o.height,u),(function(){return"height of ".concat(o.height," is invalid for output stride ")+"".concat(u,".")})),B(mR(o.width,u),(function(){return"width of ".concat(o.width," is invalid for output stride ")+"".concat(u,".")}))})(a,t.outputStride),this.inputResolution=a,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=uR),At(this,void 0,void 0,(function(){return Dt(this,(function(s){return[2,this.estimatePosesGPU(e,t,!1)]}))}))},n.prototype.estimatePosesGPU=function(e,t,s){return t===void 0&&(t=uR),s===void 0&&(s=!1),At(this,void 0,void 0,(function(){var r,i,a,o,u,c,d,p,m,g,x,b,v,w,N,I,$,E;return Dt(this,(function(D){switch(D.label){case 0:return r=(function(F){var L=F;if(L.maxPoses==null&&(L.maxPoses=1),L.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(L.maxPoses,". Should be > 0."));if(L.maxPoses>1){if((L=cn(cn({},mwe),L)).scoreThreshold<0||L.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(L.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(L.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(L.nmsRadius,"."))}return L})(t),e==null?[2,s?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=G2(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=i.imageTensor,o=i.padding,u=this.architecture==="ResNet50"?$e(a,gwe):gL(a,[-1,1]),c=this.posenetModel.predict(u),this.architecture==="ResNet50"?(d=Wt(c[2],[0]),p=Wt(c[3],[0]),m=Wt(c[0],[0]),g=Wt(c[1],[0])):(d=Wt(c[0],[0]),p=Wt(c[1],[0]),m=Wt(c[2],[0]),g=Wt(c[3],[0])),x=qr(p),this.maxPoses!==1?[3,5]:s?[4,Rwe(x,d,this.outputStride)]:[3,2]);case 1:return v=D.sent(),N=v[0],w=v[1],b=[N,w],[3,4];case 2:return[4,Ewe(x,d,this.outputStride)];case 3:N=D.sent(),b=[N],D.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,Swe(x,d,m,g,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:b=D.sent(),D.label=7;case 7:if(s){if(r.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");I=this.getCanvasInfo(Ch(e),this.inputResolution,o)}else E=Ch(e),$=(function(F,L,z,M){var O=L.height,H=L.width,X=O/(z.height*(1-M.top-M.bottom)),te=H/(z.width*(1-M.left-M.right)),Z=-M.top*z.height,W=-M.left*z.width;if(te===1&&X===1&&Z===0&&W===0)return F;for(var ee=0,ie=F;ee<ie.length;ee++)for(var de=0,ge=ie[ee].keypoints;de<ge.length;de++){var G=ge[de];G.x=(G.x+W)*te,G.y=(G.y+Z)*X}return F})(b,E,this.inputResolution,o),r.flipHorizontal&&($=(function(F,L){for(var z=0,M=F;z<M.length;z++)for(var O=0,H=M[z].keypoints;O<H.length;O++){var X=H[O];X.x=L.width-1-X.x}return F})($,E));return a.dispose(),u.dispose(),rt(c),d.dispose(),p.dispose(),m.dispose(),g.dispose(),x.dispose(),[2,s?[b,I]:$]}}))}))},n.prototype.getCanvasInfo=function(e,t,s){var r=e.height,i=e.width,a=r/(t.height*(1-s.top-s.bottom)),o=i/(t.width*(1-s.left-s.right)),u=-s.top*t.height;return[-s.left*t.width,u,o,a,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n})();function Awe(n){return n===void 0&&(n=rR),At(this,void 0,void 0,(function(){var e,t,s,r,i;return Dt(this,(function(a){switch(a.label){case 0:return(e=(function(d){var p=d||rR;if(p.architecture==null&&(p.architecture="MobileNetV1"),iR.indexOf(p.architecture)<0)throw new Error("Invalid architecture ".concat(p.architecture,". ")+"Should be one of ".concat(iR));if(p.inputResolution==null&&(p.inputResolution={height:257,width:257}),p.outputStride==null&&(p.outputStride=16),aR[p.architecture].indexOf(p.outputStride)<0)throw new Error("Invalid outputStride ".concat(p.outputStride,". ")+"Should be one of ".concat(aR[p.architecture]," ")+"for architecture ".concat(p.architecture,"."));if(p.multiplier==null&&(p.multiplier=1),oR[p.architecture].indexOf(p.multiplier)<0)throw new Error("Invalid multiplier ".concat(p.multiplier,". ")+"Should be one of ".concat(oR[p.architecture]," ")+"for architecture ".concat(p.architecture,"."));if(p.quantBytes==null&&(p.quantBytes=4),lR.indexOf(p.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(p.quantBytes,". ")+"Should be one of ".concat(lR," ")+"for architecture ".concat(p.architecture,"."));if(p.architecture==="MobileNetV1"&&p.outputStride===32&&p.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return p})(n)).architecture!=="ResNet50"?[3,2]:(o=e.outputStride,u=e.quantBytes,c="model-stride".concat(o,".json"),t=u===4?yR+"float/"+c:yR+"quant".concat(u,"/")+c,[4,gh(e.modelUrl||t)]);case 1:return s=a.sent(),[2,new bR(s,e)];case 2:return r=(function(d,p,m){var g={1:"100",.75:"075",.5:"050"},x="model-stride".concat(d,".json");return m===4?gR+"float/".concat(g[p],"/")+x:gR+"quant".concat(m,"/").concat(g[p],"/")+x})(e.outputStride,e.multiplier,e.quantBytes),[4,gh(e.modelUrl||r)];case 3:return i=a.sent(),[2,new bR(i,e)]}var o,u,c}))}))}function Dwe(n,e){return At(this,void 0,void 0,(function(){var t,s;return Dt(this,(function(r){switch(n){case va.PoseNet:return[2,Awe(e)];case va.BlazePose:if(s=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,awe(e)];if(t.runtime==="mediapipe")return[2,Dve(e)];s=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case va.MoveNet:return[2,pwe(e)];default:throw new Error("".concat(n," is not a supported model name."))}}))}))}const _we="savedSignsList";function Owe(){const[n,e]=Re.useState(!1),[t,s]=Re.useState("   "),[r,i]=Re.useState("      ."),[a,o]=Re.useState(!1),[u,c]=Re.useState(null),[d,p]=Re.useState([]),m=Re.useRef(null),g=Re.useRef(null);Re.useEffect(()=>(x(),I(),()=>{m.current&&clearInterval(m.current)}),[]);const x=async()=>{try{o(!0),s("     ..."),await v4();const $=await Dwe(va.MoveNet,{modelType:"Lightning"});c($),s("  ")}catch($){console.error("Model load failed",$),s("      "),c(null)}finally{o(!1)}},b=async $=>{if(!$)return null;if(d.length)return`  ( ): ${d[Math.floor(Math.random()*d.length)]}`;if(!u)return"    .       .";try{const E=await u.estimatePoses($);return E?.length&&(E[0].keypoints?.[0]?.score??0)>.4?" :      ":"     ."}catch(E){return console.error("Detection error",E),"   ."}},v=()=>{m.current&&clearInterval(m.current),m.current=setInterval(async()=>{const $=g.current?.video;if(!$||$.readyState<2)return;const E=await b($);E&&i(D=>`${E}.
${D}`)},3e3)},w=()=>{if(n){e(!1),s(" "),m.current&&clearInterval(m.current);return}e(!0),i("...     ..."),s(a?" ...":"  "),v()},N=()=>{i("  .")},I=()=>{const $=localStorage.getItem(_we);if($)try{const D=JSON.parse($).map(F=>F.word).filter(Boolean);p(D)}catch{p([])}};return q.jsxs("div",{className:"space-y-4 sm:space-y-6 px-3 sm:px-4 md:px-6 py-3 sm:py-4 md:py-6 max-w-7xl mx-auto",children:[q.jsxs("header",{className:"rounded-2xl sm:rounded-3xl bg-white p-4 sm:p-5 md:p-6 shadow-card",children:[q.jsx("p",{className:"text-xs sm:text-sm font-semibold text-blue-600 mb-2",children:"   ()"}),q.jsx("h1",{className:"text-lg sm:text-xl md:text-2xl font-bold text-slate-900 mb-2 sm:mb-3",children:"      "}),q.jsx("p",{className:"text-xs sm:text-sm text-slate-600 mb-4 sm:mb-5",children:" TensorFlow.js     (MoveNet)       ."}),q.jsxs("div",{className:"mt-4 flex flex-col sm:flex-row flex-wrap gap-2 sm:gap-3",children:[q.jsx("button",{onClick:w,disabled:a,className:`rounded-full px-4 sm:px-5 py-2.5 sm:py-3 text-xs sm:text-sm font-semibold text-white shadow-md transition w-full sm:w-auto ${n?"bg-rose-500 hover:bg-rose-600":"bg-primary hover:bg-blue-700"} ${a?"opacity-70 cursor-not-allowed":""}`,children:n?" ":"  "}),q.jsx("button",{onClick:N,className:"rounded-full border border-slate-200 px-4 sm:px-5 py-2.5 sm:py-3 text-xs sm:text-sm font-semibold text-slate-800 transition hover:bg-slate-100 w-full sm:w-auto",children:" "}),q.jsx("span",{className:"rounded-full bg-slate-100 px-3 sm:px-4 py-1.5 sm:py-2 text-xs font-semibold text-slate-700 text-center sm:text-right",children:a?"  ...":t})]})]}),q.jsxs("div",{className:"grid gap-4 sm:gap-5 md:gap-6 lg:grid-cols-2",children:[q.jsxs("section",{className:"relative overflow-hidden rounded-2xl sm:rounded-3xl border border-slate-200 bg-white shadow-card",children:[q.jsx("div",{className:"absolute inset-0 pointer-events-none rounded-2xl sm:rounded-3xl border-2 sm:border-4 border-dashed border-primary/40"}),q.jsxs("div",{className:"p-3 sm:p-4 md:p-5",children:[q.jsxs("div",{className:"flex items-center justify-between mb-3 sm:mb-4",children:[q.jsx("h2",{className:"text-base sm:text-lg font-bold text-slate-900",children:" "}),q.jsx("span",{className:"rounded-full bg-primary/10 px-2 sm:px-3 py-1 text-xs font-semibold text-primary whitespace-nowrap",children:" "})]}),q.jsx("div",{className:"mt-2 sm:mt-4 overflow-hidden rounded-xl sm:rounded-2xl bg-slate-900/80",children:n?q.jsx(OR,{ref:g,className:"aspect-video w-full object-cover",mirrored:!0,audio:!1,screenshotFormat:"image/jpeg",videoConstraints:{width:{ideal:1280},height:{ideal:720},facingMode:"user"}}):q.jsx("div",{className:"flex aspect-video items-center justify-center text-xs sm:text-sm text-slate-200 px-4 text-center",children:"     "})})]})]}),q.jsxs("section",{className:"rounded-2xl sm:rounded-3xl bg-white p-4 sm:p-5 md:p-6 shadow-card flex flex-col",children:[q.jsxs("div",{className:"flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2 sm:gap-0 mb-3 sm:mb-4",children:[q.jsxs("div",{className:"flex-1",children:[q.jsx("h2",{className:"text-base sm:text-lg font-bold text-slate-900 mb-1 sm:mb-2",children:"   "}),q.jsx("p",{className:"text-xs sm:text-sm text-slate-500",children:"   3          ."})]}),q.jsx("span",{className:"rounded-full bg-emerald-50 px-2 sm:px-3 py-1 text-xs font-semibold text-emerald-600 whitespace-nowrap",children:" "})]}),q.jsx("div",{className:"mt-2 sm:mt-4 flex-1 min-h-[200px] sm:min-h-[260px] md:min-h-[300px] lg:min-h-[320px] rounded-xl sm:rounded-2xl border border-slate-200 bg-slate-50 p-3 sm:p-4 text-right text-slate-800 overflow-auto",children:q.jsx("pre",{className:"whitespace-pre-wrap text-xs sm:text-sm leading-6 sm:leading-7 font-medium",children:r})})]})]})]})}const Oy=5,IL="savedSignsList",Fwe=()=>{if(typeof window>"u")return[];const n=window.localStorage.getItem(IL);if(!n)return[];try{return JSON.parse(n)}catch{return[]}};function zwe(){const[n,e]=Re.useState(""),[t,s]=Re.useState("     ."),[r,i]=Re.useState(!1),[a,o]=Re.useState(0),[u,c]=Re.useState(!1),[d,p]=Re.useState(()=>Fwe()),m=Re.useRef(null),g=Re.useRef(null);Re.useEffect(()=>()=>{m.current&&clearInterval(m.current)},[]),Re.useEffect(()=>{try{window.localStorage.setItem(IL,JSON.stringify(d))}catch{}},[d]);const x=()=>{if(!n.trim()){s("     .");return}m.current&&clearInterval(m.current),i(!0),o(0),c(!1),s(" ...     .");const N=Date.now();m.current=setInterval(()=>{const I=(Date.now()-N)/1e3,$=Math.min(100,Math.round(I/Oy*100));o($),I>=Oy&&(clearInterval(m.current),m.current=null,i(!1),c(!0),s(' .  " "  .'))},200)},b=()=>{const w=n.trim();if(!w){s("    .");return}const N={word:w,time:new Date().toLocaleTimeString("ar-EG",{hour:"2-digit",minute:"2-digit"})};p(I=>[N,...I]),s(`    : "${w}"`),c(!1),o(0)},v=()=>{e(""),s("  .    .")};return q.jsxs("div",{className:"space-y-6",children:[q.jsxs("header",{className:"rounded-3xl bg-white p-6 shadow-card",children:[q.jsx("p",{className:"text-sm font-semibold text-blue-600",children:"    "}),q.jsx("h1",{className:"text-2xl font-bold text-slate-900",children:"   ()"}),q.jsxs("p",{className:"text-sm text-slate-600",children:["        ",Oy,"       ."]})]}),q.jsxs("div",{className:"grid gap-4 lg:grid-cols-3",children:[q.jsx("div",{className:"lg:col-span-2 space-y-4",children:q.jsxs("section",{className:"rounded-3xl bg-white p-6 shadow-card space-y-4",children:[q.jsxs("div",{className:"flex flex-wrap items-center gap-3",children:[q.jsxs("div",{className:"flex-1 min-w-[220px]",children:[q.jsx("label",{className:"block text-sm font-semibold text-slate-700 mb-2",children:" "}),q.jsx("input",{type:"text",value:n,onChange:w=>e(w.target.value),className:"w-full rounded-2xl border border-slate-200 bg-slate-50 px-4 py-3 text-sm focus:border-primary focus:bg-white focus:outline-none",placeholder:': ""  ""'})]}),q.jsxs("div",{className:"flex gap-2",children:[q.jsx("button",{onClick:x,disabled:r,className:`rounded-full px-5 py-3 text-sm font-semibold text-white shadow-md transition ${r?"bg-slate-400 cursor-not-allowed":"bg-primary hover:bg-blue-700"}`,children:" "}),q.jsx("button",{onClick:v,className:"rounded-full border border-slate-200 px-4 py-3 text-sm font-semibold text-slate-800 transition hover:bg-slate-100",children:""})]})]}),q.jsxs("div",{className:"rounded-2xl border border-slate-200 bg-slate-50 p-4",children:[q.jsxs("div",{className:"flex items-center justify-between text-sm font-semibold text-slate-700",children:[q.jsxs("span",{children:[" : ",Oy," "]}),q.jsxs("span",{children:[a,"%"]})]}),q.jsx("div",{className:"mt-3 h-3 overflow-hidden rounded-full bg-slate-200",children:q.jsx("div",{className:"h-full bg-gradient-to-r from-primary to-secondary",style:{width:`${a}%`}})}),q.jsx("p",{className:"mt-2 text-xs text-slate-500",children:"     ."})]}),q.jsxs("div",{className:"rounded-3xl border border-slate-200 bg-white p-4 shadow-inner",children:[q.jsx("p",{className:"text-sm font-semibold text-slate-700",children:"  ()"}),q.jsx("div",{className:"mt-3 overflow-hidden rounded-2xl bg-slate-900/80",children:q.jsx(OR,{ref:g,className:"aspect-video w-full object-cover",mirrored:!0,audio:!1,screenshotFormat:"image/jpeg"})}),q.jsx("p",{className:"mt-2 text-xs text-slate-400",children:"            ."})]}),q.jsxs("div",{className:"flex flex-wrap gap-3",children:[q.jsx("button",{onClick:b,disabled:!u,className:`rounded-full px-5 py-3 text-sm font-semibold text-white shadow-md transition ${u?"bg-emerald-500 hover:bg-emerald-600":"bg-slate-400 cursor-not-allowed"}`,children:" "}),q.jsx("span",{className:"rounded-full bg-slate-100 px-4 py-2 text-xs font-semibold text-slate-700",children:t})]})]})}),q.jsx("aside",{className:"space-y-4",children:q.jsxs("div",{className:"rounded-3xl bg-white p-5 shadow-card",children:[q.jsx("h3",{className:"text-lg font-bold text-slate-900",children:" "}),q.jsx("p",{className:"text-sm text-slate-500",children:"     ()."}),d.length===0?q.jsx("div",{className:"mt-4 rounded-2xl border border-dashed border-slate-200 bg-slate-50 p-4 text-sm text-slate-500",children:"     ."}):q.jsx("ul",{className:"mt-4 space-y-3",children:d.map((w,N)=>q.jsxs("li",{className:"flex items-center justify-between rounded-2xl border border-slate-200 bg-slate-50 px-4 py-3 text-sm",children:[q.jsxs("div",{children:[q.jsx("p",{className:"font-semibold text-slate-900",children:w.word}),q.jsxs("p",{className:"text-xs text-slate-500",children:["   ",w.time]})]}),q.jsx("span",{className:"rounded-full bg-emerald-100 px-3 py-1 text-xs font-semibold text-emerald-700",children:""})]},`${w.word}-${N}`))})]})})]})]})}const Zc=({isActive:n})=>["px-4 py-2 rounded-full text-sm font-semibold transition-all duration-200",n?"bg-primary text-white shadow-md shadow-blue-200":"text-slate-700 hover:bg-slate-100"].join(" "),Jc=({isActive:n})=>["block w-full px-4 py-3 text-right text-sm font-semibold rounded-lg transition-all duration-200",n?"bg-primary text-white shadow-md":"text-slate-700 hover:bg-slate-100"].join(" ");function Lwe(){const{pathname:n}=Lu();return Re.useEffect(()=>{if(n!=="/"){const e=setTimeout(()=>{window.scrollTo({top:100,behavior:"smooth"})},100);return()=>clearTimeout(e)}else window.scrollTo({top:0,behavior:"smooth"})},[n]),null}function Mwe(){const[n,e]=Re.useState(!1),t=()=>{e(!n)},s=()=>{e(!1)};return q.jsxs(q.Fragment,{children:[q.jsx("header",{className:"border-b border-slate-200 bg-white/80 backdrop-blur sticky top-0 z-50",children:q.jsxs("div",{className:"mx-auto flex max-w-6xl items-center justify-between px-4 py-4",children:[q.jsxs("div",{className:"flex items-center gap-3",children:[q.jsx("div",{className:"flex h-12 w-12 items-center justify-center rounded-2xl bg-gradient-to-br from-primary to-secondary text-white shadow-md",children:q.jsx("span",{className:"text-lg font-bold",children:""})}),q.jsxs("div",{className:"hidden sm:block",children:[q.jsx("p",{className:"text-lg font-bold text-slate-900",children:"  "}),q.jsx("p",{className:"text-sm text-slate-500",children:"    "})]}),q.jsx("div",{className:"sm:hidden",children:q.jsx("p",{className:"text-base font-bold text-slate-900",children:"  "})})]}),q.jsxs("nav",{className:"hidden items-center gap-2 md:flex",children:[q.jsx(pi,{to:"/",className:Zc,children:""}),q.jsx(pi,{to:"/translation",className:Zc,children:""}),q.jsx(pi,{to:"/learning",className:Zc,children:""}),q.jsx(pi,{to:"/real-time-translation",className:Zc,children:" "}),q.jsx(pi,{to:"/training",className:Zc,children:" "}),q.jsx(pi,{to:"/about",className:Zc,children:" "})]}),q.jsx("button",{onClick:t,className:"md:hidden p-2 rounded-lg text-slate-700 hover:bg-slate-100 transition-colors z-50","aria-label":" ",children:q.jsx("svg",{className:"w-6 h-6",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:n?q.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M6 18L18 6M6 6l12 12"}):q.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M4 6h16M4 12h16M4 18h16"})})})]})}),n&&q.jsx("div",{className:"fixed inset-0 bg-black/50 z-40 md:hidden transition-opacity duration-300",onClick:s}),q.jsx("div",{className:`fixed top-0 right-0 h-full w-3/4 sm:w-1/3 md:w-1/4 bg-white shadow-2xl z-50 md:hidden transform transition-transform duration-300 ease-in-out ${n?"translate-x-0":"translate-x-full"}`,children:q.jsxs("div",{className:"flex flex-col h-full border-l border-slate-200",children:[q.jsxs("div",{className:"flex items-center justify-between p-4 sm:p-5 border-b border-slate-200 bg-gradient-to-br from-primary/5 to-secondary/5",children:[q.jsx("h2",{className:"text-base sm:text-lg font-bold text-slate-900",children:""}),q.jsx("button",{onClick:s,className:"p-2 rounded-lg text-slate-700 hover:bg-slate-100 transition-colors","aria-label":" ",children:q.jsx("svg",{className:"w-5 h-5",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:q.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M6 18L18 6M6 6l12 12"})})})]}),q.jsxs("nav",{className:"flex flex-col p-3 sm:p-4 gap-2 flex-1 overflow-y-auto",children:[q.jsx(pi,{to:"/",onClick:s,className:Jc,children:""}),q.jsx(pi,{to:"/translation",onClick:s,className:Jc,children:""}),q.jsx(pi,{to:"/learning",onClick:s,className:Jc,children:""}),q.jsx(pi,{to:"/real-time-translation",onClick:s,className:Jc,children:" "}),q.jsx(pi,{to:"/training",onClick:s,className:Jc,children:" "}),q.jsx(pi,{to:"/about",onClick:s,className:Jc,children:" "})]})]})})]})}function Pwe(){return q.jsxs(lB,{children:[q.jsx(Lwe,{}),q.jsxs("div",{className:"min-h-screen bg-slate-50 text-slate-900",children:[q.jsx(Mwe,{}),q.jsx("main",{className:"mx-auto max-w-6xl px-4 py-10",children:q.jsxs(eB,{children:[q.jsx(Qo,{path:"/",element:q.jsx(fB,{})}),q.jsx(Qo,{path:"/translation",element:q.jsx(yB,{})}),q.jsx(Qo,{path:"/learning",element:q.jsx(vB,{})}),q.jsx(Qo,{path:"/real-time-translation",element:q.jsx(Owe,{})}),q.jsx(Qo,{path:"/training",element:q.jsx(zwe,{})}),q.jsx(Qo,{path:"/about",element:q.jsx(IB,{})}),q.jsx(Qo,{path:"*",element:q.jsx(ZP,{to:"/",replace:!0})})]})}),q.jsx("footer",{className:"border-t border-slate-200 bg-white/70 py-6 text-center text-sm text-slate-500",children:"          ."})]})]})}uP.createRoot(document.getElementById("root")).render(q.jsx(Re.StrictMode,{children:q.jsx(Pwe,{})}));
